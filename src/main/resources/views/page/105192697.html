<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android性能优化：看完这篇文章,至少解决 APP 中 90 % 的内存异常问题</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-30 10:00:35                    </span>
                    <span class="read-count">阅读数 13</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-30 10:00:35</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9429255.html">
                                       程序员                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9721804.html">
                                       技术                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/105192697">https://blog.csdn.net/weixin_43901866/article/details/105192697</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a id="_0"></a>我们为什么要优化内存</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0wZDYwOTNmYTk0ZDQ2ZmFiLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>在 Android 中我们写的 .java 文件，最终会编译成 .class 文件, class 又由类装载器加载后，在 JVM 中会形成一份描述 class 结构的元信息对象，通过该元信息对象可以知道 class 的结构信息 (构造函数、属性、方法)等。JVM 会把描述类的数据从 class 文件加载到内存，Java 有一个很好的管理内存的机制，垃圾回收机制 GC 。为什么 Java 都给我们提供了垃圾回收机制，程序有时还会导致内存泄漏，内存溢出 OOM，甚至导致程序 Crash 。接下来我们就对实际开发中出现的这些内存问题，来进行优化。</p>
<h2><a id="JAVA__7"></a>JAVA 虚拟机</h2>
<p>我们先来大概了解一下 Java 虚拟机里面运行时的数据区域有哪些，如果想深入了解 Java 虚拟机 建议可以购买<a href="https://item.jd.com/11252778.html?dist=jd" rel="nofollow">&lt;&lt;深入理解 Java 虚拟机&gt;&gt;</a> <a href="https://pan.baidu.com/s/17WqfDh9ynQovuSgCCFqb8Q" rel="nofollow">或者直接点击我这里的 PDF 版本 密码: jmnf</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy05YWFiYjQ1OTMwN2I1M2NkLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="_14"></a>线程独占区</h3>
<p><strong>程序计数器</strong></p>
<ul>
<li>相当于一个执行代码的指示器，用来确认下一行执行的地址</li>
<li>每个线程都有一个</li>
<li>没有 OOM 的区</li>
</ul>
<p><strong>虚拟机栈</strong></p>
<ul>
<li>我们平时说的栈就是这块区域</li>
<li>java 虚拟机规范中定义了 OutOfMemeory , stackoverflow 异常</li>
</ul>
<p><strong>本地方法栈</strong></p>
<ul>
<li>java 虚拟机规范中定义了 OutOfMemory ，stackoverflow 异常</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>在 hotspotVM 中把虚拟机栈和本地方法栈合为了一个栈区</li>
</ul>
<h3><a id="_35"></a>线程共享区</h3>
<p><strong>方法区</strong></p>
<ul>
<li>ClassLoader 加载类信息</li>
<li>常量、静态变量</li>
<li>编译后的代码</li>
<li>会出现 OOM</li>
<li>运行时常量池
<ul>
<li>public static final</li>
<li>符号引用类、接口全名、方法名</li>
</ul>
</li>
</ul>
<p><strong>java 堆 (本次需要优化的地方)</strong></p>
<ul>
<li>虚拟机能管理的最大的一块内存 GC 主战场</li>
<li>会出现 OOM</li>
<li>对象实例</li>
<li>数据的内容</li>
</ul>
<h2><a id="JAVA_GC__54"></a>JAVA GC 如何确定内存回收</h2>
<p>随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。</p>
<p>目前虚拟机基本都是采用<strong>可达性分析算法</strong>，为什么不采用引用计数算法呢？下面就说说引用计数法是如果统计所有对象的引用计数的，再对比<strong>可达性分析算法</strong>是如何解决引用计数算法的不足。下面就来看下这 2 个算法：</p>
<h3><a id="_60"></a>引用计数算法</h3>
<p>每个对象有一个引用计数器，当对象被引用一次则计数器加一，当对象引用一次失效一次则计数器减一，对于计数器为 0 的时候就意味着是垃圾了，可以被 GC 回收。</p>
<p><strong>下面通过一段代码来实际看下</strong></p>
<pre><code>public class GCTest {
    private Object instace = null;

    public static void onGCtest() {
        //step 1
        GCTest gcTest1 = new GCTest();
        //step 2
        GCTest gcTest2 = new GCTest();
        //step 3
        gcTest1.instace = gcTest2;
        //step 4
        gcTest2.instace = gcTest1;
        //step 5
        gcTest1 = null;
        //step 6
        gcTest2 = null;

    }

    public static void main(String[] arg) {
        onGCtest();
    }
}
</code></pre>
<p><strong>分析代码</strong></p>
<pre><code>//step 1 gcTest1 引用 + 1 = 1
//step 2 gcTest2 引用 + 1 = 1
//step 3 gcTest1 引用 + 1 = 2
//step 4 gcTest2 引用 + 1 = 2
//step 5 gcTest1 引用 - 1 = 1
//step 6 gcTest2 引用 - 1 = 1

</code></pre>
<p>很明显现在 2 个对象都不能用了都为 null 了，但是 GC 确不能回收它们，因为它们本身的引用计数不为 0 。不能满足被回收的条件，尽管调用 System.gc() 也还是不能得到回收, 这就造成了 内存泄漏 。当然，现在虚拟机基本上都不采用此方式。</p>
<h3><a id="_106"></a>可达性分析算法</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1hZTcwYTA3NzNkZWE0M2ExLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>从 GC Roots 作为起点开始搜索，那么整个连通图中额对象边都是活对象，对于 GC Roots 无法到达的对象便成了垃圾回收的对象，随时可能被 GC 回收。</p>
<p><strong>可以作为 GC Roots 的对象</strong></p>
<ul>
<li>虚拟机栈正在运行使用的引用</li>
<li>静态属性 常量</li>
<li>JNI 引用的对象</li>
</ul>
<p>GC 是需要 2 次扫描才回收对象，所以我们可以使用 finalize 去救活丢失的引用</p>
<pre><code> @Override
    protected void finalize() throws Throwable {
        super.finalize();
        instace = this;
    }

</code></pre>
<p><strong>到了这里，相信大家已经能够弄明白这 2 个算法的区别了吧？反正对于对象之间循环引用的情况，引用计数算法无法回收这 2 个对象，而可达性是从 GC Roots 开始搜索，所以能够正确的回收。</strong></p>
<h3><a id="_132"></a>不同引用类型的回收状态</h3>
<h4><a id="_134"></a>强引用</h4>
<pre><code>Object strongReference = new Object()

</code></pre>
<p>如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足， Java 虚拟机宁愿抛出 OOM 错误，使程序异常 Crash ,也不会靠随意回收具有强引用的对象来解决内存不足的问题.如果强引用对象不再使用时，需要弱化从而使 GC 能够回收，需要：</p>
<pre><code>strongReference = null; //等 GC 来回收

</code></pre>
<p>还有一种情况，如果：</p>
<pre><code>public void onStrongReference(){
    Object strongReference = new Object()
}

</code></pre>
<p>在 onStrongReference() 内部有一个强引用，这个引用保存在 <em>java 栈</em> 中，而真正的引用内容 （Object）保存在 java 堆中。当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为 0 ，这个对象会被回收。</p>
<p>但是如果 mStrongReference 引用是全局时，就需要在不用这个对象时赋值为 null ,因为 强引用 不会被 GC 回收。</p>
<h4><a id="_SoftReference_161"></a>软引用 (SoftReference)</h4>
<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MDdhNDVmNzdkMDRmNmQzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>注意:</strong> 软引用对象是在 jvm 内存不够的时候才会被回收，我们调用 System.gc() 方法只是起通知作用， JVM 什么时候扫描回收对象是 JVM 自己的状态决定的。就算扫描到了 str 这个对象也不会回收，只有内存不足才会回收。</p>
<h4><a id="_WeakReference_172"></a>弱引用 (WeakReference)</h4>
<p>弱引用与软引用的区别在于: 只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0yODFmYWVhMDgxNDc1MTIzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>可见 weakReference 对象的生命周期基本由 GC 决定，一旦 GC 线程发现了弱引用就标记下来，第二次扫描到就直接回收了。</p>
<p>注意这里的 referenceQueuee 是装的被回收的对象。</p>
<h4><a id="_PhantomReference_185"></a>虚引用 (PhantomReference)</h4>
<pre><code>    @Test
    public void onPhantomReference()throws InterruptedException{
        String str = new String("123456");
        ReferenceQueue queue = new ReferenceQueue();
        // 创建虚引用，要求必须与一个引用队列关联
        PhantomReference pr = new PhantomReference(str, queue);
        System.out.println("PhantomReference:" + pr.get());
        System.out.printf("ReferenceQueue:" + queue.poll());
    }

</code></pre>
<p><strong>虚引用</strong>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列 (ReferenceQueue) 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h4><a id="_204"></a>总结</h4>

<table>
<thead>
<tr>
<th>引用类型</th>
<th>调用方式</th>
<th>GC</th>
<th>是否内存泄漏</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>直接调用</td>
<td>不回收</td>
<td>是</td>
</tr>
<tr>
<td>软引用</td>
<td>.get()</td>
<td>视内存情况回收</td>
<td>否</td>
</tr>
<tr>
<td>弱引用</td>
<td>.get()</td>
<td>回收</td>
<td>不可能</td>
</tr>
<tr>
<td>虚引用</td>
<td>null</td>
<td>任何时候都可能被回收，相当于没有引用一样</td>
<td>否</td>
</tr>
</tbody>
</table><h2><a id="_213"></a>分析内存常用工具</h2>
<p><strong>工具很多，掌握原理方法，工具随意挑选使用。</strong></p>
<h3><a id="topprocrank_217"></a>top/procrank</h3>
<h3><a id="meinfo_219"></a>meinfo</h3>
<h3><a id="Procstats_221"></a>Procstats</h3>
<h3><a id="DDMS_223"></a>DDMS</h3>
<h3><a id="MAT_225"></a>MAT</h3>
<h3><a id="Finder__Activity_227"></a>Finder - Activity</h3>
<h3><a id="LeakCanary_229"></a>LeakCanary</h3>
<h3><a id="LeakInspector_231"></a>LeakInspector</h3>
<h2><a id="_233"></a>内存泄漏</h2>
<p><strong>产生的原因:</strong> 一个长生命周期的对象持有一个短生命周期对象的引用，通俗点讲就是该回收的对象，因为引用问题没有被回收，最终会产生 OOM。</p>
<p>下面我们来利用 Profile 来检查项目是否有内存泄漏</p>
<h3><a id="_profile__239"></a>怎么利用 profile 来查看项目中是否有内存泄漏</h3>
<ol>
<li>在 AS 中项目以 profile 运行</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1kYTg0ZDM0MGM2MDBiNDBjLnBuZw?x-oss-process=image/format,png" alt=""></p>
<ol start="2">
<li>在 MEMORY 界面中选择要分析的一段内存，右键 export</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1jYjUxMTRkYjU1Y2M3OTc3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>**Allocations:** 动态分配对象个数

**Deallocation:** 解除分配的对象个数

**Total count:** 对象的总数

**Shalow Size:** 对象本身占用的内存大小

**Retained Size:** GC 回收能收走的内存大小
</code></pre>
<ol start="3">
<li>
<p>转换 profile 文件格式</p>
<ul>
<li>
<p>将 export 导出的 dprof 文件转换为 Mat 的 dprof 文件</p>
</li>
<li>
<p>cd /d 进入到 Android sdk/platform-tools/hprof-conv.exe</p>
<pre><code>//转换命令 hprof-conv -z src des
D:\Android\AndroidDeveloper-sdk\android-sdk-windows\platform-tools&gt;hprof-conv -z D:\temp_\temp_6.hprof D:\temp_\memory6.hprof

</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://www.eclipse.org/mat/downloads.php" rel="nofollow">下载 Mat 工具</a></p>
</li>
<li>
<p>打开 MemoryAnalyzer.exe 点击左上角 File 菜单中的 Open Heap Dupm</p>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0yMDIyYjU3MzQ2OTZmOGJiLnBuZw?x-oss-process=image/format,png" alt=""></p>
<ol start="6">
<li>查看内存泄漏中的 GC Roots 强引用</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MmEyNGMxNWZmOTQzZWI3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>这里我们得知是一个 ilsLoginListener 引用了 LoginView,我们来看下代码最后怎么解决的。
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1kYWVmZjk5ZTdlYzAwNzVhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>代码中我们找到了 LoginView 这个类，发现是一个单例中的回调引起的内存泄漏，下面怎么解决勒，请看第七小点。
</code></pre>
<ol start="7">
<li>
<p>2种解决单例中的内存泄漏</p>
<ol>
<li>
<p>将引用置为 null</p>
<pre><code>/**
     * 销毁监听
     */
    public void unRemoveRegisterListener(){
        mMessageController.unBindListener();
    }
    public void unBindListener(){
        if (listener != null){
            listener = null;
        }
    }

</code></pre>
</li>
<li>
<p>使用弱引用</p>
<pre><code>//将监听器放入弱引用中
WeakReference&lt;IBinderServiceListener&gt; listenerWeakReference = new WeakReference&lt;&gt;(listener);

//从弱引用中取出回调
listenerWeakReference.get()；

</code></pre>
</li>
</ol>
</li>
<li>
<p>通过第七小点就能完美的解决单例中回调引起的内存泄漏。</p>
</li>
</ol>
<h3><a id="Android__324"></a>Android 中常见的内存泄漏经典案例及解决方法</h3>
<ol>
<li>
<p>单例</p>
<p><strong>示例 :</strong></p>
<pre><code>public class AppManager {

    private static AppManager sInstance;
    private CallBack mCallBack;
    private Context mContext;

    private AppManager(Context context) {
        this.mContext = context;
    }

    public static AppManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new AppManager(context);
        }
        return sInstance;
    }

    public void addCallBack(CallBack call){
        mCallBack = call；
    }
}

</code></pre>
<ol>
<li>
<p>通过上面的单列，如果 context 传入的是 Activity , Service 的 this，那么就会导致内存泄漏。</p>
<p>以 Activity 为例，当 Activity 调用 getInstance 传入 this ，那么 sInstance 就会持有 Activity 的引用，当 Activity 需要关闭的时候需要 回收的时候，发现 sInstance 还持有 没有用的 Activity 引用，导致 Activity 无法被 GC 回收，就会造成内存泄漏</p>
</li>
<li>
<p>addCallBack(CallBack call) 这样写看起来是没有毛病的。但是当这样调用在看一下勒。</p>
<pre><code>//在 Activity 中实现单例的回调
AppManager.getInstance(getAppcationContext()).addCallBack(new CallBack(){
    @Override
    public void onStart(){

    }
})；

</code></pre>
<p>这里的 new CallBack() 匿名内部类 默认持有外部的引用，造成 CallBack 释放不了，那么怎么解决了，请看下面解决方法</p>
</li>
</ol>
<p><strong>解决方法</strong>:</p>
<ol>
<li>
<p>getInstance(Context context) context 都传入 Appcation 级别的 Context,或者实在是需要传入 Activity 的引用就用 WeakReference 这种形式。</p>
</li>
<li>
<p>匿名内部类建议大家单独写一个文件或者</p>
<pre><code>public void addCallBack(CallBack call){
        WeakReference&lt;CallBack&gt; mCallBack= new WeakReference&lt;CallBack&gt;(call)；
    }

</code></pre>
</li>
</ol>
</li>
<li>
<p>Handler</p>
<p><strong>示例:</strong></p>
<pre><code>//在 Activity 中实现 Handler
class MyHandler extends Handler{
    private Activity m;
    public MyHandler(Activity activity){
        m=activity;
    }

//    class.....
}

</code></pre>
<p>这里的 MyHandler 持有 activity 的引用，当 Activity 销毁的时候，导致 GC 不会回收造成 内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>1.使用静态内部类 + 弱引用
2.在 Activity onDestoty() 中处理  removeCallbacksAndMessages() 
    @Override
    protected void onDestroy() {
        super.onDestroy();
    if(null != handler){
          handler.removeCallbacksAndMessages(null);
          handler = null;
    }
 }

</code></pre>
</li>
<li>
<p>静态变量</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private static Police sPolice;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (sPolice != null) {
            sPolice = new Police(this);
        }
    }
}

class Police {
    public Police(Activity activity) {
    }
}

</code></pre>
<p>这里 Police 持有 activity 的引用，会造成 activity 得不到释放，导致内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//1\. sPolice 在 onDestory（）中 sPolice = null;
//2\. 在 Police 构造函数中 将强引用 to 弱引用；

</code></pre>
</li>
<li>
<p>非静态内部类</p>
<p>参考 第二点 Handler 的处理方式</p>
</li>
<li>
<p>匿名内部类</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      	new Thread(){
             @Override
             public void run() {
                super.run();
                        }
                    };
    }
}

</code></pre>
<p>很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程<code>Thread</code>和<code>AsyncTask</code>都是匿名内部类对象，默认就隐式的持有外部<code>Activity</code>的引用，导致<code>Activity</code>内存泄露。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//静态内部类 + 弱引用
//单独写一个文件 + onDestory  = null;

</code></pre>
</li>
<li>
<p>未取消注册或回调</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        registerReceiver(mReceiver, new IntentFilter());
    }

    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            // TODO ------
        }
    };
}

</code></pre>
<p>在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用<code>Retrofit + RxJava</code>注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//Activity 中实现 onDestory（）反注册广播得到释放
    @Override
    protected void onDestroy() {
        super.onDestroy();
        this.unregisterReceiver(mReceiver);
    }

</code></pre>
</li>
<li>
<p>定时任务</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    /**模拟计数*/
    private int mCount = 1;
    private Timer mTimer;
    private TimerTask mTimerTask;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
        mTimer.schedule(mTimerTask, 1000, 1000);
    }

    private void init() {
        mTimer = new Timer();
        mTimerTask = new TimerTask() {
            @Override
            public void run() {
                MainActivity.this.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        addCount();
                    }
                });
            }
        };
    }

    private void addCount() {
      mCount += 1;
    }
}

</code></pre>
<p>当我们<code>Activity</code>销毁的时，有可能<code>Timer</code>还在继续等待执行<code>TimerTask</code>，它持有Activity 的引用不能被 GC 回收，因此当我们 Activity 销毁的时候要立即<code>cancel</code>掉<code>Timer</code>和<code>TimerTask</code>，以避免发生内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//当 Activity 关闭的时候，停止一切正在进行中的定时任务，避免造成内存泄漏。
    private void stopTimer() {
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
        if (mTimerTask != null) {
            mTimerTask.cancel();
            mTimerTask = null;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        stopTimer();
    }

</code></pre>
</li>
<li>
<p>资源未关闭</p>
<p><strong>示例:</strong></p>
<pre><code>ArrayList,HashMap,IO,File,SqLite,Cursor 等资源用完一定要记得 clear remove 等关闭一系列对资源的操作。

</code></pre>
<p><strong>解决方法</strong>:</p>
<pre><code>用完即刻销毁

</code></pre>
</li>
<li>
<p>属性动画</p>
<p><strong>示例:</strong></p>
<pre><code>动画同样是一个耗时任务，比如在 Activity 中启动了属性动画 (ObjectAnimator) ，但是在销毁的时候，没有调用 cancle 方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用 Activity ，这就造成 Activity 无法正常释放。因此同样要在Activity 销毁的时候 cancel 掉属性动画，避免发生内存泄漏。

</code></pre>
<p><strong>解决方法</strong>:</p>
<pre><code>@Override
protected void onDestroy() {
    super.onDestroy();
    //当关闭 Activity 的时候记得关闭动画的操作
    mAnimator.cancel();
}

</code></pre>
</li>
<li>
<p>Android 源码或者第三方 SDK</p>
</li>
</ol>
<pre><code>**示例:**

```
//如果在开发调试中遇见 Android 源码或者 第三方 SDK 持有了我们当前的 Activity 或者其它类，那么现在怎么办了。

```

**解决方法**:

```
//当前是通过 Java 中的反射找到某个类或者成员，来进行手动 = null 的操作。

```
</code></pre>
<h2><a id="_652"></a>内存抖动</h2>
<h3><a id="_654"></a>什么是内存抖动</h3>
<p>内存频繁的分配与回收,(分配速度大于回收速度时) 最终产生 OOM 。</p>
<p><strong>也许下面的录屏更能解释什么是内存抖动</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04NWRlMGJmZjI1MzY3MmVmLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>可以看出当我点击了一下 Button 内存就频繁的创建并回收（注意看垃圾桶）。</p>
<p><strong>那么我们找出代码中具体那一块出现问题了勒，请看下面一段录屏</strong></p>
<pre><code>
mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imPrettySureSortingIsFree();
            }
        });

/**
     *&amp;emsp;排序后打印二维数组，一行行打印
     */
    public void imPrettySureSortingIsFree() {
        int dimension = 300;
        int[][] lotsOfInts = new int[dimension][dimension];
        Random randomGenerator = new Random();
        for (int i = 0; i &lt; lotsOfInts.length; i++) {
            for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                lotsOfInts[i][j] = randomGenerator.nextInt();
            }
        }

        for (int i = 0; i &lt; lotsOfInts.length; i++) {
            String rowAsStr = "";
            //排序
            int[] sorted = getSorted(lotsOfInts[i]);
            //拼接打印
            for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                rowAsStr += sorted[j];
                if (j &lt; (lotsOfInts[i].length - 1)) {
                    rowAsStr += ", ";
                }
            }
            Log.i("ricky", "Row " + i + ": " + rowAsStr);
        }
    }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1hMDc2ZTQ1YzMyYWNhNDgyLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>最后我们之后是 onClick 中的 imPrettySureSortingIsFree() 函数里面的 rowAsStr += sorted[j]; 字符串拼接造成的 内存抖动 ，因为每次拼接一个 String 都会申请一块新的堆内存，那么怎么解决这个频繁开辟内存的问题了。其实在 Java 中有 2 个更好的 API 对 String 的操作很友好，相信应该有人猜到了吧。没错就是将 此处的 String 换成 StringBuffer 或者 StringBuilder，就能很完美的解决字符串拼接造成的内存抖动问题。</p>
<p><strong>修改后</strong></p>
<pre><code>        /**
         *&amp;emsp;打印二维数组，一行行打印
         */
        public void imPrettySureSortingIsFree() {
            int dimension = 300;
            int[][] lotsOfInts = new int[dimension][dimension];
            Random randomGenerator = new Random();
            for(int i = 0; i &lt; lotsOfInts.length; i++) {
                for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                    lotsOfInts[i][j] = randomGenerator.nextInt();
                }
            }

            // 使用StringBuilder完成输出，我们只需要创建一个字符串即可，				不需要浪费过多的内存
            StringBuilder sb = new StringBuilder();
            String rowAsStr = "";
            for(int i = 0; i &lt; lotsOfInts.length; i++) {
                // 清除上一行
                sb.delete(0, rowAsStr.length());
                //排序
                int[] sorted = getSorted(lotsOfInts[i]);
                //拼接打印
                for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                    sb.append(sorted[j]);
                    if(j &lt; (lotsOfInts[i].length - 1)){
                        sb.append(", ");
                    }
                }
                rowAsStr = sb.toString();
                Log.i("jason", "Row " + i + ": " + rowAsStr);
            }
        }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03MzQ0NWI0NDM0YWIxZDA3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>这里可以看见没有垃圾桶出现，说明内存抖动解决了。</p>
<p><strong>注意</strong>: 实际开发中如果在 LogCat 中发现有这些 Log 说明也发生了 内存抖动 (Log 中出现 concurrent copying GC freed …)</p>
<h3><a id="_755"></a>回收算法</h3>
<p><a href="https://www.zhihu.com/question/35164211" rel="nofollow">ps:我觉得这个只是为了应付面试，那么可以参考这里，我也只了解概念这里就不用在多写了，点击看这个帖子吧</a></p>
<p><a href="https://juejin.im/post/5b4dea755188251ac1098e98" rel="nofollow">也可以参考掘金的这一篇 GC 回收算法</a></p>
<h3><a id="_MarkSweep_761"></a>标记清除算法 Mark-Sweep</h3>
<h3><a id="_Copying_763"></a>复制算法 Copying</h3>
<h3><a id="_MarkCompact_765"></a>标记压缩算法 Mark-Compact</h3>
<h3><a id="_767"></a>分代收集算法</h3>
<h2><a id="__90___769"></a>总结 (只要养成这样的习惯，至少可以避免 90 % 以上不会造成内存异常)</h2>
<ol>
<li>
<p>数据类型: 不要使用比需求更占用空间的基本数据类型</p>
</li>
<li>
<p>循环尽量用 foreach ,少用 iterator, 自动装箱也尽量少用</p>
</li>
<li>
<p>数据结构与算法的解度处理 (数组，链表，栈树，树，图)</p>
<ul>
<li>数据量千级以内可以使用 Sparse 数组 (Key为整数)，ArrayMap (Key 为对象) 虽然性能不如 HashMap ，但节约内存。</li>
</ul>
</li>
<li>
<p>枚举优化</p>
<p><strong>缺点</strong>:</p>
<ul>
<li>每一个枚举值都是一个单例对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存</li>
<li>较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的 IO 开销,使我们的应用需要更多的空间</li>
<li>特别是分 Dex 多的大型 APP，枚举的初始化很容易导致 ANR</li>
</ul>
<p>优化后的代码:可以直接限定传入的参数个数</p>
<pre><code>public class SHAPE {
    public static final int TYPE_0=0;
    public static final int TYPE_1=1;
    public static final int TYPE_2=2;
    public static final int TYPE_3=3;

    @IntDef(flag=true,value={TYPE_0,TYPE_1,TYPE_2,TYPE_3})
    @Target({ElementType.PARAMETER,ElementType.METHOD,ElementType.FIELD})
    @Retention(RetentionPolicy.SOURCE)
    public @interface Model{

    }

    private @Model int value=TYPE_0;
    public void setShape(@Model int value){
        this.value=value;
    }
    @Model
    public int getShape(){
        return this.value;
    }
}


</code></pre>
</li>
<li>
<p>static , static final 的问题</p>
<ul>
<li>static 会由编译器调用 clinit 方法进行初始化</li>
<li>static final 不需要进行初始化工作，打包在 dex 文件中可以直接调用，并不会在类初始化申请内存</li>
</ul>
<p>基本数据类型的成员，可以全写成 static final</p>
</li>
<li>
<p>字符串的拼接尽量少用 +=</p>
</li>
<li>
<p>重复申请内存问题</p>
<ul>
<li>同一个方法多次调用，如递归函数 ，回调函数中 new 对象</li>
<li>不要在 onMeause() onLayout() ,onDraw() 中去刷新UI（requestLayout）</li>
</ul>
</li>
<li>
<p>避免 GC 回收将来要重新使用的对象 (内存设计模式对象池 + LRU 算法)</p>
</li>
<li>
<p>Activity 组件泄漏</p>
<ul>
<li>非业务需要不要把 activity 的上下文做参数传递，可以传递 application 的上下文</li>
<li>非静态内部类和匿名内部内会持有 activity 引用（静态内部类 或者 单独写文件）</li>
<li>单例模式中回调持有 activity 引用（弱引用）</li>
<li>handler.postDelayed() 问题
<ul>
<li>如果开启的线程需要传入参数，用弱引接收可解决问题</li>
<li>handler 记得清除 removeCallbacksAndMessages(null)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Service 耗时操作尽量使用 IntentService,而不是 Service</p>
</li>
</ol>
<p>最后思维导图做一个总结:<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0zMTUzOTAwZGJkNTQ4YzEzLnBuZw?x-oss-process=image/format,png" alt=""><br>
<strong>推荐阅读：<a href="https://www.jianshu.com/p/0d7808bdffec" rel="nofollow">2020最新Android大厂高频面试题解析大全(BAT TMD JD 小米)<br>
</a></strong><br>
<strong><a href="https://www.jianshu.com/p/f682173f1607" rel="nofollow">2020最新BAT Android高端技术面试145题详解</a></strong><br>
<strong><a href="https://www.jianshu.com/p/100e8044ce90" rel="nofollow">2019年鸿洋大神最新整理一线互联网公司Android中高级面试题总结（附答案解析）</a></strong><br>
<strong><a href="https://www.jianshu.com/p/7f9ade51232e" rel="nofollow">2017-2020历年字节跳动Android面试真题解析（累计下载1082万次，持续更新中）<br>
</a></strong></p>
<p>作者：DevYK<br>
链接：https://juejin.im/post/5cd82a3ee51d456e781f20ce<br>
来源：掘金</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android性能优化：看完这篇文章,至少解决 APP 中 90 % 的内存异常问题</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-30 10:00:35                    </span>
                    <span class="read-count">阅读数 13</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-30 10:00:35</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9429255.html">
                                       程序员                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9721804.html">
                                       技术                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/105192697">https://blog.csdn.net/weixin_43901866/article/details/105192697</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a id="_0"></a>我们为什么要优化内存</h2>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0wZDYwOTNmYTk0ZDQ2ZmFiLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>在 Android 中我们写的 .java 文件，最终会编译成 .class 文件, class 又由类装载器加载后，在 JVM 中会形成一份描述 class 结构的元信息对象，通过该元信息对象可以知道 class 的结构信息 (构造函数、属性、方法)等。JVM 会把描述类的数据从 class 文件加载到内存，Java 有一个很好的管理内存的机制，垃圾回收机制 GC 。为什么 Java 都给我们提供了垃圾回收机制，程序有时还会导致内存泄漏，内存溢出 OOM，甚至导致程序 Crash 。接下来我们就对实际开发中出现的这些内存问题，来进行优化。</p>
<h2><a id="JAVA__7"></a>JAVA 虚拟机</h2>
<p>我们先来大概了解一下 Java 虚拟机里面运行时的数据区域有哪些，如果想深入了解 Java 虚拟机 建议可以购买<a href="https://item.jd.com/11252778.html?dist=jd" rel="nofollow">&lt;&lt;深入理解 Java 虚拟机&gt;&gt;</a> <a href="https://pan.baidu.com/s/17WqfDh9ynQovuSgCCFqb8Q" rel="nofollow">或者直接点击我这里的 PDF 版本 密码: jmnf</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy05YWFiYjQ1OTMwN2I1M2NkLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="_14"></a>线程独占区</h3>
<p><strong>程序计数器</strong></p>
<ul>
<li>相当于一个执行代码的指示器，用来确认下一行执行的地址</li>
<li>每个线程都有一个</li>
<li>没有 OOM 的区</li>
</ul>
<p><strong>虚拟机栈</strong></p>
<ul>
<li>我们平时说的栈就是这块区域</li>
<li>java 虚拟机规范中定义了 OutOfMemeory , stackoverflow 异常</li>
</ul>
<p><strong>本地方法栈</strong></p>
<ul>
<li>java 虚拟机规范中定义了 OutOfMemory ，stackoverflow 异常</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>在 hotspotVM 中把虚拟机栈和本地方法栈合为了一个栈区</li>
</ul>
<h3><a id="_35"></a>线程共享区</h3>
<p><strong>方法区</strong></p>
<ul>
<li>ClassLoader 加载类信息</li>
<li>常量、静态变量</li>
<li>编译后的代码</li>
<li>会出现 OOM</li>
<li>运行时常量池
<ul>
<li>public static final</li>
<li>符号引用类、接口全名、方法名</li>
</ul>
</li>
</ul>
<p><strong>java 堆 (本次需要优化的地方)</strong></p>
<ul>
<li>虚拟机能管理的最大的一块内存 GC 主战场</li>
<li>会出现 OOM</li>
<li>对象实例</li>
<li>数据的内容</li>
</ul>
<h2><a id="JAVA_GC__54"></a>JAVA GC 如何确定内存回收</h2>
<p>随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。</p>
<p>目前虚拟机基本都是采用<strong>可达性分析算法</strong>，为什么不采用引用计数算法呢？下面就说说引用计数法是如果统计所有对象的引用计数的，再对比<strong>可达性分析算法</strong>是如何解决引用计数算法的不足。下面就来看下这 2 个算法：</p>
<h3><a id="_60"></a>引用计数算法</h3>
<p>每个对象有一个引用计数器，当对象被引用一次则计数器加一，当对象引用一次失效一次则计数器减一，对于计数器为 0 的时候就意味着是垃圾了，可以被 GC 回收。</p>
<p><strong>下面通过一段代码来实际看下</strong></p>
<pre><code>public class GCTest {
    private Object instace = null;

    public static void onGCtest() {
        //step 1
        GCTest gcTest1 = new GCTest();
        //step 2
        GCTest gcTest2 = new GCTest();
        //step 3
        gcTest1.instace = gcTest2;
        //step 4
        gcTest2.instace = gcTest1;
        //step 5
        gcTest1 = null;
        //step 6
        gcTest2 = null;

    }

    public static void main(String[] arg) {
        onGCtest();
    }
}
</code></pre>
<p><strong>分析代码</strong></p>
<pre><code>//step 1 gcTest1 引用 + 1 = 1
//step 2 gcTest2 引用 + 1 = 1
//step 3 gcTest1 引用 + 1 = 2
//step 4 gcTest2 引用 + 1 = 2
//step 5 gcTest1 引用 - 1 = 1
//step 6 gcTest2 引用 - 1 = 1

</code></pre>
<p>很明显现在 2 个对象都不能用了都为 null 了，但是 GC 确不能回收它们，因为它们本身的引用计数不为 0 。不能满足被回收的条件，尽管调用 System.gc() 也还是不能得到回收, 这就造成了 内存泄漏 。当然，现在虚拟机基本上都不采用此方式。</p>
<h3><a id="_106"></a>可达性分析算法</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1hZTcwYTA3NzNkZWE0M2ExLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>从 GC Roots 作为起点开始搜索，那么整个连通图中额对象边都是活对象，对于 GC Roots 无法到达的对象便成了垃圾回收的对象，随时可能被 GC 回收。</p>
<p><strong>可以作为 GC Roots 的对象</strong></p>
<ul>
<li>虚拟机栈正在运行使用的引用</li>
<li>静态属性 常量</li>
<li>JNI 引用的对象</li>
</ul>
<p>GC 是需要 2 次扫描才回收对象，所以我们可以使用 finalize 去救活丢失的引用</p>
<pre><code> @Override
    protected void finalize() throws Throwable {
        super.finalize();
        instace = this;
    }

</code></pre>
<p><strong>到了这里，相信大家已经能够弄明白这 2 个算法的区别了吧？反正对于对象之间循环引用的情况，引用计数算法无法回收这 2 个对象，而可达性是从 GC Roots 开始搜索，所以能够正确的回收。</strong></p>
<h3><a id="_132"></a>不同引用类型的回收状态</h3>
<h4><a id="_134"></a>强引用</h4>
<pre><code>Object strongReference = new Object()

</code></pre>
<p>如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足， Java 虚拟机宁愿抛出 OOM 错误，使程序异常 Crash ,也不会靠随意回收具有强引用的对象来解决内存不足的问题.如果强引用对象不再使用时，需要弱化从而使 GC 能够回收，需要：</p>
<pre><code>strongReference = null; //等 GC 来回收

</code></pre>
<p>还有一种情况，如果：</p>
<pre><code>public void onStrongReference(){
    Object strongReference = new Object()
}

</code></pre>
<p>在 onStrongReference() 内部有一个强引用，这个引用保存在 <em>java 栈</em> 中，而真正的引用内容 （Object）保存在 java 堆中。当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为 0 ，这个对象会被回收。</p>
<p>但是如果 mStrongReference 引用是全局时，就需要在不用这个对象时赋值为 null ,因为 强引用 不会被 GC 回收。</p>
<h4><a id="_SoftReference_161"></a>软引用 (SoftReference)</h4>
<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MDdhNDVmNzdkMDRmNmQzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>注意:</strong> 软引用对象是在 jvm 内存不够的时候才会被回收，我们调用 System.gc() 方法只是起通知作用， JVM 什么时候扫描回收对象是 JVM 自己的状态决定的。就算扫描到了 str 这个对象也不会回收，只有内存不足才会回收。</p>
<h4><a id="_WeakReference_172"></a>弱引用 (WeakReference)</h4>
<p>弱引用与软引用的区别在于: 只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0yODFmYWVhMDgxNDc1MTIzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>可见 weakReference 对象的生命周期基本由 GC 决定，一旦 GC 线程发现了弱引用就标记下来，第二次扫描到就直接回收了。</p>
<p>注意这里的 referenceQueuee 是装的被回收的对象。</p>
<h4><a id="_PhantomReference_185"></a>虚引用 (PhantomReference)</h4>
<pre><code>    @Test
    public void onPhantomReference()throws InterruptedException{
        String str = new String("123456");
        ReferenceQueue queue = new ReferenceQueue();
        // 创建虚引用，要求必须与一个引用队列关联
        PhantomReference pr = new PhantomReference(str, queue);
        System.out.println("PhantomReference:" + pr.get());
        System.out.printf("ReferenceQueue:" + queue.poll());
    }

</code></pre>
<p><strong>虚引用</strong>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列 (ReferenceQueue) 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h4><a id="_204"></a>总结</h4>

<table>
<thead>
<tr>
<th>引用类型</th>
<th>调用方式</th>
<th>GC</th>
<th>是否内存泄漏</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>直接调用</td>
<td>不回收</td>
<td>是</td>
</tr>
<tr>
<td>软引用</td>
<td>.get()</td>
<td>视内存情况回收</td>
<td>否</td>
</tr>
<tr>
<td>弱引用</td>
<td>.get()</td>
<td>回收</td>
<td>不可能</td>
</tr>
<tr>
<td>虚引用</td>
<td>null</td>
<td>任何时候都可能被回收，相当于没有引用一样</td>
<td>否</td>
</tr>
</tbody>
</table><h2><a id="_213"></a>分析内存常用工具</h2>
<p><strong>工具很多，掌握原理方法，工具随意挑选使用。</strong></p>
<h3><a id="topprocrank_217"></a>top/procrank</h3>
<h3><a id="meinfo_219"></a>meinfo</h3>
<h3><a id="Procstats_221"></a>Procstats</h3>
<h3><a id="DDMS_223"></a>DDMS</h3>
<h3><a id="MAT_225"></a>MAT</h3>
<h3><a id="Finder__Activity_227"></a>Finder - Activity</h3>
<h3><a id="LeakCanary_229"></a>LeakCanary</h3>
<h3><a id="LeakInspector_231"></a>LeakInspector</h3>
<h2><a id="_233"></a>内存泄漏</h2>
<p><strong>产生的原因:</strong> 一个长生命周期的对象持有一个短生命周期对象的引用，通俗点讲就是该回收的对象，因为引用问题没有被回收，最终会产生 OOM。</p>
<p>下面我们来利用 Profile 来检查项目是否有内存泄漏</p>
<h3><a id="_profile__239"></a>怎么利用 profile 来查看项目中是否有内存泄漏</h3>
<ol>
<li>在 AS 中项目以 profile 运行</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1kYTg0ZDM0MGM2MDBiNDBjLnBuZw?x-oss-process=image/format,png" alt=""></p>
<ol start="2">
<li>在 MEMORY 界面中选择要分析的一段内存，右键 export</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1jYjUxMTRkYjU1Y2M3OTc3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>**Allocations:** 动态分配对象个数

**Deallocation:** 解除分配的对象个数

**Total count:** 对象的总数

**Shalow Size:** 对象本身占用的内存大小

**Retained Size:** GC 回收能收走的内存大小
</code></pre>
<ol start="3">
<li>
<p>转换 profile 文件格式</p>
<ul>
<li>
<p>将 export 导出的 dprof 文件转换为 Mat 的 dprof 文件</p>
</li>
<li>
<p>cd /d 进入到 Android sdk/platform-tools/hprof-conv.exe</p>
<pre><code>//转换命令 hprof-conv -z src des
D:\Android\AndroidDeveloper-sdk\android-sdk-windows\platform-tools&gt;hprof-conv -z D:\temp_\temp_6.hprof D:\temp_\memory6.hprof

</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://www.eclipse.org/mat/downloads.php" rel="nofollow">下载 Mat 工具</a></p>
</li>
<li>
<p>打开 MemoryAnalyzer.exe 点击左上角 File 菜单中的 Open Heap Dupm</p>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0yMDIyYjU3MzQ2OTZmOGJiLnBuZw?x-oss-process=image/format,png" alt=""></p>
<ol start="6">
<li>查看内存泄漏中的 GC Roots 强引用</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MmEyNGMxNWZmOTQzZWI3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>这里我们得知是一个 ilsLoginListener 引用了 LoginView,我们来看下代码最后怎么解决的。
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1kYWVmZjk5ZTdlYzAwNzVhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<pre><code>代码中我们找到了 LoginView 这个类，发现是一个单例中的回调引起的内存泄漏，下面怎么解决勒，请看第七小点。
</code></pre>
<ol start="7">
<li>
<p>2种解决单例中的内存泄漏</p>
<ol>
<li>
<p>将引用置为 null</p>
<pre><code>/**
     * 销毁监听
     */
    public void unRemoveRegisterListener(){
        mMessageController.unBindListener();
    }
    public void unBindListener(){
        if (listener != null){
            listener = null;
        }
    }

</code></pre>
</li>
<li>
<p>使用弱引用</p>
<pre><code>//将监听器放入弱引用中
WeakReference&lt;IBinderServiceListener&gt; listenerWeakReference = new WeakReference&lt;&gt;(listener);

//从弱引用中取出回调
listenerWeakReference.get()；

</code></pre>
</li>
</ol>
</li>
<li>
<p>通过第七小点就能完美的解决单例中回调引起的内存泄漏。</p>
</li>
</ol>
<h3><a id="Android__324"></a>Android 中常见的内存泄漏经典案例及解决方法</h3>
<ol>
<li>
<p>单例</p>
<p><strong>示例 :</strong></p>
<pre><code>public class AppManager {

    private static AppManager sInstance;
    private CallBack mCallBack;
    private Context mContext;

    private AppManager(Context context) {
        this.mContext = context;
    }

    public static AppManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new AppManager(context);
        }
        return sInstance;
    }

    public void addCallBack(CallBack call){
        mCallBack = call；
    }
}

</code></pre>
<ol>
<li>
<p>通过上面的单列，如果 context 传入的是 Activity , Service 的 this，那么就会导致内存泄漏。</p>
<p>以 Activity 为例，当 Activity 调用 getInstance 传入 this ，那么 sInstance 就会持有 Activity 的引用，当 Activity 需要关闭的时候需要 回收的时候，发现 sInstance 还持有 没有用的 Activity 引用，导致 Activity 无法被 GC 回收，就会造成内存泄漏</p>
</li>
<li>
<p>addCallBack(CallBack call) 这样写看起来是没有毛病的。但是当这样调用在看一下勒。</p>
<pre><code>//在 Activity 中实现单例的回调
AppManager.getInstance(getAppcationContext()).addCallBack(new CallBack(){
    @Override
    public void onStart(){

    }
})；

</code></pre>
<p>这里的 new CallBack() 匿名内部类 默认持有外部的引用，造成 CallBack 释放不了，那么怎么解决了，请看下面解决方法</p>
</li>
</ol>
<p><strong>解决方法</strong>:</p>
<ol>
<li>
<p>getInstance(Context context) context 都传入 Appcation 级别的 Context,或者实在是需要传入 Activity 的引用就用 WeakReference 这种形式。</p>
</li>
<li>
<p>匿名内部类建议大家单独写一个文件或者</p>
<pre><code>public void addCallBack(CallBack call){
        WeakReference&lt;CallBack&gt; mCallBack= new WeakReference&lt;CallBack&gt;(call)；
    }

</code></pre>
</li>
</ol>
</li>
<li>
<p>Handler</p>
<p><strong>示例:</strong></p>
<pre><code>//在 Activity 中实现 Handler
class MyHandler extends Handler{
    private Activity m;
    public MyHandler(Activity activity){
        m=activity;
    }

//    class.....
}

</code></pre>
<p>这里的 MyHandler 持有 activity 的引用，当 Activity 销毁的时候，导致 GC 不会回收造成 内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>1.使用静态内部类 + 弱引用
2.在 Activity onDestoty() 中处理  removeCallbacksAndMessages() 
    @Override
    protected void onDestroy() {
        super.onDestroy();
    if(null != handler){
          handler.removeCallbacksAndMessages(null);
          handler = null;
    }
 }

</code></pre>
</li>
<li>
<p>静态变量</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private static Police sPolice;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (sPolice != null) {
            sPolice = new Police(this);
        }
    }
}

class Police {
    public Police(Activity activity) {
    }
}

</code></pre>
<p>这里 Police 持有 activity 的引用，会造成 activity 得不到释放，导致内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//1\. sPolice 在 onDestory（）中 sPolice = null;
//2\. 在 Police 构造函数中 将强引用 to 弱引用；

</code></pre>
</li>
<li>
<p>非静态内部类</p>
<p>参考 第二点 Handler 的处理方式</p>
</li>
<li>
<p>匿名内部类</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      	new Thread(){
             @Override
             public void run() {
                super.run();
                        }
                    };
    }
}

</code></pre>
<p>很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程<code>Thread</code>和<code>AsyncTask</code>都是匿名内部类对象，默认就隐式的持有外部<code>Activity</code>的引用，导致<code>Activity</code>内存泄露。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//静态内部类 + 弱引用
//单独写一个文件 + onDestory  = null;

</code></pre>
</li>
<li>
<p>未取消注册或回调</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        registerReceiver(mReceiver, new IntentFilter());
    }

    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            // TODO ------
        }
    };
}

</code></pre>
<p>在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用<code>Retrofit + RxJava</code>注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//Activity 中实现 onDestory（）反注册广播得到释放
    @Override
    protected void onDestroy() {
        super.onDestroy();
        this.unregisterReceiver(mReceiver);
    }

</code></pre>
</li>
<li>
<p>定时任务</p>
<p><strong>示例:</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    /**模拟计数*/
    private int mCount = 1;
    private Timer mTimer;
    private TimerTask mTimerTask;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
        mTimer.schedule(mTimerTask, 1000, 1000);
    }

    private void init() {
        mTimer = new Timer();
        mTimerTask = new TimerTask() {
            @Override
            public void run() {
                MainActivity.this.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        addCount();
                    }
                });
            }
        };
    }

    private void addCount() {
      mCount += 1;
    }
}

</code></pre>
<p>当我们<code>Activity</code>销毁的时，有可能<code>Timer</code>还在继续等待执行<code>TimerTask</code>，它持有Activity 的引用不能被 GC 回收，因此当我们 Activity 销毁的时候要立即<code>cancel</code>掉<code>Timer</code>和<code>TimerTask</code>，以避免发生内存泄漏。</p>
<p><strong>解决方法</strong>:</p>
<pre><code>//当 Activity 关闭的时候，停止一切正在进行中的定时任务，避免造成内存泄漏。
    private void stopTimer() {
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
        if (mTimerTask != null) {
            mTimerTask.cancel();
            mTimerTask = null;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        stopTimer();
    }

</code></pre>
</li>
<li>
<p>资源未关闭</p>
<p><strong>示例:</strong></p>
<pre><code>ArrayList,HashMap,IO,File,SqLite,Cursor 等资源用完一定要记得 clear remove 等关闭一系列对资源的操作。

</code></pre>
<p><strong>解决方法</strong>:</p>
<pre><code>用完即刻销毁

</code></pre>
</li>
<li>
<p>属性动画</p>
<p><strong>示例:</strong></p>
<pre><code>动画同样是一个耗时任务，比如在 Activity 中启动了属性动画 (ObjectAnimator) ，但是在销毁的时候，没有调用 cancle 方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用 Activity ，这就造成 Activity 无法正常释放。因此同样要在Activity 销毁的时候 cancel 掉属性动画，避免发生内存泄漏。

</code></pre>
<p><strong>解决方法</strong>:</p>
<pre><code>@Override
protected void onDestroy() {
    super.onDestroy();
    //当关闭 Activity 的时候记得关闭动画的操作
    mAnimator.cancel();
}

</code></pre>
</li>
<li>
<p>Android 源码或者第三方 SDK</p>
</li>
</ol>
<pre><code>**示例:**

```
//如果在开发调试中遇见 Android 源码或者 第三方 SDK 持有了我们当前的 Activity 或者其它类，那么现在怎么办了。

```

**解决方法**:

```
//当前是通过 Java 中的反射找到某个类或者成员，来进行手动 = null 的操作。

```
</code></pre>
<h2><a id="_652"></a>内存抖动</h2>
<h3><a id="_654"></a>什么是内存抖动</h3>
<p>内存频繁的分配与回收,(分配速度大于回收速度时) 最终产生 OOM 。</p>
<p><strong>也许下面的录屏更能解释什么是内存抖动</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04NWRlMGJmZjI1MzY3MmVmLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>可以看出当我点击了一下 Button 内存就频繁的创建并回收（注意看垃圾桶）。</p>
<p><strong>那么我们找出代码中具体那一块出现问题了勒，请看下面一段录屏</strong></p>
<pre><code>
mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imPrettySureSortingIsFree();
            }
        });

/**
     *&amp;emsp;排序后打印二维数组，一行行打印
     */
    public void imPrettySureSortingIsFree() {
        int dimension = 300;
        int[][] lotsOfInts = new int[dimension][dimension];
        Random randomGenerator = new Random();
        for (int i = 0; i &lt; lotsOfInts.length; i++) {
            for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                lotsOfInts[i][j] = randomGenerator.nextInt();
            }
        }

        for (int i = 0; i &lt; lotsOfInts.length; i++) {
            String rowAsStr = "";
            //排序
            int[] sorted = getSorted(lotsOfInts[i]);
            //拼接打印
            for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                rowAsStr += sorted[j];
                if (j &lt; (lotsOfInts[i].length - 1)) {
                    rowAsStr += ", ";
                }
            }
            Log.i("ricky", "Row " + i + ": " + rowAsStr);
        }
    }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1hMDc2ZTQ1YzMyYWNhNDgyLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>最后我们之后是 onClick 中的 imPrettySureSortingIsFree() 函数里面的 rowAsStr += sorted[j]; 字符串拼接造成的 内存抖动 ，因为每次拼接一个 String 都会申请一块新的堆内存，那么怎么解决这个频繁开辟内存的问题了。其实在 Java 中有 2 个更好的 API 对 String 的操作很友好，相信应该有人猜到了吧。没错就是将 此处的 String 换成 StringBuffer 或者 StringBuilder，就能很完美的解决字符串拼接造成的内存抖动问题。</p>
<p><strong>修改后</strong></p>
<pre><code>        /**
         *&amp;emsp;打印二维数组，一行行打印
         */
        public void imPrettySureSortingIsFree() {
            int dimension = 300;
            int[][] lotsOfInts = new int[dimension][dimension];
            Random randomGenerator = new Random();
            for(int i = 0; i &lt; lotsOfInts.length; i++) {
                for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                    lotsOfInts[i][j] = randomGenerator.nextInt();
                }
            }

            // 使用StringBuilder完成输出，我们只需要创建一个字符串即可，				不需要浪费过多的内存
            StringBuilder sb = new StringBuilder();
            String rowAsStr = "";
            for(int i = 0; i &lt; lotsOfInts.length; i++) {
                // 清除上一行
                sb.delete(0, rowAsStr.length());
                //排序
                int[] sorted = getSorted(lotsOfInts[i]);
                //拼接打印
                for (int j = 0; j &lt; lotsOfInts[i].length; j++) {
                    sb.append(sorted[j]);
                    if(j &lt; (lotsOfInts[i].length - 1)){
                        sb.append(", ");
                    }
                }
                rowAsStr = sb.toString();
                Log.i("jason", "Row " + i + ": " + rowAsStr);
            }
        }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03MzQ0NWI0NDM0YWIxZDA3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>这里可以看见没有垃圾桶出现，说明内存抖动解决了。</p>
<p><strong>注意</strong>: 实际开发中如果在 LogCat 中发现有这些 Log 说明也发生了 内存抖动 (Log 中出现 concurrent copying GC freed …)</p>
<h3><a id="_755"></a>回收算法</h3>
<p><a href="https://www.zhihu.com/question/35164211" rel="nofollow">ps:我觉得这个只是为了应付面试，那么可以参考这里，我也只了解概念这里就不用在多写了，点击看这个帖子吧</a></p>
<p><a href="https://juejin.im/post/5b4dea755188251ac1098e98" rel="nofollow">也可以参考掘金的这一篇 GC 回收算法</a></p>
<h3><a id="_MarkSweep_761"></a>标记清除算法 Mark-Sweep</h3>
<h3><a id="_Copying_763"></a>复制算法 Copying</h3>
<h3><a id="_MarkCompact_765"></a>标记压缩算法 Mark-Compact</h3>
<h3><a id="_767"></a>分代收集算法</h3>
<h2><a id="__90___769"></a>总结 (只要养成这样的习惯，至少可以避免 90 % 以上不会造成内存异常)</h2>
<ol>
<li>
<p>数据类型: 不要使用比需求更占用空间的基本数据类型</p>
</li>
<li>
<p>循环尽量用 foreach ,少用 iterator, 自动装箱也尽量少用</p>
</li>
<li>
<p>数据结构与算法的解度处理 (数组，链表，栈树，树，图)</p>
<ul>
<li>数据量千级以内可以使用 Sparse 数组 (Key为整数)，ArrayMap (Key 为对象) 虽然性能不如 HashMap ，但节约内存。</li>
</ul>
</li>
<li>
<p>枚举优化</p>
<p><strong>缺点</strong>:</p>
<ul>
<li>每一个枚举值都是一个单例对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存</li>
<li>较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的 IO 开销,使我们的应用需要更多的空间</li>
<li>特别是分 Dex 多的大型 APP，枚举的初始化很容易导致 ANR</li>
</ul>
<p>优化后的代码:可以直接限定传入的参数个数</p>
<pre><code>public class SHAPE {
    public static final int TYPE_0=0;
    public static final int TYPE_1=1;
    public static final int TYPE_2=2;
    public static final int TYPE_3=3;

    @IntDef(flag=true,value={TYPE_0,TYPE_1,TYPE_2,TYPE_3})
    @Target({ElementType.PARAMETER,ElementType.METHOD,ElementType.FIELD})
    @Retention(RetentionPolicy.SOURCE)
    public @interface Model{

    }

    private @Model int value=TYPE_0;
    public void setShape(@Model int value){
        this.value=value;
    }
    @Model
    public int getShape(){
        return this.value;
    }
}


</code></pre>
</li>
<li>
<p>static , static final 的问题</p>
<ul>
<li>static 会由编译器调用 clinit 方法进行初始化</li>
<li>static final 不需要进行初始化工作，打包在 dex 文件中可以直接调用，并不会在类初始化申请内存</li>
</ul>
<p>基本数据类型的成员，可以全写成 static final</p>
</li>
<li>
<p>字符串的拼接尽量少用 +=</p>
</li>
<li>
<p>重复申请内存问题</p>
<ul>
<li>同一个方法多次调用，如递归函数 ，回调函数中 new 对象</li>
<li>不要在 onMeause() onLayout() ,onDraw() 中去刷新UI（requestLayout）</li>
</ul>
</li>
<li>
<p>避免 GC 回收将来要重新使用的对象 (内存设计模式对象池 + LRU 算法)</p>
</li>
<li>
<p>Activity 组件泄漏</p>
<ul>
<li>非业务需要不要把 activity 的上下文做参数传递，可以传递 application 的上下文</li>
<li>非静态内部类和匿名内部内会持有 activity 引用（静态内部类 或者 单独写文件）</li>
<li>单例模式中回调持有 activity 引用（弱引用）</li>
<li>handler.postDelayed() 问题
<ul>
<li>如果开启的线程需要传入参数，用弱引接收可解决问题</li>
<li>handler 记得清除 removeCallbacksAndMessages(null)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Service 耗时操作尽量使用 IntentService,而不是 Service</p>
</li>
</ol>
<p>最后思维导图做一个总结:<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0zMTUzOTAwZGJkNTQ4YzEzLnBuZw?x-oss-process=image/format,png" alt=""><br>
<strong>推荐阅读：<a href="https://www.jianshu.com/p/0d7808bdffec" rel="nofollow">2020最新Android大厂高频面试题解析大全(BAT TMD JD 小米)<br>
</a></strong><br>
<strong><a href="https://www.jianshu.com/p/f682173f1607" rel="nofollow">2020最新BAT Android高端技术面试145题详解</a></strong><br>
<strong><a href="https://www.jianshu.com/p/100e8044ce90" rel="nofollow">2019年鸿洋大神最新整理一线互联网公司Android中高级面试题总结（附答案解析）</a></strong><br>
<strong><a href="https://www.jianshu.com/p/7f9ade51232e" rel="nofollow">2017-2020历年字节跳动Android面试真题解析（累计下载1082万次，持续更新中）<br>
</a></strong></p>
<p>作者：DevYK<br>
链接：https://juejin.im/post/5cd82a3ee51d456e781f20ce<br>
来源：掘金</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
