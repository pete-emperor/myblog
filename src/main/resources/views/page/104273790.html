<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">阿里面试官： 自定义View跟绘制流程相关知识点？（标准参考解答，值得收藏）</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-02-12 09:51:14                    </span>
                    <span class="read-count">阅读数 96</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-02-12 09:51:14</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9415988.html">
                                       面试                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9439978.html">
                                       学习资料                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104273790">https://blog.csdn.net/weixin_43901866/article/details/104273790</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <blockquote>
<p>本文用于记录自定义View的基础步骤以及一些基础的信息，后期可能针对具体的点写一些补充性的文章。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0zNGIzZGJhYjUyNDllZDc2LnBuZw?x-oss-process=image/format,png" alt=""></p>
</blockquote>
<h3><a id="_View_8"></a>一 、View中关于四个构造函数参数</h3>
<p>自定义View中View的构造函数有四个</p>
<pre><code>//  主要是在java代码中生命一个View时所调用，没有任何参数，一个空的View对象
    public ChildrenView(Context context) {
        super(context);
    }
// 在布局文件中使用该自定义view的时候会调用到，一般会调用到该方法
    public ChildrenView(Context context, AttributeSet attrs) {
        this(context, attrs，0);
    }
//如果你不需要View随着主题变化而变化，则上面两个构造函数就可以了
//下面两个是与主题相关的构造函数
   public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, 0);
    }
//
    public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }
</code></pre>
<p>四个参数解释：</p>
<p><strong>context</strong>:上下文</p>
<p><strong>AttributeSet attrs</strong>：从xml中定义的参数</p>
<p><strong>intdefStyleAttr</strong>：主题中优先级最高的属性</p>
<p><strong>intdefStyleRes</strong>： 优先级次之的内置于View的style(这里就是自定义View设置样式的地方)</p>
<blockquote>
<ul>
<li><strong>多个地方定义属性，优先级排序</strong> Xml直接定义 &gt; xml中style引用 &gt; defStyleAttr&gt;defStyleRes &gt; theme直接定义 (参考文章：<a href="https://www.jianshu.com/p/7389287c04bb" rel="nofollow">www.jianshu.com/p/7389287c0…</a>)</li>
</ul>
</blockquote>
<h3><a id="_44"></a>二、自定义属性说明</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wYmYyNGM2ZTkzN2Q4ZDFhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>除了基本类型的不说 讲一下其它几个吧：</p>
<ul>
<li>
<p>color ：引用颜色</p>
</li>
<li>
<p>dimension: 引用字体大小</p>
</li>
</ul>
<pre><code>//定义
&lt;attr name = "text_size" format = "dimension" /&gt;
//使用：
    app:text_size = "28sp" 
或者 
    app:text_size = "@android:dimen/app_icon_size"
</code></pre>
<ul>
<li>enum：枚举值</li>
</ul>
<pre><code>//定义
    &lt;attr name="orientation"&gt;
        &lt;enum name="horizontal" value="0" /&gt;
        &lt;enum name="vertical" value="1" /&gt;
    &lt;/attr&gt;
//使用：
    app:orientation = "vertical"
</code></pre>
<ul>
<li>flags:标志 （位或运行） 主要作用=可以多个值</li>
</ul>
<pre><code>//定义
  &lt;attr name="gravity"&gt;
            &lt;flag name="top" value="0x01" /&gt;
            &lt;flag name="bottom" value="0x02" /&gt;
            &lt;flag name="left" value="0x04" /&gt;
            &lt;flag name="right" value="0x08" /&gt;
            &lt;flag name="center_vertical" value="0x16" /&gt;
    &lt;/attr&gt;
// 使用
app:gravity = Top|left
</code></pre>
<ul>
<li>fraction:百分数：</li>
</ul>
<pre><code>//定义：
&lt;attr name = "transparency" format = "fraction" /&gt;
//使用：
  app:transparency = "80%" 
</code></pre>
<ul>
<li>reference:参考/引用某一资源ID</li>
</ul>
<pre><code>//定义：
 &lt;attr name="leftIcon" format="reference" /&gt;
//使用：
app:leftIcon = "@drawable/图片ID"
</code></pre>
<ul>
<li>混合类型：属性定义时指定多种类型值</li>
</ul>
<pre><code>//属性定义
 &lt;attr name = "background" format = "reference|color" /&gt;
//使用
android:background = "@drawable/图片ID" 
//或者
android:background = "#FFFFFF" 
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1mZDE4ZGMxYzA0ZTc0ZGE5LnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="_121"></a>三、自定义控件类型</h3>
<ul>
<li>
<h4><a id="_123"></a>自定义组合控件步骤</h4>
</li>
</ul>
<h5><a id="1__125"></a>1. 自定义属性</h5>
<p>在<code>res/values</code>目录下的<code>attrs.xml</code>文件中</p>
<pre><code>&lt;resources&gt;
&lt;declare-styleable name="CustomView"&gt;
        &lt;attr name="leftIcon" format="reference" /&gt;
        &lt;attr name="state" format="boolean"/&gt;
        &lt;attr name="name" format="string"/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>
<h5><a id="2__139"></a>2. 布局中使用自定义属性</h5>
<p>在布局中使用</p>
<pre><code>&lt;com.myapplication.view.CustomView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:leftIcon="@mipmap/ic_temp"
                app:name="温度"
                app:state="false" /&gt;
</code></pre>
<h5><a id="3_view_152"></a>3. view的构造函数获取自定义属性</h5>
<pre><code>class DigitalCustomView : LinearLayout {
    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        LayoutInflater.from(context).inflate(R.layout.view_custom, this)
        var ta = context.obtainStyledAttributes(attrs, R.styleable.CustomView)
        mIcon = ta.getResourceId(R.styleable.CustomView_leftIcon, -1) //左图像
        mState = ta.getBoolean(R.styleable.DigitalCustomView_state, false)
        mName = ta.getString(R.styleable.CustomView_name)
        ta.recycle()
        initView()
    }

}
</code></pre>
<p>上面给出大致的代码 记得获取<code>context.obtainStyledAttributes(attrs, R.styleable.CustomView)</code>最后要调用<code>ta.recycle()</code>利用对象池回收ta加以复用</p>
<ul>
<li>
<h4><a id="_172"></a>继承系统控件</h4>
</li>
</ul>
<p>就是继承系统已经提供好给我们的控件例如TextView、LinearLayout等,分为View类型或者ViewGroup类型的两种。主要根据业务需求进行实现，实现重写的空间也很大 主要看需求。</p>
<p>比如需求 ：在文字后面加个颜色背景</p>
<p>根据需要一般这种情况下我们是希望可以复用系统的<code>onMeaseur</code>和<code>onLayout</code>流程.直接复写<code>onDraw</code>方法</p>
<pre><code>class Practice02BeforeOnDrawView : AppCompatTextView {
    internal var paint = Paint(Paint.ANTI_ALIAS_FLAG)
    internal var bounds = RectF()

    constructor(context: Context) : super(context) {}

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {}

    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {}

    init {
        paint.color = Color.parseColor("#FFC107")
    }

    override fun onDraw(canvas: Canvas) {
        // 把下面的绘制代码移到 super.onDraw() 的上面，就可以让原主体内容盖住你的绘制代码了
        // （或者你也可以把 super.onDraw() 移到这段代码的下面）
        val layout = layout
        bounds.left = layout.getLineLeft(1)
        bounds.right = layout.getLineRight(1)
        bounds.top = layout.getLineTop(1).toFloat()
        bounds.bottom = layout.getLineBottom(1).toFloat()
       //绘制方形背景
        canvas.drawRect(bounds, paint)
        super.onDraw(canvas)
    }
}
</code></pre>
<blockquote>
<p>这里会涉及到画笔<code>Paint()</code>、画布<code>canvas</code>、路径<code>Path</code>、绘画顺序等的一些知识点，后面再详细说明</p>
</blockquote>
<ul>
<li>
<h4><a id="View_212"></a>直接继承View</h4>
</li>
</ul>
<p>这种就是类似TextView等，不需要去轮训子<code>View</code>只需要根据自己的需求重写<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code>等方法便可以，要注意点就是记得<code>Padding</code>等值要记得加入运算</p>
<pre><code> private int getCalculateSize(int defaultSize, int measureSpec) {
        int finallSize = defaultSize;

        int mode = MeasureSpec.getMode(measureSpec);
        int size = MeasureSpec.getSize(measureSpec);
     //  根据模式对
        switch (mode) {
            case MeasureSpec.EXACTLY: {
              ...
                break;
            }
            case MeasureSpec.AT_MOST: {
                ...
                break;
            }
            case MeasureSpec.UNSPECIFIED: {
               ...
                break;
            }
        }
        return finallSize;
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = getCalculateSize(120, widthMeasureSpec);
        int height = getCalculateSize(120, heightMeasureSpec);
        setMeasuredDimension(width, height);
}

  //画一个圆
    @Override
    protected void onDraw(Canvas canvas) {
        //调用父View的onDraw函数，因为View这个类帮我们实现了一些基本的而绘制功能，比如绘制背景颜色、背景图片等
        super.onDraw(canvas);
        int r = getMeasuredWidth() / 2;
        //圆心的横坐标为当前的View的左边起始位置+半径
        int centerX = getLeft() + r;
        //圆心的纵坐标为当前的View的顶部起始位置+半径
        int centerY = getTop() + r;

        Paint paint = new Paint();
        paint.setColor(Color.RED);
        canvas.drawCircle(centerX, centerY, r, paint);
    }

</code></pre>
<ul>
<li>
<h4><a id="ViewGroup_266"></a>直接继承ViewGroup</h4>
</li>
</ul>
<p>类似实现LinearLayout等，可以去看那一下LinearLayout的实现 基本的你可能要重写<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code>方法,这块很多问题要处理包括轮训<code>childView</code>的测量值以及模式进行大小逻辑计算等，这个篇幅过大后期加多个文章写详细的</p>
<p>这里写个简单的需求，模仿<code>LinearLayout</code>的垂直布局</p>
<pre><code>class CustomViewGroup :ViewGroup{

    constructor(context:Context):super(context)
    constructor(context: Context,attrs:AttributeSet):super(context,attrs){
            //可获取自定义的属性等
    }
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        //将所有的子View进行测量，这会触发每个子View的onMeasure函数
        measureChildren(widthMeasureSpec, heightMeasureSpec)
        val widthMode = MeasureSpec.getMode(widthMeasureSpec)
        val widthSize = MeasureSpec.getSize(widthMeasureSpec)
        val heightMode = MeasureSpec.getMode(heightMeasureSpec)
        val heightSize = MeasureSpec.getSize(heightMeasureSpec)
        val childCount = childCount
        if (childCount == 0) {
            //没有子View的情况
            setMeasuredDimension(0, 0)
        } else {
            //如果宽高都是包裹内容
            if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) {
                //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度
                val height = getTotalHeight()
                val width = getMaxChildWidth()
                setMeasuredDimension(width, height)
            } else if (heightMode == MeasureSpec.AT_MOST) {
                //如果只有高度是包裹内容
                //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和
                setMeasuredDimension(widthSize, getTotalHeight())
            } else if (widthMode == MeasureSpec.AT_MOST) {//如果只有宽度是包裹内容
                //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值
                setMeasuredDimension(getMaxChildWidth(), heightSize)

            }
        }
    /***
     * 获取子View中宽度最大的值
     */
    private fun getMaxChildWidth(): Int {
        val childCount = childCount
        var maxWidth = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            if (childView.measuredWidth &gt; maxWidth)
                maxWidth = childView.measuredWidth

        }
        return maxWidth
    }

    /***
     * 将所有子View的高度相加
     */
    private fun getTotalHeight(): Int {
        val childCount = childCount
        var height = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            height += childView.measuredHeight

        }

        return height
    }

    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
        val count = childCount
        var currentHeight = t
        for (i in 0 until count) {
            val child = getChildAt(i)
            val h = child.measuredHeight
            val w = child.measuredWidth
            //摆放子view
            child.layout(l, currentHeight, l + w, currentHeight + h)
            currentHeight += h
        }
    }
}
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi03MzdlOWMxNmNjNjM0OTYzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<blockquote>
<p>主要两点 先 <code>measureChildren()</code>轮训遍历子<code>View</code>获取宽高,并根据测量模式逻辑计算最后所有的控件的所需宽高，最后<code>setMeasuredDimension()</code>保存一下 ###四、 View的绘制流程相关 最基本的三个相关函数 <code>measure()</code> -&gt;<code>layout()</code>-&gt;<code>draw()</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1hOWQzNzE0MjUxZWY2NzQzLnBuZw?x-oss-process=image/format,png" alt=""></p>
</blockquote>
<h3><a id="onMeasure_362"></a>五、onMeasure()相关的知识点</h3>
<h4><a id="1_MeasureSpec_364"></a>1. MeasureSpec</h4>
<p><code>MeasureSpec</code>是<code>View</code>的内部类，它封装了一个<code>View</code>的尺寸，在<code>onMeasure()</code>当中会根据这个<code>MeasureSpec</code>的值来确定<code>View</code>的宽高。 <code>MeasureSpec</code> 的数据是<code>int</code>类型，有<code>32</code>位。 高两位表示模式，后面<code>30</code>位表示大小<code>size</code>。则<code>MeasureSpec = mode+size</code> 三种模式分别为：<code>EXACTLY</code>,<code>AT_MOST</code>,<code>UNSPECIFIED</code></p>
<blockquote>
<p><code>EXACTLY</code>: （<code>match_parent</code>或者 <code>精确数据值</code>）精确模式，对应的数值就是<code>MeasureSpec</code>当中的<code>size</code></p>
<p><code>AT_MOST</code>😦<code>wrap_content)</code>最大值模式，View的尺寸有一个最大值，<code>View</code>不超过<code>MeasureSpec</code>当中的<code>Size</code>值</p>
<p><code>UNSPECIFIED</code>：（一般系统使用）无限制模式，View设置多大就给他多大</p>
</blockquote>
<pre><code>//获取测量模式
 val widthMode = MeasureSpec.getMode(widthMeasureSpec)
//获取测量大小 
val widthSize = MeasureSpec.getSize(widthMeasureSpec)
//通过Mode和Size构造MeasureSpec
val measureSpec = MeasureSpec.makeMeasureSpec(size, mode);
</code></pre>
<h4><a id="2_View_onMeasure_383"></a>2. View #onMeasure()源码</h4>
<pre><code>   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }
    protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
    protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }
    public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
    }
    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;

        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }
</code></pre>
<ul>
<li>
<p><strong>setMeasuredDimension(int measuredWidth, int measuredHeight)</strong> ：用来设置View的宽高，在我们自定义View保存宽高也会要用到。</p>
</li>
<li>
<p><strong>getSuggestedMinimumWidth()</strong>：当View没有设置背景时，默认大小就是<code>mMinWidth</code>，这个值对应<code>Android:minWidth</code>属性，如果没有设置时默认为0. 如果有设置背景，则默认大小为<code>mMinWidth</code>和<code>mBackground.getMinimumWidth()</code>当中的较大值。</p>
</li>
<li>
<p><strong>getDefaultSize(int size, int measureSpec)</strong>：用来获取View默认的宽高，在**getDefaultSize()**中对<code>MeasureSpec.AT_MOST</code>,<code>MeasureSpec.EXACTLY</code>两个的处理是一样的，我们自定义<code>View</code>的时候 要对两种模式进行处理。</p>
</li>
</ul>
<h4><a id="3_ViewGroupmeasureonMeasure_435"></a>3. ViewGroup中并没有measure()也没有onMeasure()</h4>
<p>因为ViewGroup除了测量自身的宽高，还需要测量各个子<code>View</code>的宽高，不同的布局测量方式不同 (例如 <code>LinearLayout</code>跟<code>RelativeLayout</code>等布局）,所以直接交由继承者根据自己的需要去复写。但是里面因为子<code>View</code>的测量是相对固定的，所以里面已经提供了基本的<code>measureChildren()</code>以及<code>measureChild()</code>来帮助我们对子<code>View</code>进行测量 这个可以看一下我另一篇文章：<code>LinearLayout # onMeasure()</code><a href="https://www.jianshu.com/p/61efaa047ae4" rel="nofollow">LinearLayout onMeasure源码阅读</a></p>
<h3><a id="onLayout_439"></a>六、onLayout()相关</h3>
<blockquote>
<ol>
<li>View.java的onLayout方法是空实现:因为子View的位置，是由其父控件的onLayout方法来确定的。</li>
<li>onLayout(int l, int t, int r, int b)中的参数l、t、r、b都是相对于其父 控件的位置。</li>
<li>自身的mLeft, mTop, mRight, mBottom都是相对于父控件的位置。</li>
</ol>
</blockquote>
<h4><a id="1_Android_445"></a>1. Android坐标系</h4>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1jNjhiYzMzN2Q5YWEyMmQwLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="2_View_450"></a>2. 内部View坐标系跟点击坐标</h4>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wNmRlZGRiMGRmMjJkMWZhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="3_Viewlayoutint_l_int_t_int_r_int_b_454"></a>3. 看一下View#layout(int l, int t, int r, int b)源码</h4>
<pre><code>public void layout(int l, int t, int r, int b) {
        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }

        int oldL = mLeft;
        int oldT = mTop;
        int oldB = mBottom;
        int oldR = mRight;

        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
            onLayout(changed, l, t, r, b);
   //   ....省略其它部分
    }
  private boolean setOpticalFrame(int left, int top, int right, int bottom) {
        Insets parentInsets = mParent instanceof View ?
                ((View) mParent).getOpticalInsets() : Insets.NONE;
        Insets childInsets = getOpticalInsets();
        return setFrame(
                left   + parentInsets.left - childInsets.left,
                top    + parentInsets.top  - childInsets.top,
                right  + parentInsets.left + childInsets.right,
                bottom + parentInsets.top  + childInsets.bottom);
    }
  protected boolean setFrame(int left, int top, int right, int bottom) {
        boolean changed = false;
    // ....省略其它部分
        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;
            int drawn = mPrivateFlags &amp; PFLAG_DRAWN;
            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;
            int newWidth = right - left;
            int newHeight = bottom - top;
            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
            invalidate(sizeChanged);
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
            mPrivateFlags |= PFLAG_HAS_BOUNDS;
            if (sizeChanged) {
                sizeChange(newWidth, newHeight, oldWidth, oldHeight);
            }
            if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) {
                mPrivateFlags |= PFLAG_DRAWN;
                invalidate(sizeChanged);
                invalidateParentCaches();
            }
            mPrivateFlags |= drawn;
            mBackgroundSizeChanged = true;
            mDefaultFocusHighlightSizeChanged = true;
            if (mForegroundInfo != null) {
                mForegroundInfo.mBoundsChanged = true;
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
        return changed;
    }

</code></pre>
<p>四个参数<code>l、t、r、b</code>分别代表<code>View</code>的左、上、右、下四个边界相对于其父<code>View</code>的距离。 在调用<code>onLayout(changed, l, t, r, b);</code>之前都会调用到<code>setFrame()</code>确定<code>View</code>在父容器当中的位置，赋值给<code>mLeft</code>,<code>mTop</code>,<code>mRight</code>,<code>mBottom</code>。 在<code>ViewGroup#onLayout()</code>跟<code>View#onLayout()</code>都是空实现，交给继承者根据自身需求去定位</p>
<blockquote>
<p>部分零散知识点：</p>
<ul>
<li><strong><code>getMeasureWidth()</code>与<code>getWidth()</code></strong> <code>getMeasureWidth()</code>返回的是<code>mMeasuredWidth</code>，而该值是在<code>setMeasureDimension()</code>中的<code>setMeasureDimensionRaw()</code>中设置的。因此<code>onMeasure()</code>后的所有方法都能获取到这个值。 <code>getWidth</code>返回的是<code>mRight-mLeft</code>，这两个值，是在<code>layout()</code>中的<code>setFrame()</code>中设置的. <code>getMeasureWidthAndState</code>中有一句： <code>This should be used during measurement and layout calculations only. Use {@link #getWidth()} to see how wide a view is after layout.</code></li>
</ul>
<p>总结：只有在测量过程中和布局计算时，才用<code>getMeasuredWidth()</code>。在layout之后，用<code>getWidth()</code>来获取宽度</p>
</blockquote>
<h3><a id="draw_532"></a>七、draw()绘画过程</h3>
<pre><code> /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1\. Draw the background
         *      2\. If necessary, save the canvas' layers to prepare for fading
         *      3\. Draw view's content
         *      4\. Draw children
         *      5\. If necessary, draw the fading edges and restore layers
         *      6\. Draw decorations (scrollbars for instance)
         */
</code></pre>
<blockquote>
<p>上面是<code>draw()</code>里面写的绘画顺序。</p>
<ol>
<li>绘制背景。</li>
<li>如果必要的话,保存当前<code>canvas</code></li>
<li>绘制<code>View</code>的内容</li>
<li>绘制子<code>View</code></li>
<li>如果必要的话,绘画边缘重新保存图层</li>
<li>画装饰(例如滚动条)</li>
</ol>
</blockquote>
<h4><a id="1_Viewdraw_557"></a>1. 看一下View#draw()源码的实现</h4>
<pre><code>public void draw(Canvas canvas) {
  // Step 1, draw the background, if needed
        int saveCount;

        if (!dirtyOpaque) {
            drawBackground(canvas);
        }

        // skip step 2 &amp; 5 if possible (common case)
        final int viewFlags = mViewFlags;
        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
        if (!verticalEdges &amp;&amp; !horizontalEdges) {
            // Step 3, draw the content
            if (!dirtyOpaque) onDraw(canvas);

            // Step 4, draw the children
            dispatchDraw(canvas);

            drawAutofilledHighlight(canvas);

            // Overlay is part of the content and draws beneath Foreground
            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().dispatchDraw(canvas);
            }

            // Step 6, draw decorations (foreground, scrollbars)
            onDrawForeground(canvas);

            // Step 7, draw the default focus highlight
            drawDefaultFocusHighlight(canvas);

            if (debugDraw()) {
                debugDrawFocus(canvas);
            }

            // we're done...
            return;
        }
}

</code></pre>
<p>由上面可以看到 先调用<code>drawBackground(canvas)</code> -&gt;<code>onDraw(canvas)</code>-&gt;<code>dispatchDraw(canvas)</code>-&gt;<code>onDrawForeground(canvas)</code>越是后面绘画的越是覆盖在最上层。</p>
<p><strong>drawBackground(canvas)</strong>:画背景，不可重写</p>
<p><strong>onDraw(canvas)</strong>：画主体</p>
<ul>
<li><strong>代码写在super.onDraw()前</strong>：会被父类的onDraw覆盖</li>
<li><strong>代码写在super.onDraw()后</strong>：不会被父类的onDraw覆盖</li>
</ul>
<p><strong>dispatchDraw()</strong> ：绘制子 View 的方法</p>
<ul>
<li>
<p><strong>代码写在super.dispatchDraw(canvas)前</strong>：把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。而这个…… 其实和重写 onDraw() 并把绘制代码写在 super.onDraw() 之后的做法，效果是一样的。</p>
</li>
<li>
<p><strong>代码写在super.dispatchDraw(canvas)后</strong>：只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。</p>
</li>
</ul>
<p><strong>onDrawForeground(canvas)</strong>：包含了滑动边缘渐变和滑动条跟前景</p>
<blockquote>
<p>一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制。需要注意，前景的支持是在 Android 6.0（也就是 API 23）才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi03N2U5ZGFkMzIwNzdmYTFhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="2__625"></a>2. 注意事项</h4>
<h5><a id="21__ViewGroup__dispatchDraw__setWillNotDrawfalse_627"></a>2.1 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)；</h5>
<p><em>出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。</em></p>
<h5><a id="22__onDraw_631"></a>2.2 在重写的方法有多个选择时，优先选择 onDraw()</h5>
<p><em>一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。</em></p>
<h3><a id="ActivityView_635"></a>八、在Activity中获取View的宽高的几种方式</h3>
<blockquote>
<p>Activity 获取 view 的宽高， 在 onCreate , onResume 等方法中获取到的都是0， 因为 View 的测量过程并不是和 Activity 的声明周期同步执行的</p>
</blockquote>
<p><strong>1. view.post</strong> post 可以将一个 runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候， View 也已经初始化好了</p>
<pre><code>       view.post(new Runnable() {
            @Override
            public void run() {
                int width = view.getMeasuredWidth();
                int height = view.getMeasuredHeight(); 
            }
        });
</code></pre>
<p><strong>2. ViewTreeObserver</strong> 使用 addOnGlobalLayoutListener 接口， 当 view 树的状态发生改变或者 View 树内部的 view 的可见性发生改变时， onGlobalLayout 都会被调用， 需要注意的是， <strong>onGlobalLayout 方法可能被调用多次</strong>， 代码如下：</p>
<pre><code> view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                int width = view.getMeasuredWidth();
                int height = view.getMeasuredHeight();
            }
        });
</code></pre>
<p><strong>3. onWindowFocusChanged</strong> 这个方法的含义是 View 已经初始化完毕了， 宽高已经准备好了， 需要注意的就是这个方法可能会调用多次， 在 Activity <code>onResume</code> 和<code>onPause</code>的时候都会调用， <strong>也会有多次调用的情况</strong></p>
<pre><code>     @Override
    public void onWindowFocusChanged(boolean hasWindowFocus) {
        super.onWindowFocusChanged(hasWindowFocus);
        if(hasWindowFocus){
            int width = view.getMeasuredWidth();
            int height = view.getMeasuredHeight();
        }
    }
</code></pre>
<p>节选自：未扬帆的小船https://juejin.im/post/5dde44dc5188250e8b235d83</p>
<h1><a id="_677"></a>最后</h1>
<p>题外话，虽然我在阿里工作时间不长，但也指导过不少同行。很少跟大家一起探讨，今年春节受武汉新型冠状病毒影响，大家都只能在家办公学习，待疫情过去，大家重归工作岗位，面试和岗位流动多起来，因此充分利用这段时间复习，未来在寻找工作过程中占领有利位置就显得尤为重要了。<br>
在这里我分享两本由我们阿里同事总结《Android面试指导》，以及《Android架构师面试题精编解析大全》两本电子书分享给读者，需要的朋友，点击下方链接，前往免费领取！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0xMmMxNGI0NmNjNDAyMWI2LnBuZw?x-oss-process=image/format,png" alt="《Android面试指导》"><br>
<strong>下载地址：<a href="https://shimo.im/docs/3Tvytq686Yyv83KX/read" rel="nofollow">https://shimo.im/docs/3Tvytq686Yyv83KX/read</a></strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wZDhjOTNjZDAzNmNhZmEyLnBuZw?x-oss-process=image/format,png" alt="《Android架构师面试题精编解析大全》"><br>
<strong>下载地址：<a href="https://shimo.im/docs/3Tvytq686Yyv83KX/read" rel="nofollow">https://shimo.im/docs/3Tvytq686Yyv83KX/read</a></strong></p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">阿里面试官： 自定义View跟绘制流程相关知识点？（标准参考解答，值得收藏）</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-02-12 09:51:14                    </span>
                    <span class="read-count">阅读数 96</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-02-12 09:51:14</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9415988.html">
                                       面试                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9439978.html">
                                       学习资料                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104273790">https://blog.csdn.net/weixin_43901866/article/details/104273790</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <blockquote>
<p>本文用于记录自定义View的基础步骤以及一些基础的信息，后期可能针对具体的点写一些补充性的文章。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0zNGIzZGJhYjUyNDllZDc2LnBuZw?x-oss-process=image/format,png" alt=""></p>
</blockquote>
<h3><a id="_View_8"></a>一 、View中关于四个构造函数参数</h3>
<p>自定义View中View的构造函数有四个</p>
<pre><code>//  主要是在java代码中生命一个View时所调用，没有任何参数，一个空的View对象
    public ChildrenView(Context context) {
        super(context);
    }
// 在布局文件中使用该自定义view的时候会调用到，一般会调用到该方法
    public ChildrenView(Context context, AttributeSet attrs) {
        this(context, attrs，0);
    }
//如果你不需要View随着主题变化而变化，则上面两个构造函数就可以了
//下面两个是与主题相关的构造函数
   public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, 0);
    }
//
    public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }
</code></pre>
<p>四个参数解释：</p>
<p><strong>context</strong>:上下文</p>
<p><strong>AttributeSet attrs</strong>：从xml中定义的参数</p>
<p><strong>intdefStyleAttr</strong>：主题中优先级最高的属性</p>
<p><strong>intdefStyleRes</strong>： 优先级次之的内置于View的style(这里就是自定义View设置样式的地方)</p>
<blockquote>
<ul>
<li><strong>多个地方定义属性，优先级排序</strong> Xml直接定义 &gt; xml中style引用 &gt; defStyleAttr&gt;defStyleRes &gt; theme直接定义 (参考文章：<a href="https://www.jianshu.com/p/7389287c04bb" rel="nofollow">www.jianshu.com/p/7389287c0…</a>)</li>
</ul>
</blockquote>
<h3><a id="_44"></a>二、自定义属性说明</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wYmYyNGM2ZTkzN2Q4ZDFhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>除了基本类型的不说 讲一下其它几个吧：</p>
<ul>
<li>
<p>color ：引用颜色</p>
</li>
<li>
<p>dimension: 引用字体大小</p>
</li>
</ul>
<pre><code>//定义
&lt;attr name = "text_size" format = "dimension" /&gt;
//使用：
    app:text_size = "28sp" 
或者 
    app:text_size = "@android:dimen/app_icon_size"
</code></pre>
<ul>
<li>enum：枚举值</li>
</ul>
<pre><code>//定义
    &lt;attr name="orientation"&gt;
        &lt;enum name="horizontal" value="0" /&gt;
        &lt;enum name="vertical" value="1" /&gt;
    &lt;/attr&gt;
//使用：
    app:orientation = "vertical"
</code></pre>
<ul>
<li>flags:标志 （位或运行） 主要作用=可以多个值</li>
</ul>
<pre><code>//定义
  &lt;attr name="gravity"&gt;
            &lt;flag name="top" value="0x01" /&gt;
            &lt;flag name="bottom" value="0x02" /&gt;
            &lt;flag name="left" value="0x04" /&gt;
            &lt;flag name="right" value="0x08" /&gt;
            &lt;flag name="center_vertical" value="0x16" /&gt;
    &lt;/attr&gt;
// 使用
app:gravity = Top|left
</code></pre>
<ul>
<li>fraction:百分数：</li>
</ul>
<pre><code>//定义：
&lt;attr name = "transparency" format = "fraction" /&gt;
//使用：
  app:transparency = "80%" 
</code></pre>
<ul>
<li>reference:参考/引用某一资源ID</li>
</ul>
<pre><code>//定义：
 &lt;attr name="leftIcon" format="reference" /&gt;
//使用：
app:leftIcon = "@drawable/图片ID"
</code></pre>
<ul>
<li>混合类型：属性定义时指定多种类型值</li>
</ul>
<pre><code>//属性定义
 &lt;attr name = "background" format = "reference|color" /&gt;
//使用
android:background = "@drawable/图片ID" 
//或者
android:background = "#FFFFFF" 
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1mZDE4ZGMxYzA0ZTc0ZGE5LnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="_121"></a>三、自定义控件类型</h3>
<ul>
<li>
<h4><a id="_123"></a>自定义组合控件步骤</h4>
</li>
</ul>
<h5><a id="1__125"></a>1. 自定义属性</h5>
<p>在<code>res/values</code>目录下的<code>attrs.xml</code>文件中</p>
<pre><code>&lt;resources&gt;
&lt;declare-styleable name="CustomView"&gt;
        &lt;attr name="leftIcon" format="reference" /&gt;
        &lt;attr name="state" format="boolean"/&gt;
        &lt;attr name="name" format="string"/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>
<h5><a id="2__139"></a>2. 布局中使用自定义属性</h5>
<p>在布局中使用</p>
<pre><code>&lt;com.myapplication.view.CustomView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                app:leftIcon="@mipmap/ic_temp"
                app:name="温度"
                app:state="false" /&gt;
</code></pre>
<h5><a id="3_view_152"></a>3. view的构造函数获取自定义属性</h5>
<pre><code>class DigitalCustomView : LinearLayout {
    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        LayoutInflater.from(context).inflate(R.layout.view_custom, this)
        var ta = context.obtainStyledAttributes(attrs, R.styleable.CustomView)
        mIcon = ta.getResourceId(R.styleable.CustomView_leftIcon, -1) //左图像
        mState = ta.getBoolean(R.styleable.DigitalCustomView_state, false)
        mName = ta.getString(R.styleable.CustomView_name)
        ta.recycle()
        initView()
    }

}
</code></pre>
<p>上面给出大致的代码 记得获取<code>context.obtainStyledAttributes(attrs, R.styleable.CustomView)</code>最后要调用<code>ta.recycle()</code>利用对象池回收ta加以复用</p>
<ul>
<li>
<h4><a id="_172"></a>继承系统控件</h4>
</li>
</ul>
<p>就是继承系统已经提供好给我们的控件例如TextView、LinearLayout等,分为View类型或者ViewGroup类型的两种。主要根据业务需求进行实现，实现重写的空间也很大 主要看需求。</p>
<p>比如需求 ：在文字后面加个颜色背景</p>
<p>根据需要一般这种情况下我们是希望可以复用系统的<code>onMeaseur</code>和<code>onLayout</code>流程.直接复写<code>onDraw</code>方法</p>
<pre><code>class Practice02BeforeOnDrawView : AppCompatTextView {
    internal var paint = Paint(Paint.ANTI_ALIAS_FLAG)
    internal var bounds = RectF()

    constructor(context: Context) : super(context) {}

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {}

    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {}

    init {
        paint.color = Color.parseColor("#FFC107")
    }

    override fun onDraw(canvas: Canvas) {
        // 把下面的绘制代码移到 super.onDraw() 的上面，就可以让原主体内容盖住你的绘制代码了
        // （或者你也可以把 super.onDraw() 移到这段代码的下面）
        val layout = layout
        bounds.left = layout.getLineLeft(1)
        bounds.right = layout.getLineRight(1)
        bounds.top = layout.getLineTop(1).toFloat()
        bounds.bottom = layout.getLineBottom(1).toFloat()
       //绘制方形背景
        canvas.drawRect(bounds, paint)
        super.onDraw(canvas)
    }
}
</code></pre>
<blockquote>
<p>这里会涉及到画笔<code>Paint()</code>、画布<code>canvas</code>、路径<code>Path</code>、绘画顺序等的一些知识点，后面再详细说明</p>
</blockquote>
<ul>
<li>
<h4><a id="View_212"></a>直接继承View</h4>
</li>
</ul>
<p>这种就是类似TextView等，不需要去轮训子<code>View</code>只需要根据自己的需求重写<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code>等方法便可以，要注意点就是记得<code>Padding</code>等值要记得加入运算</p>
<pre><code> private int getCalculateSize(int defaultSize, int measureSpec) {
        int finallSize = defaultSize;

        int mode = MeasureSpec.getMode(measureSpec);
        int size = MeasureSpec.getSize(measureSpec);
     //  根据模式对
        switch (mode) {
            case MeasureSpec.EXACTLY: {
              ...
                break;
            }
            case MeasureSpec.AT_MOST: {
                ...
                break;
            }
            case MeasureSpec.UNSPECIFIED: {
               ...
                break;
            }
        }
        return finallSize;
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = getCalculateSize(120, widthMeasureSpec);
        int height = getCalculateSize(120, heightMeasureSpec);
        setMeasuredDimension(width, height);
}

  //画一个圆
    @Override
    protected void onDraw(Canvas canvas) {
        //调用父View的onDraw函数，因为View这个类帮我们实现了一些基本的而绘制功能，比如绘制背景颜色、背景图片等
        super.onDraw(canvas);
        int r = getMeasuredWidth() / 2;
        //圆心的横坐标为当前的View的左边起始位置+半径
        int centerX = getLeft() + r;
        //圆心的纵坐标为当前的View的顶部起始位置+半径
        int centerY = getTop() + r;

        Paint paint = new Paint();
        paint.setColor(Color.RED);
        canvas.drawCircle(centerX, centerY, r, paint);
    }

</code></pre>
<ul>
<li>
<h4><a id="ViewGroup_266"></a>直接继承ViewGroup</h4>
</li>
</ul>
<p>类似实现LinearLayout等，可以去看那一下LinearLayout的实现 基本的你可能要重写<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code>方法,这块很多问题要处理包括轮训<code>childView</code>的测量值以及模式进行大小逻辑计算等，这个篇幅过大后期加多个文章写详细的</p>
<p>这里写个简单的需求，模仿<code>LinearLayout</code>的垂直布局</p>
<pre><code>class CustomViewGroup :ViewGroup{

    constructor(context:Context):super(context)
    constructor(context: Context,attrs:AttributeSet):super(context,attrs){
            //可获取自定义的属性等
    }
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        //将所有的子View进行测量，这会触发每个子View的onMeasure函数
        measureChildren(widthMeasureSpec, heightMeasureSpec)
        val widthMode = MeasureSpec.getMode(widthMeasureSpec)
        val widthSize = MeasureSpec.getSize(widthMeasureSpec)
        val heightMode = MeasureSpec.getMode(heightMeasureSpec)
        val heightSize = MeasureSpec.getSize(heightMeasureSpec)
        val childCount = childCount
        if (childCount == 0) {
            //没有子View的情况
            setMeasuredDimension(0, 0)
        } else {
            //如果宽高都是包裹内容
            if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) {
                //我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度
                val height = getTotalHeight()
                val width = getMaxChildWidth()
                setMeasuredDimension(width, height)
            } else if (heightMode == MeasureSpec.AT_MOST) {
                //如果只有高度是包裹内容
                //宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和
                setMeasuredDimension(widthSize, getTotalHeight())
            } else if (widthMode == MeasureSpec.AT_MOST) {//如果只有宽度是包裹内容
                //宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值
                setMeasuredDimension(getMaxChildWidth(), heightSize)

            }
        }
    /***
     * 获取子View中宽度最大的值
     */
    private fun getMaxChildWidth(): Int {
        val childCount = childCount
        var maxWidth = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            if (childView.measuredWidth &gt; maxWidth)
                maxWidth = childView.measuredWidth

        }
        return maxWidth
    }

    /***
     * 将所有子View的高度相加
     */
    private fun getTotalHeight(): Int {
        val childCount = childCount
        var height = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            height += childView.measuredHeight

        }

        return height
    }

    }

    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
        val count = childCount
        var currentHeight = t
        for (i in 0 until count) {
            val child = getChildAt(i)
            val h = child.measuredHeight
            val w = child.measuredWidth
            //摆放子view
            child.layout(l, currentHeight, l + w, currentHeight + h)
            currentHeight += h
        }
    }
}
</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi03MzdlOWMxNmNjNjM0OTYzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<blockquote>
<p>主要两点 先 <code>measureChildren()</code>轮训遍历子<code>View</code>获取宽高,并根据测量模式逻辑计算最后所有的控件的所需宽高，最后<code>setMeasuredDimension()</code>保存一下 ###四、 View的绘制流程相关 最基本的三个相关函数 <code>measure()</code> -&gt;<code>layout()</code>-&gt;<code>draw()</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1hOWQzNzE0MjUxZWY2NzQzLnBuZw?x-oss-process=image/format,png" alt=""></p>
</blockquote>
<h3><a id="onMeasure_362"></a>五、onMeasure()相关的知识点</h3>
<h4><a id="1_MeasureSpec_364"></a>1. MeasureSpec</h4>
<p><code>MeasureSpec</code>是<code>View</code>的内部类，它封装了一个<code>View</code>的尺寸，在<code>onMeasure()</code>当中会根据这个<code>MeasureSpec</code>的值来确定<code>View</code>的宽高。 <code>MeasureSpec</code> 的数据是<code>int</code>类型，有<code>32</code>位。 高两位表示模式，后面<code>30</code>位表示大小<code>size</code>。则<code>MeasureSpec = mode+size</code> 三种模式分别为：<code>EXACTLY</code>,<code>AT_MOST</code>,<code>UNSPECIFIED</code></p>
<blockquote>
<p><code>EXACTLY</code>: （<code>match_parent</code>或者 <code>精确数据值</code>）精确模式，对应的数值就是<code>MeasureSpec</code>当中的<code>size</code></p>
<p><code>AT_MOST</code>😦<code>wrap_content)</code>最大值模式，View的尺寸有一个最大值，<code>View</code>不超过<code>MeasureSpec</code>当中的<code>Size</code>值</p>
<p><code>UNSPECIFIED</code>：（一般系统使用）无限制模式，View设置多大就给他多大</p>
</blockquote>
<pre><code>//获取测量模式
 val widthMode = MeasureSpec.getMode(widthMeasureSpec)
//获取测量大小 
val widthSize = MeasureSpec.getSize(widthMeasureSpec)
//通过Mode和Size构造MeasureSpec
val measureSpec = MeasureSpec.makeMeasureSpec(size, mode);
</code></pre>
<h4><a id="2_View_onMeasure_383"></a>2. View #onMeasure()源码</h4>
<pre><code>   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }
    protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
    protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }
    public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
    }
    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;

        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }
</code></pre>
<ul>
<li>
<p><strong>setMeasuredDimension(int measuredWidth, int measuredHeight)</strong> ：用来设置View的宽高，在我们自定义View保存宽高也会要用到。</p>
</li>
<li>
<p><strong>getSuggestedMinimumWidth()</strong>：当View没有设置背景时，默认大小就是<code>mMinWidth</code>，这个值对应<code>Android:minWidth</code>属性，如果没有设置时默认为0. 如果有设置背景，则默认大小为<code>mMinWidth</code>和<code>mBackground.getMinimumWidth()</code>当中的较大值。</p>
</li>
<li>
<p><strong>getDefaultSize(int size, int measureSpec)</strong>：用来获取View默认的宽高，在**getDefaultSize()**中对<code>MeasureSpec.AT_MOST</code>,<code>MeasureSpec.EXACTLY</code>两个的处理是一样的，我们自定义<code>View</code>的时候 要对两种模式进行处理。</p>
</li>
</ul>
<h4><a id="3_ViewGroupmeasureonMeasure_435"></a>3. ViewGroup中并没有measure()也没有onMeasure()</h4>
<p>因为ViewGroup除了测量自身的宽高，还需要测量各个子<code>View</code>的宽高，不同的布局测量方式不同 (例如 <code>LinearLayout</code>跟<code>RelativeLayout</code>等布局）,所以直接交由继承者根据自己的需要去复写。但是里面因为子<code>View</code>的测量是相对固定的，所以里面已经提供了基本的<code>measureChildren()</code>以及<code>measureChild()</code>来帮助我们对子<code>View</code>进行测量 这个可以看一下我另一篇文章：<code>LinearLayout # onMeasure()</code><a href="https://www.jianshu.com/p/61efaa047ae4" rel="nofollow">LinearLayout onMeasure源码阅读</a></p>
<h3><a id="onLayout_439"></a>六、onLayout()相关</h3>
<blockquote>
<ol>
<li>View.java的onLayout方法是空实现:因为子View的位置，是由其父控件的onLayout方法来确定的。</li>
<li>onLayout(int l, int t, int r, int b)中的参数l、t、r、b都是相对于其父 控件的位置。</li>
<li>自身的mLeft, mTop, mRight, mBottom都是相对于父控件的位置。</li>
</ol>
</blockquote>
<h4><a id="1_Android_445"></a>1. Android坐标系</h4>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi1jNjhiYzMzN2Q5YWEyMmQwLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="2_View_450"></a>2. 内部View坐标系跟点击坐标</h4>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wNmRlZGRiMGRmMjJkMWZhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="3_Viewlayoutint_l_int_t_int_r_int_b_454"></a>3. 看一下View#layout(int l, int t, int r, int b)源码</h4>
<pre><code>public void layout(int l, int t, int r, int b) {
        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }

        int oldL = mLeft;
        int oldT = mTop;
        int oldB = mBottom;
        int oldR = mRight;

        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
            onLayout(changed, l, t, r, b);
   //   ....省略其它部分
    }
  private boolean setOpticalFrame(int left, int top, int right, int bottom) {
        Insets parentInsets = mParent instanceof View ?
                ((View) mParent).getOpticalInsets() : Insets.NONE;
        Insets childInsets = getOpticalInsets();
        return setFrame(
                left   + parentInsets.left - childInsets.left,
                top    + parentInsets.top  - childInsets.top,
                right  + parentInsets.left + childInsets.right,
                bottom + parentInsets.top  + childInsets.bottom);
    }
  protected boolean setFrame(int left, int top, int right, int bottom) {
        boolean changed = false;
    // ....省略其它部分
        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;
            int drawn = mPrivateFlags &amp; PFLAG_DRAWN;
            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;
            int newWidth = right - left;
            int newHeight = bottom - top;
            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
            invalidate(sizeChanged);
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
            mPrivateFlags |= PFLAG_HAS_BOUNDS;
            if (sizeChanged) {
                sizeChange(newWidth, newHeight, oldWidth, oldHeight);
            }
            if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) {
                mPrivateFlags |= PFLAG_DRAWN;
                invalidate(sizeChanged);
                invalidateParentCaches();
            }
            mPrivateFlags |= drawn;
            mBackgroundSizeChanged = true;
            mDefaultFocusHighlightSizeChanged = true;
            if (mForegroundInfo != null) {
                mForegroundInfo.mBoundsChanged = true;
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
        return changed;
    }

</code></pre>
<p>四个参数<code>l、t、r、b</code>分别代表<code>View</code>的左、上、右、下四个边界相对于其父<code>View</code>的距离。 在调用<code>onLayout(changed, l, t, r, b);</code>之前都会调用到<code>setFrame()</code>确定<code>View</code>在父容器当中的位置，赋值给<code>mLeft</code>,<code>mTop</code>,<code>mRight</code>,<code>mBottom</code>。 在<code>ViewGroup#onLayout()</code>跟<code>View#onLayout()</code>都是空实现，交给继承者根据自身需求去定位</p>
<blockquote>
<p>部分零散知识点：</p>
<ul>
<li><strong><code>getMeasureWidth()</code>与<code>getWidth()</code></strong> <code>getMeasureWidth()</code>返回的是<code>mMeasuredWidth</code>，而该值是在<code>setMeasureDimension()</code>中的<code>setMeasureDimensionRaw()</code>中设置的。因此<code>onMeasure()</code>后的所有方法都能获取到这个值。 <code>getWidth</code>返回的是<code>mRight-mLeft</code>，这两个值，是在<code>layout()</code>中的<code>setFrame()</code>中设置的. <code>getMeasureWidthAndState</code>中有一句： <code>This should be used during measurement and layout calculations only. Use {@link #getWidth()} to see how wide a view is after layout.</code></li>
</ul>
<p>总结：只有在测量过程中和布局计算时，才用<code>getMeasuredWidth()</code>。在layout之后，用<code>getWidth()</code>来获取宽度</p>
</blockquote>
<h3><a id="draw_532"></a>七、draw()绘画过程</h3>
<pre><code> /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1\. Draw the background
         *      2\. If necessary, save the canvas' layers to prepare for fading
         *      3\. Draw view's content
         *      4\. Draw children
         *      5\. If necessary, draw the fading edges and restore layers
         *      6\. Draw decorations (scrollbars for instance)
         */
</code></pre>
<blockquote>
<p>上面是<code>draw()</code>里面写的绘画顺序。</p>
<ol>
<li>绘制背景。</li>
<li>如果必要的话,保存当前<code>canvas</code></li>
<li>绘制<code>View</code>的内容</li>
<li>绘制子<code>View</code></li>
<li>如果必要的话,绘画边缘重新保存图层</li>
<li>画装饰(例如滚动条)</li>
</ol>
</blockquote>
<h4><a id="1_Viewdraw_557"></a>1. 看一下View#draw()源码的实现</h4>
<pre><code>public void draw(Canvas canvas) {
  // Step 1, draw the background, if needed
        int saveCount;

        if (!dirtyOpaque) {
            drawBackground(canvas);
        }

        // skip step 2 &amp; 5 if possible (common case)
        final int viewFlags = mViewFlags;
        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
        if (!verticalEdges &amp;&amp; !horizontalEdges) {
            // Step 3, draw the content
            if (!dirtyOpaque) onDraw(canvas);

            // Step 4, draw the children
            dispatchDraw(canvas);

            drawAutofilledHighlight(canvas);

            // Overlay is part of the content and draws beneath Foreground
            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().dispatchDraw(canvas);
            }

            // Step 6, draw decorations (foreground, scrollbars)
            onDrawForeground(canvas);

            // Step 7, draw the default focus highlight
            drawDefaultFocusHighlight(canvas);

            if (debugDraw()) {
                debugDrawFocus(canvas);
            }

            // we're done...
            return;
        }
}

</code></pre>
<p>由上面可以看到 先调用<code>drawBackground(canvas)</code> -&gt;<code>onDraw(canvas)</code>-&gt;<code>dispatchDraw(canvas)</code>-&gt;<code>onDrawForeground(canvas)</code>越是后面绘画的越是覆盖在最上层。</p>
<p><strong>drawBackground(canvas)</strong>:画背景，不可重写</p>
<p><strong>onDraw(canvas)</strong>：画主体</p>
<ul>
<li><strong>代码写在super.onDraw()前</strong>：会被父类的onDraw覆盖</li>
<li><strong>代码写在super.onDraw()后</strong>：不会被父类的onDraw覆盖</li>
</ul>
<p><strong>dispatchDraw()</strong> ：绘制子 View 的方法</p>
<ul>
<li>
<p><strong>代码写在super.dispatchDraw(canvas)前</strong>：把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。而这个…… 其实和重写 onDraw() 并把绘制代码写在 super.onDraw() 之后的做法，效果是一样的。</p>
</li>
<li>
<p><strong>代码写在super.dispatchDraw(canvas)后</strong>：只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。</p>
</li>
</ul>
<p><strong>onDrawForeground(canvas)</strong>：包含了滑动边缘渐变和滑动条跟前景</p>
<blockquote>
<p>一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制。需要注意，前景的支持是在 Android 6.0（也就是 API 23）才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi03N2U5ZGFkMzIwNzdmYTFhLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h4><a id="2__625"></a>2. 注意事项</h4>
<h5><a id="21__ViewGroup__dispatchDraw__setWillNotDrawfalse_627"></a>2.1 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)；</h5>
<p><em>出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。</em></p>
<h5><a id="22__onDraw_631"></a>2.2 在重写的方法有多个选择时，优先选择 onDraw()</h5>
<p><em>一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。</em></p>
<h3><a id="ActivityView_635"></a>八、在Activity中获取View的宽高的几种方式</h3>
<blockquote>
<p>Activity 获取 view 的宽高， 在 onCreate , onResume 等方法中获取到的都是0， 因为 View 的测量过程并不是和 Activity 的声明周期同步执行的</p>
</blockquote>
<p><strong>1. view.post</strong> post 可以将一个 runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候， View 也已经初始化好了</p>
<pre><code>       view.post(new Runnable() {
            @Override
            public void run() {
                int width = view.getMeasuredWidth();
                int height = view.getMeasuredHeight(); 
            }
        });
</code></pre>
<p><strong>2. ViewTreeObserver</strong> 使用 addOnGlobalLayoutListener 接口， 当 view 树的状态发生改变或者 View 树内部的 view 的可见性发生改变时， onGlobalLayout 都会被调用， 需要注意的是， <strong>onGlobalLayout 方法可能被调用多次</strong>， 代码如下：</p>
<pre><code> view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                int width = view.getMeasuredWidth();
                int height = view.getMeasuredHeight();
            }
        });
</code></pre>
<p><strong>3. onWindowFocusChanged</strong> 这个方法的含义是 View 已经初始化完毕了， 宽高已经准备好了， 需要注意的就是这个方法可能会调用多次， 在 Activity <code>onResume</code> 和<code>onPause</code>的时候都会调用， <strong>也会有多次调用的情况</strong></p>
<pre><code>     @Override
    public void onWindowFocusChanged(boolean hasWindowFocus) {
        super.onWindowFocusChanged(hasWindowFocus);
        if(hasWindowFocus){
            int width = view.getMeasuredWidth();
            int height = view.getMeasuredHeight();
        }
    }
</code></pre>
<p>节选自：未扬帆的小船https://juejin.im/post/5dde44dc5188250e8b235d83</p>
<h1><a id="_677"></a>最后</h1>
<p>题外话，虽然我在阿里工作时间不长，但也指导过不少同行。很少跟大家一起探讨，今年春节受武汉新型冠状病毒影响，大家都只能在家办公学习，待疫情过去，大家重归工作岗位，面试和岗位流动多起来，因此充分利用这段时间复习，未来在寻找工作过程中占领有利位置就显得尤为重要了。<br>
在这里我分享两本由我们阿里同事总结《Android面试指导》，以及《Android架构师面试题精编解析大全》两本电子书分享给读者，需要的朋友，点击下方链接，前往免费领取！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0xMmMxNGI0NmNjNDAyMWI2LnBuZw?x-oss-process=image/format,png" alt="《Android面试指导》"><br>
<strong>下载地址：<a href="https://shimo.im/docs/3Tvytq686Yyv83KX/read" rel="nofollow">https://shimo.im/docs/3Tvytq686Yyv83KX/read</a></strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODQ1MjUzNi0wZDhjOTNjZDAzNmNhZmEyLnBuZw?x-oss-process=image/format,png" alt="《Android架构师面试题精编解析大全》"><br>
<strong>下载地址：<a href="https://shimo.im/docs/3Tvytq686Yyv83KX/read" rel="nofollow">https://shimo.im/docs/3Tvytq686Yyv83KX/read</a></strong></p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
