<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android开发，你所不知道的Android原生开发的现状</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-02-13 21:31:27                    </span>
                    <span class="read-count">阅读数 60</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-02-13 21:31:27</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104303200">https://blog.csdn.net/weixin_43901866/article/details/104303200</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <ul>
<li>原文地址：<a href="https://www.techyourchance.com/the-state-of-native-android-development-november-2019/" rel="nofollow">The State of Native Android Development, November 2019</a></li>
<li>原文作者：<a href="https://www.techyourchance.com/about/" rel="nofollow">Vasiliy Zukanov</a><br>
Android原生开发的生态一直在不断地发展变化，过去5年从事android开发的经历让我深刻的体会到了这一点。每隔2到3年，谷歌就会发布一些的新的开发指导建议、libraries、frameworks，我花了很多时间来认真审查这些变化并从中找出可能存在的问题。我相信许多Android开发者都有我这样类似的经历。</li>
</ul>
<p>然而，2019年绝对是Android原生开发生态发生剧变的一年。在这一年里，Android sdk添加了许多新的内容、重写和移除了一些旧的内容，官方的开发者指南也进行了大幅度的更新。想要对Android开发有一种完整而又详细的认识实在是太难了。</p>
<p>于是我写下了这篇文章，我试图去总结Android生态系统中所发生的事情，并对原生开发的未来做出一些预测。接下来我会把我的观点分成不同的章节来进行具体的阐述，文章的最后我会分享一些极具争议的观点。</p>
<p>我希望这篇文章会对你们有所帮助，但是请记住，文章中肯定遗漏了许多重要的内容，而且其中的许多观点都是我个人的偏见。</p>
<h2><a id="AndroidX_10"></a>AndroidX</h2>
<p><a href="https://android-developers.googleblog.com/2018/05/hello-world-androidx.html" rel="nofollow">AndroidX的预览版是在一年半前发布的</a>。大约一年前它变得稳定了，与此同时Google也停止了对旧版Support Library的进一步开发。 当我写下这句话的那一刻，我想起了我之前在StackOverflow上提出的一个问题：<a href="https://stackoverflow.com/questions/29197821/why-does-aosp-add-new-apis-to-support-libraries-without-adding-them-to-sdk" rel="nofollow">Why does AOSP add new APIs to support libraries without adding them to SDK?</a>，当时我是一个android开发新手，我想知道Support Library背后的动机，Googl为什么不直接把Support Library放到android sdk里呢？</p>
<p>不过使用“稳定”一词来描述AndroidX似乎有点讽刺，因为关于AndroidX的任何信息似乎都不是稳定的。 Google不断的在往AndroidX里添加新的库和框架。 命名空间和许多旧的API（目前还不到一年）正在以非常快的速度发展。</p>
<p>到目前为止，我已经将我的两个应用迁移到了AndroidX。 一切都很顺利，但我也不觉得有多惊喜。 Jetifier是一种将Support Library上的依赖项重定向到其AndroidX对等项的工具，转换效果令人惊讶。 但是即使应用程序不大，也并不是“一键式迁移”。</p>
<p>我还参与了一个尚未迁移到AndroidX的项目，没有任何问题。在某些情况下，似乎我完全不需要AndroidX。</p>
<p>总而言之，我想说的是：如果是开启新的Android项目，那么肯定是应该使用AndroidX；对于现有的项目，我也建议您做好迁移到AndroidX的计划，即使您现在看不到明显的好处。 无论如何，您很可能都需要迁移，因此最好按自己的计划进行迁移，而不是以后当你需要一些新的AndroidX库时进行紧急的迁移</p>
<h2><a id="Jetpack_22"></a>Jetpack</h2>
<p>在讨论完AndroidX之后，就不得不提到Jetpack了。 据我所知，Jetpack最初只是“architecture components”的工具集合，但是后来扩展为包含了AndroidX的大多数（甚至所有）API的工具集合。 因此，到目前为止，我还没有看到AndroidX和Jetpack之间有任何有意义的区别，市场营销和公关宣传除外。</p>
<p>当您访问<a href="https://developer.android.com/jetpack" rel="nofollow">Jetpack</a>的官方网站时，它看起来不像是技术文档，更像是早期SaaS初创公司的主页。</p>
<p>看看这些“感言”：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04ZDEwYWM0Y2UwMGQ1OWE3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>再看看下面这些app：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy02NDc5ZmRiYTI5OWI2ZDBlLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>如果Jetpack申请2020年独立IPO，我不会感到惊讶，因为他们是如此的专注于营销和公关。</p>
<p>不过说真的，这种向自己的生态系统中的开发人员“销售”api的做法存在一些深层次的问题。比如，为什么有人真的想在搜索中宣传ViewModel？</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0xODA0ODg2MzlhNjEyM2Y2LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>总而言之，由于Jetpack的大部分内容都是来源于AndroidX，所以我之前写的有关AndroidX的内容在很大程度上也适用于Jetpack。</p>
<p>下面，我将分别讨论其中一些具体的API。</p>
<h2><a id="Background_Work_47"></a>Background Work</h2>
<p>当应用程序不在前台时让应用也能执行操作是Android开发中最常见的场景之一。 在引入doze模式、SyncAdapter、GCMNetworkManager、FirebaseJobDispatcher、JobScheduler以及最近的WorkManager之前，您可以通过启动服务（而不是绑定服务）来实现。 这些都是Google自己的API，不过也有很多第三方解决方案，比如Android-Job。</p>
<p>但是，<a href="https://android-developers.googleblog.com/2019/11/unifying-background-task-scheduling-on.html" rel="nofollow">Google最近宣布，他们将通过WorkManager API来统一后台任务的调度</a>。 听起来很不错，但是由于某种原因，当我听到这样的声音时，我总有种似曾相识的感觉……</p>
<p>无论最终能否统一，WorkManager都无法解决在执行后台任务过程中存在的一个最严重的问题：可靠性。 我在这里不做解释，但是请记住，如果您需要在应用程序中执行后台任务，请先阅读<a href="https://dontkillmyapp.com/" rel="nofollow">dontkillmyapp.com</a>上的所有信息。 此外，请在Google的<a href="https://issuetracker.google.com/issues/122098785" rel="nofollow">issue tracker</a>中阅读并加注星标。</p>
<p>Android系统的后台任务执行与调度是一团糟，碎片化使得它非常细微且不可靠。</p>
<p>过去，我一直主张尽可能的将数据同步等类似的工作放在后台来执行，我可能是SyncAdapter的最后一批粉丝。 但是今天，鉴于可靠性问题，我主张相反的做法：尽可能避免在后台执行操作。 如果您的PM坚持使用此功能，请向他们展示以上链接，并向他们解释，后台任务需要花费数百小时的时间来实现，而且带来的麻烦多于收益。</p>
<p>有些时候执行后台任务是不可避免的，但是在大多数情况下，您可以不这样做。即使以给用户带来一些不便为代价，它也可能是最佳选择。</p>
<h2><a id="Databases_61"></a>Databases</h2>
<p>毫无疑问，Room在众多SQLite的ORM框架中占据着主导地位。从2.2.0开始，Room支持增量注解处理。不过请记住，您的应用架构不应过于关心使用了哪种ORM框架。因此，作为architecture components的一员，Room只是市场术语，而不是技术角色。</p>
<p>Android开发中ORM框架的主要竞争者是SQLDelight。 这个库比Room还要老，但是据我了解，在过去的一年左右的时间里，它已经被重写了很多。 不幸的是，它现在只针对Kotlin。 另一方面，SQLDelight支持Kotlin跨平台。 因此，随着Kotlin使用率的增加，我预计SQLDelight的使用率也会随之增加。</p>
<p>顺便说一下，AndroidX中有对原生SQLite的使用说明，我还不知道该怎么使用。但是如果您想在应用中使用原生SQLite，那么你或许需要去认真的研究下这个主题。</p>
<p>此外还有许多针对Android的非关系型的数据库，例如Realm，Parse，Firebase，ObjectBox等（其中有些仍在使用SQLite）。如果我没记错的话，它们中的大多数（甚至全部）都具有自动数据同步功能。 一段时间以来，这些解决方案比较流行，但据我所知，它们已经不复存在了。但是我并不会马上认为非关系型的数据库不再重要了。</p>
<p>去年，我编写了一个非常复杂的集成了Parse Server的Android应用。 我使用了Android版本的的Parse SDK，体验都非常好。如果您的公司已经雇用了许多后端开发人员，或者您需要实现许多服务器端逻辑，这可能不是最佳解决方案，但是对于仅在后端执行CRUD操作的初创企业和个人来说，这可能会是一种好的选择。</p>
<p>但是我必须提醒的一点是：如果您要采用数据库即服务的解决方案（例如Firebase），那么请务必了解其长期的成本和影响。</p>
<h2><a id="External_Storage_75"></a>External Storage</h2>
<p>关于外部存储的开发，这里有许多有“意思”的事情。</p>
<p>如果您应用的target sdk版本等于或者大于29，<a href="https://youtu.be/UnJ3amzJM94" rel="nofollow">那么你的应用将无法再正常访问手机外部存储上的文件，除了少数几种明显的情况</a>。 相反，您需要使用SAF框架（据说），该框架允许用户进行更精细的访问管理。不幸的是，SAF的工作方式与之前完全不同，因此某些应用程序可能需要进行重大重构。</p>
<p>Google希望从Android 10开始对所有的应用程序都实行这一要求，但它引起了开发者社区的强烈抗议，于是他们决定推迟此功能。 因此，即使您的应用设置target sdk版本为 29，它仍可以在“旧版”模式下工作。 但是，无论目标API级别是多少，下一版的Android系统都将对所有应用的存储访问范围做更加严格的限制。</p>
<p>到目前为止，我还没有使用SAF框架，但是从我在互联网上阅读的许多讨论中看来，这可能是一项艰巨的任务。因此，如果您的应用程序还在以“旧版”模式使用外部存储，那么最好立即开始进行重构和测试。</p>
<h2><a id="Shared_Preferences_85"></a>Shared Preferences</h2>
<p>几周前，<a href="https://www.techyourchance.com/the-state-of-native-android-development-november-2019/" rel="nofollow">AndroidX系列中添加了一个新框架</a>。 它的commit message是这么说的：</p>
<blockquote>
<p>New library meant to replace SharedPreferences. The name is not final, this is just for implementation review and to support the design doc (feel free to request the design doc privately)[…]</p>
</blockquote>
<p>目前我们无需担心，但从长远来看，似乎SharedPreferences会被重写，我们需要使用这种新的方法。</p>
<p>SharedPreferences和这个新框架之间的主要区别在于，<a href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1169184/3/applicationpreferences/src/main/java/androidx/applicationpreferences/ApplicationPreferences.java" rel="nofollow">默认情况下后者是异步的</a>。 换句话说，您需要实现一个回调以获取特定键的值，该回调将在以后的某个时间收到通知。</p>
<p>如果您对这种异步通知的机制感到好奇，则可以阅读StackOverflow上的这个<a href="https://stackoverflow.com/questions/37549578/how-to-get-something-useful-from-this-anr-log/37551254#37551254" rel="nofollow">答案</a>。 Reddit用户Tolriq在这里分享了他们遇到此bug的概率。 在他们的应用中，这个bug会影响1 / 10,000 / SESSIONS_PER_USER_PER_MONTH的用户。 对于一般的应用程序，这可能微不足道。但是在需要高可靠性的情况下，这可能会引起严重的后果。 例如，在装有Android Auto的汽车中，应用程序挂起和随后的崩溃会分散驾驶员的注意力，这可能会导致非常不幸的后果。</p>
<h2><a id="Dependency_Injection_97"></a>Dependency Injection</h2>
<p>在依赖注入方面，最大的变化就是Dagger-Android的弃用。 这里我想解释两点： 首先，我说的弃用并不是指“正式”弃用，因为它尚未正式弃用。 其次，Dagger-Android并不是整个Dagger2框架，而只是相对较新的功能。 我在这个主题上写了一篇非常详尽的<a href="https://www.techyourchance.com/dagger-android-dead/" rel="nofollow">文章</a>，所以我在这里不再重复。</p>
<p>至于其他依赖注入框架，我不认为它们是Dagger的真正竞争者。 例如，Koin也许不错，但我认为它不会吸引很多人。 实际上，我相信它仅由于两个主要原因而得到了初步采用。 第一个是Dagger的糟糕文档，Koin在这方面要比Dagger领先N光年。 第二个原因是Koin是用Kotlin编写的，它借着kotlin发展的浪潮开始兴起。 到目前为止，这波浪潮已经几乎消逝。</p>
<p>我认为可能会发生的情况是，纯依赖注入的框架（又称为手动依赖注入）会逐渐出现。</p>
<p>现在，谷歌声称<a href="https://www.youtube.com/watch?v=o-ins1nvbDg&amp;feature=youtu.be&amp;t=308" rel="nofollow">“随着应用程序的不断增大，手动依赖项注入成本呈指数增长”</a>。 我认为，这仅表明他们既不了解“指数”的含义，也没做过任何实际的“测量”。 此声明是完全错误的，我希望Google不要以这种方式来误导社区里的开发者了。</p>
<p>事实上，纯依赖注入在后端开发中非常普遍（尤其是在开发微服务的时候，您不想在其中添加对每个服务的框架的依赖），反射也是后端开发中的一个有效的选项。 因此，如果要使用依赖注入框架，他们通常不需要解析编译时代码。</p>
<p>但是，Android开发的情况有所不同。由于我们不能使用反射式DI框架，所以我们使用了Dagger。事实上，我们可以使用反射式DI框架，并且对于大多数项目来说都可以，但是却存在性能问题。我并不是说使用反射式DI框架是安全的，但它绝对不是一种非黑即白的方案。无论如何，Dagger已经是在Android开发中使用依赖注入的事实上的标准，我们都使用它。但使用Dagger的代价也很明显：</p>
<ul>
<li>1）应用的代码越多，在构建过程中运行注解处理所花费的时间就越多。</li>
<li>2）应用参与的开发人员越多，他们需要执行的构建次数就越多。</li>
<li>3）所有开发人员都需要学习Dagger ，这需要很多时间。</li>
</ul>
<p>换句话说，虽然Dagger确实允许您编写更少的代码，但由于它会影响构建时间和所需的培训时间，因此在大型项目上它会花费更多的时间。</p>
<p>在大型项目中，构建时间慢才是真正的问题，并成为主要的生产力瓶颈。 因此，尽管Dagger确实提供了非常出色的功能来简化DI（当然，一旦您知道如何使用它），但我相信我们对纯依赖注入会产生越来越多的兴趣。</p>
<h2><a id="DataBinding_119"></a>DataBinding</h2>
<p>开发人员采用DataBidning的主要原因之一是不再需要调用findViewById（）了。 老实说，findViewById确实很冗余，我也不介意摆脱它们。 但是，在我看来，调用findViewById（）带来的小麻烦并不能证明使用DataBinding是合理的。 好消息是，很快我们将能够使用另一个新功能<a href="https://developer.android.com/topic/libraries/view-binding" rel="nofollow">ViewBinding</a>来删除这些findViewById（）的调用。</p>
<p>实际上，我从来都不相信DataBinding。对于它（应该）解决的问题，我感觉太复杂了。 此外，DataBinding允许开发人员将逻辑放入XML布局中。 经验丰富的开发人员是不会使用这种方法的，因为这增加了项目维护的难度。这是DataBinding框架的另一个缺点。</p>
<p>早在2016年11月，当DataBinding正处于大肆宣传的顶峰时，我在StackOverflow上的一个<a href="https://stackoverflow.com/questions/4916209/which-design-patterns-are-used-on-android/30628530#30628530" rel="nofollow">答案</a>中做出了以下预测：</p>
<blockquote>
<p>However, there is one prediction I can make with a high degree of confidence: Usage of the Data Binding library will not become an industry standard. I’m confident to say that because the Data Binding library (in its current implementation) provides short-term productivity gains and some kind of architectural guideline, but it will make the code non-maintainable in the long run. Once long-term effects of this library will surface – it will be abandoned.</p>
</blockquote>
<p>现在，关于DataBinding的使用率，我没有任何统计数据，但是很明显，它并没有成为行业标准。 我自己还从未见过使用DataBinding的专业项目，也很少见到在其应用中使用DataBinding的开发人员。据我估计，一旦ViewBinding成熟并被广泛采用，DataBinding将会更加流行，并成为“传统”框架。</p>
<h2><a id="Preserving_State_on_Configuration_Changes_131"></a>Preserving State on Configuration Changes</h2>
<p>自从引入ViewModel之后，在Android应用中对于配置更改的处理就变得一团糟。 我知道我的这种说法太苛刻了点，但实际上，这是我可以描述的最温和的表达方式。</p>
<p>对我来说幸运的是，Gabor Varadi（又名Zhuinden）已经在Reddit上的<a href="https://www.reddit.com/r/androiddev/comments/b908fr/can_someone_explain_to_me_why_aac_is_trying_to/" rel="nofollow">这篇文章</a>中对这一问题进行了总结，所以我不需要自己做。他的结论就是：不推荐使用onRetainCustomNonConfigurationInstance（），而推荐使用ViewModel。有趣的是，在该帖子的结尾，Gabor做了一些颇具嘲讽味道的预测：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03Zjk3ZWI0NGRmNTc5MzZjLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>你发现什么了吗？ <a href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1159084" rel="nofollow">Retained Fragments现在已经被弃用了！</a> 。</p>
<p>我认为，弃用Retained Fragments实际上是一个好主意。 Fragment的生命周期里具有onAttach（）和onDetach（）这两个方法的唯一原因就是为了支持Retained Fragments的使用。 通过弃用Retained Fragments，这些方法也可以弃用，并且可以简化Fragment的生命周期。 如果您使用<a href="https://www.techyourchance.com/android-fragment-lifecycle-for-professional-developers/" rel="nofollow">我的方法</a>来处理Fragment的生命周期，那么这种弃用就不会让您感到困扰，因为我长期以来一直建议您避免Retained Fragments，忽略onAttach（）和onDetach（）方法。</p>
<p>尽管有充分的理由要弃用Retained Fragments，但弃用onRetainCustomNonConfigurationInstance（）却是胡说八道。 这不是我说的，而是Jake Wharton说的（您可以在前面提到的Gabor在Reddit上的帖子下阅读他的原话）。</p>
<p>为什么要做这些变动呢？我只能看到一种解释：Google决定不管其它技术优势如何，都强制将所有Android项目迁移到ViewModel。 他们愿意弃用所有现有的替代方案以实现其目标，即使这些替代方案实际上优于ViewModel本身。</p>
<p>听起来有点阴谋吧？ 我同意。 但是，幸运的是，我们可以对此理论有一个简单的检验。</p>
<p>虽然我不喜欢Preserving State on Configuration Changes，但它不会以任何方式影响我，因为我没有使用它。 实际上，绝大部分应用程序都不需要它。 它们也不需要ViewModel。正确处理Configuration Changes的方式就是在onSaveInstanceState（Bundle）回调方法里增加处理逻辑。 这是一种更简单，更好的方法，因为它还可以处理保存和恢复流程（也称为进程终止）。 因此，只要我能以这种方式保存状态，就可以了。 尽管Google进行了大量的营销和公关工作，但许多经验丰富的开发人员都意识到ViewModel太复杂了，并且有更好的方法来保留配置更改的状态。</p>
<p>因此，如果Google确实有别有用心，并且想迫使所有项目都使用ViewModel，那么他们还需要弃用onSaveInstanceState（Bundle）。 我知道这听起来很疯狂，但这实际上是件好事，因为如果这种疯狂的预测成真，您就会知道基础理论是正确的。</p>
<p>但是，鉴于Android的内存管理机制，Google不能仅在不提供可靠替代方案的情况下就弃用onSaveInstanceState（Bundle）。 “幸运”的是，<a href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="nofollow">这些变化已经应用在ViewModel的保存状态模块上了</a>。</p>
<p>我想在一两年内我们就会知道这种做法是否有任何优点。‘</p>
<p>总而言之，正如我在本节开头所说的那样，自ViewModel发布以来，Android中的Configuration Changes就成了屎。 两年多以前，当我撰写题为<a href="https://www.techyourchance.com/android-viewmodel-architecture-component-harmful/" rel="nofollow">“Android ViewModel Architecture Component Considered Harmful”</a>的文章时，我预测ViewModels将是一种浪费。我的所有预测都是真实的，但不幸的是，事实证明真相比这还糟。</p>
<h2><a id="Concurrency_159"></a>Concurrency</h2>
<p>在并发这方面，最大的变化就是AsyncTask的弃用。 我已经写了一篇有关此主题的非常详细的<a href="https://www.techyourchance.com/asynctask-deprecated/" rel="nofollow">文章</a>，并提出了具体建议，因此在此不再赘述。</p>
<p>接下来我说的话可能会使部分读者感到不满。拜托，别太把这事当真。</p>
<p>Android开发中另一个流行的多线程框架RxJava很快就会成为“过去式”。 从下面这幅StackOverflow趋势图可以明显看出：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03NDVlODAyMGZjYjJjNmM1LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>许多开发者会质疑我的观点，称该数据不具有代表性，并且还有其他方法的可以解释该图。他们可能是正确的，因为我自己也不是数据科学家。但是，在此图中，我看不到任何其他关于峰值的解释，而且RxJava的曲线与AsyncTask的曲线具有相同的斜率。</p>
<p>因此，如果您尚未花时间在学习RxJava上并且您的项目没有使用它，那么我建议您避免使用它。实际上，这一直是我的建议，今天它也得到了数据的支持。</p>
<p>如果您的项目已经使用了Rx，也请不要惊慌，您无需立即重构任何东西。但是，请记住，今后找到具有Rx经验的开发人员将越来越困难。 因此，在项目中广泛使用Rx可能需要新的开发人员投入更多的时间。最终，广泛使用Rx的项目将被视为“not cool”（例如今天使用AsyncTask和Loaders的项目）。</p>
<p>我知道我的这些观点对于许多开发人员来说很不友好。他们花了数周时间来学习RxJava，甚至说服了同事在项目中使用RxJava，现在我却说它会成为“过去式”。我只想说我只是分析实际情况并根据我所看到的做出预测，我可能是错的，也可能是对的。</p>
<p>在Kotlin语言中，我们可以使用协程。我最近使用协程实现了<a href="https://www.techyourchance.com/kotlin-coroutines-in-complex-scenarios/" rel="nofollow">一些复杂的用例</a>，发现此框架非常的细微和复杂，并且相对不成熟，我甚至发现了一个bug。</p>
<p>有一种流行的说法是，协程使得并发处理更简单。我从来不这样认为，因为我知道并发是非常复杂的，但是在我有了一些实践经验之后，我可以自信地说，协程并没有想像中的那么美好。在我看来，协程实际上增加了程序复杂性，所以我建议你们小心地使用它们。</p>
<p>另一方面，协程似乎将成为Kotlin语言里处理并发操作的默认方式。因此，我认为如果您编写Kotlin代码，您需要投入时间并学会使用它们。</p>
<p>据我所知，目前还有一个流式框架，它在协程之上添加了流处理操作符。几个月前才稳定下来，所以我现在还不能说什么。</p>
<h2><a id="Kotlin_186"></a>Kotlin</h2>
<p>现在让我们来讨论一下Kotlin。根据以往的经验，我知道这是一个非常敏感的话题，而且不管我描述的多么客观，最终都会遭受一些开发者的攻击。然而，我认为在总结原生Android开发现状的时候跳过Kotlin是极不诚实的。因此，我再次请你不要把我说的话当真。</p>
<p>你所需要知道的一个重要的事实是：在Android开发中使用Kotlin会严重增加你的构建时间。</p>
<p>在这篇<a href="https://eng.uber.com/measuring-kotlin-build-performance/" rel="nofollow">文章</a>中，您会了解到我在使用Kotlin进行开发时对构建时间所进行的统计测试的结果。clean build 增加了18%的构建时间，incremental build 增加了8%的构建时间。</p>
<p><a href="https://eng.uber.com/measuring-kotlin-build-performance/" rel="nofollow">Uber与JetBrains也联合发表了他们自己的研究结果</a>，他们的结果更为负面。如果您不在应用程序中使用注解处理器，那么引入Kotlin可能会使您的构建时间增加四倍！如果您使用了注解处理器，那么引入Kotlin会使您的构建时间增加50%-100%。</p>
<p>Uber的研究结果与<a href="https://publicobject.com/2019/05/13/metrics-for-okhttps-kotlin-upgrade/" rel="nofollow">将OkHttp迁移到Kotlin版本</a>后构建时间增加了4倍的结果是一致的。</p>
<p>如果您对这些数字感到惊讶，您不用担心-这不是您的错，而且您并不孤单。尽管这个事实极为重要，但它并未得到广泛讨论，并且我觉得Google也试图回避这个事实。我曾与Google内部一个熟悉此事的开发人员有过一次非常有趣的讨论，我问他是否可以讨论下这个话题，他说：“我不喜欢；我不喜欢；我不喜欢。这是一件很微妙的事情。”</p>
<p>除了增加构建时间之外，Kotlin还不支持增量注解处理，而在大约10个月前Java就已经支持增量注解处理了。</p>
<p>两年前，我写了一篇<a href="https://www.techyourchance.com/kotlin-vs-java-whole-story/" rel="nofollow">文章</a>来警告开发者们在早期使用Kotlin时可能会遇到的潜在风险。在很长一段时间内我被称为“kotlin的讨厌者”。</p>
<p>但是，如果您今天阅读这篇文章，您会发现我实际上低估了这些问题的严重性。在大型的Android项目上，构建时间是最糟糕的生产力杀手之一，而且即使在今天，即Kotlin被官方“正式采用”两年多之后的今天，Kotlin仍然不如Java。不管Kotlin带来什么其他好处，所有这些都可能由于更长的构建时间而被否定。</p>
<p>也就是说，我们不应改忽视这样一个事实：是谷歌将android开发的生态强行推向了kotlin，使得其使用率在稳步上升。</p>
<p>就我个人而言，我并没有在我目前已经开始的新项目中选择kotlin语言，我不想在kotlin上浪费我自己的时间。不过，从现在开始，我会认真考虑使用kotlin来开发新项目，我已经在几个demo上尝试过了。但是我不同意开发人员说你必须在新项目中使用Kotlin，这仍然是一种权衡。</p>
<p>至于你们是否应该将现有项目迁移到Kotlin，我无法提供任何一般性建议，您需要根据具体的情况进行仔细的分析。但是，如果您确实决定开始（或已经开始）迁移，那么这个<a href="https://www.techyourchance.com/migrate-android-applications-to-kotlin-with-caution/" rel="nofollow">帖子</a>可能会对您有用。</p>
<h2><a id="Summary_212"></a>Summary</h2>
<p>在过去的两年中，我开发了三个新的应用程序。我认真研究了现有的项目并分析了早期技术决策所带来的长期影响。我写了一些博客，提供有关Android开发的高级课程。我花了很多时间在互联网上讨论Android开发相关主题。</p>
<p>尽管如此，我还是感觉自己无法跟上Android生态系统的变化。</p>
<p>如果是这样的话，对于那些缺乏经验、需要指导的Android开发人员，我深表歉意，而且我至今无法想象从头开始学习Android开发的感觉。当您对框架和工具感到满意的时候，其中许多将已过时或即将过时。加入这个原本很棒的社区可能是最糟糕的时刻。Google为他们的“包容性”感到非常自豪，但看起来它不适用于经验不足的开发新手。</p>
<p>我个人认为Google对Android框架所做的更改会导致巨大的人类潜力浪费。阅读所有这些更改需要花费数小时，更不用说实际实施它们了。我宁愿花更多的时间来创造价值，而不是追逐自己的尾巴。</p>
<p>在这篇文章中，我试图总结有关Android原生开发现状的一些重要的内容，我还对未来做了一些预测。这篇文章并不完美：它可能包含一些错误，而且还错过了一些其他重要内容。请随时在下面的评论中纠正我。但是请记住，本文没有任何私人内容。我知道我提出了一些非常有争议的观点，但是我相信这是对的。</p>
<p>我还在本文的多个地方引用了我之前写的一些文章。我这样做并不是为了炫耀并说“看，我是正确的！”，而是让您能够了解我过去的预测并将其与实际发生的情况进行比较。当我写这些文章时，他们读起来就像您今天读本篇文章一样疯狂。但是我所做的预测却非常准确。</p>
<p>当然，我也想说：“看，我是对的！”。我冒着巨大的专业风险发表了这些有争议的预测，在得知自己没有误导读者后我感到非常的欣慰。即使有时候我宁愿自己是错的，也希望Google成为真正的合作伙伴。但是到目前为止，情况并非如此。</p>
<p>最后附上文章作者对于跨平台开发的一些看法，仅供参考。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MDM3YjFhNmM5NzA3MmUzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>作者：ronaldong<br>
链接：https://juejin.im/post/5e0eb606f265da5d0d435b88<br>
来源：掘金</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android开发，你所不知道的Android原生开发的现状</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-02-13 21:31:27                    </span>
                    <span class="read-count">阅读数 60</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-02-13 21:31:27</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104303200">https://blog.csdn.net/weixin_43901866/article/details/104303200</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <ul>
<li>原文地址：<a href="https://www.techyourchance.com/the-state-of-native-android-development-november-2019/" rel="nofollow">The State of Native Android Development, November 2019</a></li>
<li>原文作者：<a href="https://www.techyourchance.com/about/" rel="nofollow">Vasiliy Zukanov</a><br>
Android原生开发的生态一直在不断地发展变化，过去5年从事android开发的经历让我深刻的体会到了这一点。每隔2到3年，谷歌就会发布一些的新的开发指导建议、libraries、frameworks，我花了很多时间来认真审查这些变化并从中找出可能存在的问题。我相信许多Android开发者都有我这样类似的经历。</li>
</ul>
<p>然而，2019年绝对是Android原生开发生态发生剧变的一年。在这一年里，Android sdk添加了许多新的内容、重写和移除了一些旧的内容，官方的开发者指南也进行了大幅度的更新。想要对Android开发有一种完整而又详细的认识实在是太难了。</p>
<p>于是我写下了这篇文章，我试图去总结Android生态系统中所发生的事情，并对原生开发的未来做出一些预测。接下来我会把我的观点分成不同的章节来进行具体的阐述，文章的最后我会分享一些极具争议的观点。</p>
<p>我希望这篇文章会对你们有所帮助，但是请记住，文章中肯定遗漏了许多重要的内容，而且其中的许多观点都是我个人的偏见。</p>
<h2><a id="AndroidX_10"></a>AndroidX</h2>
<p><a href="https://android-developers.googleblog.com/2018/05/hello-world-androidx.html" rel="nofollow">AndroidX的预览版是在一年半前发布的</a>。大约一年前它变得稳定了，与此同时Google也停止了对旧版Support Library的进一步开发。 当我写下这句话的那一刻，我想起了我之前在StackOverflow上提出的一个问题：<a href="https://stackoverflow.com/questions/29197821/why-does-aosp-add-new-apis-to-support-libraries-without-adding-them-to-sdk" rel="nofollow">Why does AOSP add new APIs to support libraries without adding them to SDK?</a>，当时我是一个android开发新手，我想知道Support Library背后的动机，Googl为什么不直接把Support Library放到android sdk里呢？</p>
<p>不过使用“稳定”一词来描述AndroidX似乎有点讽刺，因为关于AndroidX的任何信息似乎都不是稳定的。 Google不断的在往AndroidX里添加新的库和框架。 命名空间和许多旧的API（目前还不到一年）正在以非常快的速度发展。</p>
<p>到目前为止，我已经将我的两个应用迁移到了AndroidX。 一切都很顺利，但我也不觉得有多惊喜。 Jetifier是一种将Support Library上的依赖项重定向到其AndroidX对等项的工具，转换效果令人惊讶。 但是即使应用程序不大，也并不是“一键式迁移”。</p>
<p>我还参与了一个尚未迁移到AndroidX的项目，没有任何问题。在某些情况下，似乎我完全不需要AndroidX。</p>
<p>总而言之，我想说的是：如果是开启新的Android项目，那么肯定是应该使用AndroidX；对于现有的项目，我也建议您做好迁移到AndroidX的计划，即使您现在看不到明显的好处。 无论如何，您很可能都需要迁移，因此最好按自己的计划进行迁移，而不是以后当你需要一些新的AndroidX库时进行紧急的迁移</p>
<h2><a id="Jetpack_22"></a>Jetpack</h2>
<p>在讨论完AndroidX之后，就不得不提到Jetpack了。 据我所知，Jetpack最初只是“architecture components”的工具集合，但是后来扩展为包含了AndroidX的大多数（甚至所有）API的工具集合。 因此，到目前为止，我还没有看到AndroidX和Jetpack之间有任何有意义的区别，市场营销和公关宣传除外。</p>
<p>当您访问<a href="https://developer.android.com/jetpack" rel="nofollow">Jetpack</a>的官方网站时，它看起来不像是技术文档，更像是早期SaaS初创公司的主页。</p>
<p>看看这些“感言”：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04ZDEwYWM0Y2UwMGQ1OWE3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>再看看下面这些app：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy02NDc5ZmRiYTI5OWI2ZDBlLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>如果Jetpack申请2020年独立IPO，我不会感到惊讶，因为他们是如此的专注于营销和公关。</p>
<p>不过说真的，这种向自己的生态系统中的开发人员“销售”api的做法存在一些深层次的问题。比如，为什么有人真的想在搜索中宣传ViewModel？</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0xODA0ODg2MzlhNjEyM2Y2LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>总而言之，由于Jetpack的大部分内容都是来源于AndroidX，所以我之前写的有关AndroidX的内容在很大程度上也适用于Jetpack。</p>
<p>下面，我将分别讨论其中一些具体的API。</p>
<h2><a id="Background_Work_47"></a>Background Work</h2>
<p>当应用程序不在前台时让应用也能执行操作是Android开发中最常见的场景之一。 在引入doze模式、SyncAdapter、GCMNetworkManager、FirebaseJobDispatcher、JobScheduler以及最近的WorkManager之前，您可以通过启动服务（而不是绑定服务）来实现。 这些都是Google自己的API，不过也有很多第三方解决方案，比如Android-Job。</p>
<p>但是，<a href="https://android-developers.googleblog.com/2019/11/unifying-background-task-scheduling-on.html" rel="nofollow">Google最近宣布，他们将通过WorkManager API来统一后台任务的调度</a>。 听起来很不错，但是由于某种原因，当我听到这样的声音时，我总有种似曾相识的感觉……</p>
<p>无论最终能否统一，WorkManager都无法解决在执行后台任务过程中存在的一个最严重的问题：可靠性。 我在这里不做解释，但是请记住，如果您需要在应用程序中执行后台任务，请先阅读<a href="https://dontkillmyapp.com/" rel="nofollow">dontkillmyapp.com</a>上的所有信息。 此外，请在Google的<a href="https://issuetracker.google.com/issues/122098785" rel="nofollow">issue tracker</a>中阅读并加注星标。</p>
<p>Android系统的后台任务执行与调度是一团糟，碎片化使得它非常细微且不可靠。</p>
<p>过去，我一直主张尽可能的将数据同步等类似的工作放在后台来执行，我可能是SyncAdapter的最后一批粉丝。 但是今天，鉴于可靠性问题，我主张相反的做法：尽可能避免在后台执行操作。 如果您的PM坚持使用此功能，请向他们展示以上链接，并向他们解释，后台任务需要花费数百小时的时间来实现，而且带来的麻烦多于收益。</p>
<p>有些时候执行后台任务是不可避免的，但是在大多数情况下，您可以不这样做。即使以给用户带来一些不便为代价，它也可能是最佳选择。</p>
<h2><a id="Databases_61"></a>Databases</h2>
<p>毫无疑问，Room在众多SQLite的ORM框架中占据着主导地位。从2.2.0开始，Room支持增量注解处理。不过请记住，您的应用架构不应过于关心使用了哪种ORM框架。因此，作为architecture components的一员，Room只是市场术语，而不是技术角色。</p>
<p>Android开发中ORM框架的主要竞争者是SQLDelight。 这个库比Room还要老，但是据我了解，在过去的一年左右的时间里，它已经被重写了很多。 不幸的是，它现在只针对Kotlin。 另一方面，SQLDelight支持Kotlin跨平台。 因此，随着Kotlin使用率的增加，我预计SQLDelight的使用率也会随之增加。</p>
<p>顺便说一下，AndroidX中有对原生SQLite的使用说明，我还不知道该怎么使用。但是如果您想在应用中使用原生SQLite，那么你或许需要去认真的研究下这个主题。</p>
<p>此外还有许多针对Android的非关系型的数据库，例如Realm，Parse，Firebase，ObjectBox等（其中有些仍在使用SQLite）。如果我没记错的话，它们中的大多数（甚至全部）都具有自动数据同步功能。 一段时间以来，这些解决方案比较流行，但据我所知，它们已经不复存在了。但是我并不会马上认为非关系型的数据库不再重要了。</p>
<p>去年，我编写了一个非常复杂的集成了Parse Server的Android应用。 我使用了Android版本的的Parse SDK，体验都非常好。如果您的公司已经雇用了许多后端开发人员，或者您需要实现许多服务器端逻辑，这可能不是最佳解决方案，但是对于仅在后端执行CRUD操作的初创企业和个人来说，这可能会是一种好的选择。</p>
<p>但是我必须提醒的一点是：如果您要采用数据库即服务的解决方案（例如Firebase），那么请务必了解其长期的成本和影响。</p>
<h2><a id="External_Storage_75"></a>External Storage</h2>
<p>关于外部存储的开发，这里有许多有“意思”的事情。</p>
<p>如果您应用的target sdk版本等于或者大于29，<a href="https://youtu.be/UnJ3amzJM94" rel="nofollow">那么你的应用将无法再正常访问手机外部存储上的文件，除了少数几种明显的情况</a>。 相反，您需要使用SAF框架（据说），该框架允许用户进行更精细的访问管理。不幸的是，SAF的工作方式与之前完全不同，因此某些应用程序可能需要进行重大重构。</p>
<p>Google希望从Android 10开始对所有的应用程序都实行这一要求，但它引起了开发者社区的强烈抗议，于是他们决定推迟此功能。 因此，即使您的应用设置target sdk版本为 29，它仍可以在“旧版”模式下工作。 但是，无论目标API级别是多少，下一版的Android系统都将对所有应用的存储访问范围做更加严格的限制。</p>
<p>到目前为止，我还没有使用SAF框架，但是从我在互联网上阅读的许多讨论中看来，这可能是一项艰巨的任务。因此，如果您的应用程序还在以“旧版”模式使用外部存储，那么最好立即开始进行重构和测试。</p>
<h2><a id="Shared_Preferences_85"></a>Shared Preferences</h2>
<p>几周前，<a href="https://www.techyourchance.com/the-state-of-native-android-development-november-2019/" rel="nofollow">AndroidX系列中添加了一个新框架</a>。 它的commit message是这么说的：</p>
<blockquote>
<p>New library meant to replace SharedPreferences. The name is not final, this is just for implementation review and to support the design doc (feel free to request the design doc privately)[…]</p>
</blockquote>
<p>目前我们无需担心，但从长远来看，似乎SharedPreferences会被重写，我们需要使用这种新的方法。</p>
<p>SharedPreferences和这个新框架之间的主要区别在于，<a href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1169184/3/applicationpreferences/src/main/java/androidx/applicationpreferences/ApplicationPreferences.java" rel="nofollow">默认情况下后者是异步的</a>。 换句话说，您需要实现一个回调以获取特定键的值，该回调将在以后的某个时间收到通知。</p>
<p>如果您对这种异步通知的机制感到好奇，则可以阅读StackOverflow上的这个<a href="https://stackoverflow.com/questions/37549578/how-to-get-something-useful-from-this-anr-log/37551254#37551254" rel="nofollow">答案</a>。 Reddit用户Tolriq在这里分享了他们遇到此bug的概率。 在他们的应用中，这个bug会影响1 / 10,000 / SESSIONS_PER_USER_PER_MONTH的用户。 对于一般的应用程序，这可能微不足道。但是在需要高可靠性的情况下，这可能会引起严重的后果。 例如，在装有Android Auto的汽车中，应用程序挂起和随后的崩溃会分散驾驶员的注意力，这可能会导致非常不幸的后果。</p>
<h2><a id="Dependency_Injection_97"></a>Dependency Injection</h2>
<p>在依赖注入方面，最大的变化就是Dagger-Android的弃用。 这里我想解释两点： 首先，我说的弃用并不是指“正式”弃用，因为它尚未正式弃用。 其次，Dagger-Android并不是整个Dagger2框架，而只是相对较新的功能。 我在这个主题上写了一篇非常详尽的<a href="https://www.techyourchance.com/dagger-android-dead/" rel="nofollow">文章</a>，所以我在这里不再重复。</p>
<p>至于其他依赖注入框架，我不认为它们是Dagger的真正竞争者。 例如，Koin也许不错，但我认为它不会吸引很多人。 实际上，我相信它仅由于两个主要原因而得到了初步采用。 第一个是Dagger的糟糕文档，Koin在这方面要比Dagger领先N光年。 第二个原因是Koin是用Kotlin编写的，它借着kotlin发展的浪潮开始兴起。 到目前为止，这波浪潮已经几乎消逝。</p>
<p>我认为可能会发生的情况是，纯依赖注入的框架（又称为手动依赖注入）会逐渐出现。</p>
<p>现在，谷歌声称<a href="https://www.youtube.com/watch?v=o-ins1nvbDg&amp;feature=youtu.be&amp;t=308" rel="nofollow">“随着应用程序的不断增大，手动依赖项注入成本呈指数增长”</a>。 我认为，这仅表明他们既不了解“指数”的含义，也没做过任何实际的“测量”。 此声明是完全错误的，我希望Google不要以这种方式来误导社区里的开发者了。</p>
<p>事实上，纯依赖注入在后端开发中非常普遍（尤其是在开发微服务的时候，您不想在其中添加对每个服务的框架的依赖），反射也是后端开发中的一个有效的选项。 因此，如果要使用依赖注入框架，他们通常不需要解析编译时代码。</p>
<p>但是，Android开发的情况有所不同。由于我们不能使用反射式DI框架，所以我们使用了Dagger。事实上，我们可以使用反射式DI框架，并且对于大多数项目来说都可以，但是却存在性能问题。我并不是说使用反射式DI框架是安全的，但它绝对不是一种非黑即白的方案。无论如何，Dagger已经是在Android开发中使用依赖注入的事实上的标准，我们都使用它。但使用Dagger的代价也很明显：</p>
<ul>
<li>1）应用的代码越多，在构建过程中运行注解处理所花费的时间就越多。</li>
<li>2）应用参与的开发人员越多，他们需要执行的构建次数就越多。</li>
<li>3）所有开发人员都需要学习Dagger ，这需要很多时间。</li>
</ul>
<p>换句话说，虽然Dagger确实允许您编写更少的代码，但由于它会影响构建时间和所需的培训时间，因此在大型项目上它会花费更多的时间。</p>
<p>在大型项目中，构建时间慢才是真正的问题，并成为主要的生产力瓶颈。 因此，尽管Dagger确实提供了非常出色的功能来简化DI（当然，一旦您知道如何使用它），但我相信我们对纯依赖注入会产生越来越多的兴趣。</p>
<h2><a id="DataBinding_119"></a>DataBinding</h2>
<p>开发人员采用DataBidning的主要原因之一是不再需要调用findViewById（）了。 老实说，findViewById确实很冗余，我也不介意摆脱它们。 但是，在我看来，调用findViewById（）带来的小麻烦并不能证明使用DataBinding是合理的。 好消息是，很快我们将能够使用另一个新功能<a href="https://developer.android.com/topic/libraries/view-binding" rel="nofollow">ViewBinding</a>来删除这些findViewById（）的调用。</p>
<p>实际上，我从来都不相信DataBinding。对于它（应该）解决的问题，我感觉太复杂了。 此外，DataBinding允许开发人员将逻辑放入XML布局中。 经验丰富的开发人员是不会使用这种方法的，因为这增加了项目维护的难度。这是DataBinding框架的另一个缺点。</p>
<p>早在2016年11月，当DataBinding正处于大肆宣传的顶峰时，我在StackOverflow上的一个<a href="https://stackoverflow.com/questions/4916209/which-design-patterns-are-used-on-android/30628530#30628530" rel="nofollow">答案</a>中做出了以下预测：</p>
<blockquote>
<p>However, there is one prediction I can make with a high degree of confidence: Usage of the Data Binding library will not become an industry standard. I’m confident to say that because the Data Binding library (in its current implementation) provides short-term productivity gains and some kind of architectural guideline, but it will make the code non-maintainable in the long run. Once long-term effects of this library will surface – it will be abandoned.</p>
</blockquote>
<p>现在，关于DataBinding的使用率，我没有任何统计数据，但是很明显，它并没有成为行业标准。 我自己还从未见过使用DataBinding的专业项目，也很少见到在其应用中使用DataBinding的开发人员。据我估计，一旦ViewBinding成熟并被广泛采用，DataBinding将会更加流行，并成为“传统”框架。</p>
<h2><a id="Preserving_State_on_Configuration_Changes_131"></a>Preserving State on Configuration Changes</h2>
<p>自从引入ViewModel之后，在Android应用中对于配置更改的处理就变得一团糟。 我知道我的这种说法太苛刻了点，但实际上，这是我可以描述的最温和的表达方式。</p>
<p>对我来说幸运的是，Gabor Varadi（又名Zhuinden）已经在Reddit上的<a href="https://www.reddit.com/r/androiddev/comments/b908fr/can_someone_explain_to_me_why_aac_is_trying_to/" rel="nofollow">这篇文章</a>中对这一问题进行了总结，所以我不需要自己做。他的结论就是：不推荐使用onRetainCustomNonConfigurationInstance（），而推荐使用ViewModel。有趣的是，在该帖子的结尾，Gabor做了一些颇具嘲讽味道的预测：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03Zjk3ZWI0NGRmNTc5MzZjLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>你发现什么了吗？ <a href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1159084" rel="nofollow">Retained Fragments现在已经被弃用了！</a> 。</p>
<p>我认为，弃用Retained Fragments实际上是一个好主意。 Fragment的生命周期里具有onAttach（）和onDetach（）这两个方法的唯一原因就是为了支持Retained Fragments的使用。 通过弃用Retained Fragments，这些方法也可以弃用，并且可以简化Fragment的生命周期。 如果您使用<a href="https://www.techyourchance.com/android-fragment-lifecycle-for-professional-developers/" rel="nofollow">我的方法</a>来处理Fragment的生命周期，那么这种弃用就不会让您感到困扰，因为我长期以来一直建议您避免Retained Fragments，忽略onAttach（）和onDetach（）方法。</p>
<p>尽管有充分的理由要弃用Retained Fragments，但弃用onRetainCustomNonConfigurationInstance（）却是胡说八道。 这不是我说的，而是Jake Wharton说的（您可以在前面提到的Gabor在Reddit上的帖子下阅读他的原话）。</p>
<p>为什么要做这些变动呢？我只能看到一种解释：Google决定不管其它技术优势如何，都强制将所有Android项目迁移到ViewModel。 他们愿意弃用所有现有的替代方案以实现其目标，即使这些替代方案实际上优于ViewModel本身。</p>
<p>听起来有点阴谋吧？ 我同意。 但是，幸运的是，我们可以对此理论有一个简单的检验。</p>
<p>虽然我不喜欢Preserving State on Configuration Changes，但它不会以任何方式影响我，因为我没有使用它。 实际上，绝大部分应用程序都不需要它。 它们也不需要ViewModel。正确处理Configuration Changes的方式就是在onSaveInstanceState（Bundle）回调方法里增加处理逻辑。 这是一种更简单，更好的方法，因为它还可以处理保存和恢复流程（也称为进程终止）。 因此，只要我能以这种方式保存状态，就可以了。 尽管Google进行了大量的营销和公关工作，但许多经验丰富的开发人员都意识到ViewModel太复杂了，并且有更好的方法来保留配置更改的状态。</p>
<p>因此，如果Google确实有别有用心，并且想迫使所有项目都使用ViewModel，那么他们还需要弃用onSaveInstanceState（Bundle）。 我知道这听起来很疯狂，但这实际上是件好事，因为如果这种疯狂的预测成真，您就会知道基础理论是正确的。</p>
<p>但是，鉴于Android的内存管理机制，Google不能仅在不提供可靠替代方案的情况下就弃用onSaveInstanceState（Bundle）。 “幸运”的是，<a href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="nofollow">这些变化已经应用在ViewModel的保存状态模块上了</a>。</p>
<p>我想在一两年内我们就会知道这种做法是否有任何优点。‘</p>
<p>总而言之，正如我在本节开头所说的那样，自ViewModel发布以来，Android中的Configuration Changes就成了屎。 两年多以前，当我撰写题为<a href="https://www.techyourchance.com/android-viewmodel-architecture-component-harmful/" rel="nofollow">“Android ViewModel Architecture Component Considered Harmful”</a>的文章时，我预测ViewModels将是一种浪费。我的所有预测都是真实的，但不幸的是，事实证明真相比这还糟。</p>
<h2><a id="Concurrency_159"></a>Concurrency</h2>
<p>在并发这方面，最大的变化就是AsyncTask的弃用。 我已经写了一篇有关此主题的非常详细的<a href="https://www.techyourchance.com/asynctask-deprecated/" rel="nofollow">文章</a>，并提出了具体建议，因此在此不再赘述。</p>
<p>接下来我说的话可能会使部分读者感到不满。拜托，别太把这事当真。</p>
<p>Android开发中另一个流行的多线程框架RxJava很快就会成为“过去式”。 从下面这幅StackOverflow趋势图可以明显看出：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03NDVlODAyMGZjYjJjNmM1LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>许多开发者会质疑我的观点，称该数据不具有代表性，并且还有其他方法的可以解释该图。他们可能是正确的，因为我自己也不是数据科学家。但是，在此图中，我看不到任何其他关于峰值的解释，而且RxJava的曲线与AsyncTask的曲线具有相同的斜率。</p>
<p>因此，如果您尚未花时间在学习RxJava上并且您的项目没有使用它，那么我建议您避免使用它。实际上，这一直是我的建议，今天它也得到了数据的支持。</p>
<p>如果您的项目已经使用了Rx，也请不要惊慌，您无需立即重构任何东西。但是，请记住，今后找到具有Rx经验的开发人员将越来越困难。 因此，在项目中广泛使用Rx可能需要新的开发人员投入更多的时间。最终，广泛使用Rx的项目将被视为“not cool”（例如今天使用AsyncTask和Loaders的项目）。</p>
<p>我知道我的这些观点对于许多开发人员来说很不友好。他们花了数周时间来学习RxJava，甚至说服了同事在项目中使用RxJava，现在我却说它会成为“过去式”。我只想说我只是分析实际情况并根据我所看到的做出预测，我可能是错的，也可能是对的。</p>
<p>在Kotlin语言中，我们可以使用协程。我最近使用协程实现了<a href="https://www.techyourchance.com/kotlin-coroutines-in-complex-scenarios/" rel="nofollow">一些复杂的用例</a>，发现此框架非常的细微和复杂，并且相对不成熟，我甚至发现了一个bug。</p>
<p>有一种流行的说法是，协程使得并发处理更简单。我从来不这样认为，因为我知道并发是非常复杂的，但是在我有了一些实践经验之后，我可以自信地说，协程并没有想像中的那么美好。在我看来，协程实际上增加了程序复杂性，所以我建议你们小心地使用它们。</p>
<p>另一方面，协程似乎将成为Kotlin语言里处理并发操作的默认方式。因此，我认为如果您编写Kotlin代码，您需要投入时间并学会使用它们。</p>
<p>据我所知，目前还有一个流式框架，它在协程之上添加了流处理操作符。几个月前才稳定下来，所以我现在还不能说什么。</p>
<h2><a id="Kotlin_186"></a>Kotlin</h2>
<p>现在让我们来讨论一下Kotlin。根据以往的经验，我知道这是一个非常敏感的话题，而且不管我描述的多么客观，最终都会遭受一些开发者的攻击。然而，我认为在总结原生Android开发现状的时候跳过Kotlin是极不诚实的。因此，我再次请你不要把我说的话当真。</p>
<p>你所需要知道的一个重要的事实是：在Android开发中使用Kotlin会严重增加你的构建时间。</p>
<p>在这篇<a href="https://eng.uber.com/measuring-kotlin-build-performance/" rel="nofollow">文章</a>中，您会了解到我在使用Kotlin进行开发时对构建时间所进行的统计测试的结果。clean build 增加了18%的构建时间，incremental build 增加了8%的构建时间。</p>
<p><a href="https://eng.uber.com/measuring-kotlin-build-performance/" rel="nofollow">Uber与JetBrains也联合发表了他们自己的研究结果</a>，他们的结果更为负面。如果您不在应用程序中使用注解处理器，那么引入Kotlin可能会使您的构建时间增加四倍！如果您使用了注解处理器，那么引入Kotlin会使您的构建时间增加50%-100%。</p>
<p>Uber的研究结果与<a href="https://publicobject.com/2019/05/13/metrics-for-okhttps-kotlin-upgrade/" rel="nofollow">将OkHttp迁移到Kotlin版本</a>后构建时间增加了4倍的结果是一致的。</p>
<p>如果您对这些数字感到惊讶，您不用担心-这不是您的错，而且您并不孤单。尽管这个事实极为重要，但它并未得到广泛讨论，并且我觉得Google也试图回避这个事实。我曾与Google内部一个熟悉此事的开发人员有过一次非常有趣的讨论，我问他是否可以讨论下这个话题，他说：“我不喜欢；我不喜欢；我不喜欢。这是一件很微妙的事情。”</p>
<p>除了增加构建时间之外，Kotlin还不支持增量注解处理，而在大约10个月前Java就已经支持增量注解处理了。</p>
<p>两年前，我写了一篇<a href="https://www.techyourchance.com/kotlin-vs-java-whole-story/" rel="nofollow">文章</a>来警告开发者们在早期使用Kotlin时可能会遇到的潜在风险。在很长一段时间内我被称为“kotlin的讨厌者”。</p>
<p>但是，如果您今天阅读这篇文章，您会发现我实际上低估了这些问题的严重性。在大型的Android项目上，构建时间是最糟糕的生产力杀手之一，而且即使在今天，即Kotlin被官方“正式采用”两年多之后的今天，Kotlin仍然不如Java。不管Kotlin带来什么其他好处，所有这些都可能由于更长的构建时间而被否定。</p>
<p>也就是说，我们不应改忽视这样一个事实：是谷歌将android开发的生态强行推向了kotlin，使得其使用率在稳步上升。</p>
<p>就我个人而言，我并没有在我目前已经开始的新项目中选择kotlin语言，我不想在kotlin上浪费我自己的时间。不过，从现在开始，我会认真考虑使用kotlin来开发新项目，我已经在几个demo上尝试过了。但是我不同意开发人员说你必须在新项目中使用Kotlin，这仍然是一种权衡。</p>
<p>至于你们是否应该将现有项目迁移到Kotlin，我无法提供任何一般性建议，您需要根据具体的情况进行仔细的分析。但是，如果您确实决定开始（或已经开始）迁移，那么这个<a href="https://www.techyourchance.com/migrate-android-applications-to-kotlin-with-caution/" rel="nofollow">帖子</a>可能会对您有用。</p>
<h2><a id="Summary_212"></a>Summary</h2>
<p>在过去的两年中，我开发了三个新的应用程序。我认真研究了现有的项目并分析了早期技术决策所带来的长期影响。我写了一些博客，提供有关Android开发的高级课程。我花了很多时间在互联网上讨论Android开发相关主题。</p>
<p>尽管如此，我还是感觉自己无法跟上Android生态系统的变化。</p>
<p>如果是这样的话，对于那些缺乏经验、需要指导的Android开发人员，我深表歉意，而且我至今无法想象从头开始学习Android开发的感觉。当您对框架和工具感到满意的时候，其中许多将已过时或即将过时。加入这个原本很棒的社区可能是最糟糕的时刻。Google为他们的“包容性”感到非常自豪，但看起来它不适用于经验不足的开发新手。</p>
<p>我个人认为Google对Android框架所做的更改会导致巨大的人类潜力浪费。阅读所有这些更改需要花费数小时，更不用说实际实施它们了。我宁愿花更多的时间来创造价值，而不是追逐自己的尾巴。</p>
<p>在这篇文章中，我试图总结有关Android原生开发现状的一些重要的内容，我还对未来做了一些预测。这篇文章并不完美：它可能包含一些错误，而且还错过了一些其他重要内容。请随时在下面的评论中纠正我。但是请记住，本文没有任何私人内容。我知道我提出了一些非常有争议的观点，但是我相信这是对的。</p>
<p>我还在本文的多个地方引用了我之前写的一些文章。我这样做并不是为了炫耀并说“看，我是正确的！”，而是让您能够了解我过去的预测并将其与实际发生的情况进行比较。当我写这些文章时，他们读起来就像您今天读本篇文章一样疯狂。但是我所做的预测却非常准确。</p>
<p>当然，我也想说：“看，我是对的！”。我冒着巨大的专业风险发表了这些有争议的预测，在得知自己没有误导读者后我感到非常的欣慰。即使有时候我宁愿自己是错的，也希望Google成为真正的合作伙伴。但是到目前为止，情况并非如此。</p>
<p>最后附上文章作者对于跨平台开发的一些看法，仅供参考。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy04MDM3YjFhNmM5NzA3MmUzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>作者：ronaldong<br>
链接：https://juejin.im/post/5e0eb606f265da5d0d435b88<br>
来源：掘金</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
