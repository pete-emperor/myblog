<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android中Bitmap内存优化</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-26 20:23:22                    </span>
                    <span class="read-count">阅读数 16</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-26 20:23:22</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9429255.html">
                                       程序员                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9605682.html">
                                       字节跳动                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9721804.html">
                                       技术                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/105127123">https://blog.csdn.net/weixin_43901866/article/details/105127123</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>Android开发中，Bitmap是经常会遇到的对象，特别是在列表图片展示、大图显示等界面。而Bitmap实实在在是内存使用的“大客户”。如何更好的使用Bitmap，减少其对App内存的使用，是Android优化方面不可回避的问题。因此，本文从常规的Bitmap使用，到Bitmap内存计算进行了介绍，最后分析了Bitmap的源码和其内存模型在不同版本上的变化。</p>
<h2><a id="Bitmap_2"></a>Bitmap的使用</h2>
<p>一般来说，一个对象的使用，我们会尝试利用其构造函数去生成这个对象。在Bitmap中，其构造函数：</p>
<pre><code>// called from JNI
    Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) 

</code></pre>
<p>通过构造函数的注释，得知这是一个给native层调用的方法，因此可以知道Bitmap的创建将会涉及到底层库的支持。为了方便从不同来源来创建Bitmap，Android中提供了BitmapFactory工具类。BitmapFactory类中有一系列的decodeXXX方法，用于解析资源文件、本地文件、流等方式，基本流程都很类似，读取目标文件，转换成输入流，调用native方法解析流，虽然Java层代码没有体现，但是我们可以猜想到，最后native方法解析完成后，必然会通过JNI调用Bitmap的构造函数，完成Java层的Bitmap对象创建。</p>
<pre><code>// BitmapFactory部分代码：
public static Bitmap decodeResource(Resources res, int id)
public static Bitmap decodeStream(InputStream is)
private static native Bitmap nativeDecodeStream

</code></pre>
<p>native层的代码稍后我们在看，先从Java层来看看常规的使用。典型的一个例子是，当我们需要从本地Resource中加载一个图片，并展示出来，我们可以通过BitmapFacotry来完成：</p>
<pre><code>Bitmap bitmapDecode = BitmapFactory.decodeResource(getResources(), resId);
imageView.setImageBitmap(bitmapDecode);

</code></pre>
<p>当然，这里简单的使用<code>imageView.setImageResource(int resId)</code>也能实现一样的效果，实际上setImageResource方法只是封装了bitmap的读入、解析的过程，并且这个过程是在UI线程完成的，对于性能是有所影响的。另外，也对接下来讨论的内容，Bitmap占用的内存有影响。</p>
<h2><a id="Bitmap_34"></a>Bitmap到底占用多大的内存</h2>
<p>Bitmap作为位图，需要读入一张图片每一个像素点的数据，其主要占用内存的地方也正是这些像素数据。对于像素数据总大小，我们可以猜想为：像素总数量 × 每个像素的字节大小，而像素总数量在矩形屏幕表现下，应该是：横向像素数量 × 纵向像素数量，结合得到：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 横向像素数量 × 纵向像素数量 × 每个像素的字节大小</p>
</blockquote>
<h3><a id="_40"></a>单个像素的字节大小</h3>
<p>单个像素的字节大小由Bitmap的一个可配置的参数Config来决定。<br>
Bitmap中，存在一个枚举类Config，定义了Android中支持的Bitmap配置：</p>

<table>
<thead>
<tr>
<th>Config</th>
<th>占用字节大小（byte）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALPHA_8 (1)</td>
<td>1</td>
<td>单透明通道</td>
</tr>
<tr>
<td>RGB_565 (3)</td>
<td>2</td>
<td>简易RGB色调</td>
</tr>
<tr>
<td>ARGB_4444 (4)</td>
<td>4</td>
<td>已废弃</td>
</tr>
<tr>
<td>ARGB_8888 (5)</td>
<td>4</td>
<td>24位真彩色</td>
</tr>
<tr>
<td>RGBA_F16 (6)</td>
<td>8</td>
<td>Android 8.0 新增（更丰富的色彩表现HDR）</td>
</tr>
<tr>
<td>HARDWARE (7)</td>
<td>Special</td>
<td>Android 8.0 新增 （Bitmap直接存储在graphic memory）<strong>注1</strong></td>
</tr>
</tbody>
</table><blockquote>
<p>**注1：**关于Android 8.0中新增的这个配置，<a href="https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F45511017%2Fbitmap-config-hardware-vs-bitmap-config-rgb-565" rel="nofollow">stackoverflow</a>已经有相关问题，可以关注下。</p>
</blockquote>
<p>之前我们分析到，Bitmap的decode实际上是在native层完成的，因此在native层也存在对应的Config枚举类。<br>
一般使用时，我们并未关注这个配置，在BitmapFactory中，有：</p>
<pre><code>  * Image are loaded with the {@link Bitmap.Config#ARGB_8888} config by default.
  */
  public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;

</code></pre>
<p>因此，Android系统中，默认Bitmap加载图片，使用24位真彩色模式。</p>
<h3><a id="Bitmap_68"></a>Bitmap占用内存大小实例</h3>
<p>首先准备了一张800×600分辨率的jpg图片，大小约135k,放置于res/drawable文件夹下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWRhMjY2NjQ5NTRkN2U4YTMuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvODAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>并将其加载到一个200dp×300dp大小的ImageView中，使用BitmapFactory。</p>
<pre><code>Bitmap bitmapDecode = BitmapFactory.decodeResource(getResources(), resId);
imageView.setImageBitmap(bitmapDecode);

</code></pre>
<p>打印出相关信息：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTJlZjBkYjI3YjlkNDU1Y2IucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQ0L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>图中显示了从资源文件中decode得到的bitmap的长、宽和占用内存大小（byte）等信息。<br>
首先，从数据上可以验证：</p>
<blockquote>
<p>17280000 = 2400 * 1800 * 4</p>
</blockquote>
<p>这意味着，为了将单张800 * 600 的图片加载到内存当中，付出了近17.28M的代价，即使现在手机运存普遍上涨，这样的开销也是无法接受的，因此，对于Bitmap的使用，是需要非常小心的。好在，目前主流的图像加载库（Glide、Fresco等）基本上都不在需要开发者去关心Bitmap内存占用问题。<br>
先暂时回到Bitmap占用内存的计算上来，对比之前定义的公式和源图片的尺寸数据，我们会发现，这张800 * 600大小的图片，decode到内存中的Bitmap的横纵像素数量实际是：2400 * 1800，相当于缩放了3倍大小。为了探究这缩放来自何处，我们开始跟踪源码：之前提到过，Bitmap的decode过程实际上是在native层完成的，为此，需要从<a href="https://link.jianshu.com?t=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fframeworks%2Fbase%2F%2B%2Fandroid-8.0.0_r34%2Fcore%2Fjni%2Fandroid%2Fgraphics%2FBitmapFactory.cpp" rel="nofollow">BitmapFactory.cpp</a>#nativeDecodeXXX方法开始跟踪，这里省略其他decode代码，直接贴出和缩放相关的代码如下：</p>
<pre><code>if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) {
    const int density = env-&gt;GetIntField(options, gOptions_densityFieldID);
    const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);
    const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);
    if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) {
        scale = (float) targetDensity / density;
    }
}
...
int scaledWidth = decoded-&gt;width();
int scaledHeight = decoded-&gt;height();

if (willScale &amp;&amp; mode != SkImageDecoder::kDecodeBounds_Mode) {
    scaledWidth = int(scaledWidth * scale + 0.5f);
    scaledHeight = int(scaledHeight * scale + 0.5f);
}
...
if (willScale) {
    const float sx = scaledWidth / float(decoded-&gt;width());
    const float sy = scaledHeight / float(decoded-&gt;height());
    bitmap-&gt;setConfig(decoded-&gt;getConfig(), scaledWidth, scaledHeight);
    bitmap-&gt;allocPixels(&amp;javaAllocator, NULL);
    bitmap-&gt;eraseColor(0);
    SkPaint paint;
    paint.setFilterBitmap(true);
    SkCanvas canvas(*bitmap);
    canvas.scale(sx, sy);
    canvas.drawBitmap(*decoded, 0.0f, 0.0f, &amp;paint);
}

</code></pre>
<p>从上述代码中，我们看到bitmap最终通过canvas绘制出来，而canvas在绘制之前，有一个scale的操作，scale的值由</p>
<blockquote>
<p><code>scale = (float) targetDensity / density;</code></p>
</blockquote>
<p>这一行代码决定，即缩放的倍率和targetDensity和density相关，而这两个参数都是从传入的options中获取到的。这时候，需要回到Java层，看看options这个对象的定义和赋值。</p>
<h3><a id="BitmapFactoryOptions_133"></a>BitmapFactory#Options</h3>
<p>Options是BitmapFactory中的一个静态内部类，用于配置Bitmap在decode时的一些参数。</p>
<pre><code>// native层doDecode方法，传入了Options参数
static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)

</code></pre>
<p>其内部有很多可配置的参数，下面的类图，列举出了部分常用的参数。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWFkMWY0NDhmODRmODIyNWUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTIzL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>我们先关注之前提到的几个密度相关的参数，通过阅读源码的注释，大概可以知道这三个密度参数代表的涵义：</p>
<ul>
<li>inDensity：Bitmap位图自身的密度、分辨率</li>
<li>inTargetDensity: Bitmap最终绘制的目标位置的分辨率</li>
<li>inScreenDensity: 设备屏幕分辨率</li>
</ul>
<p>其中inDensity和图片存放的资源文件的目录有关，同一张图片放置在不同目录下会有不同的值：</p>

<table>
<thead>
<tr>
<th>density</th>
<th>0.75</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
<th>3</th>
<th>3.5</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>densityDpi</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>560</td>
<td>640</td>
</tr>
<tr>
<td>DpiFolder</td>
<td>ldpi</td>
<td>mdpi</td>
<td>hdpi</td>
<td>xhdpi</td>
<td>xxhdpi</td>
<td>xxxhdpi</td>
<td>xxxxhdpi</td>
</tr>
</tbody>
</table><p>inTargetDensity和inScreenDensity一般来说，很少手动去赋值，默认情况下，是和设备分辨率保持一致。为此，我在手机（红米4，Android 6.0系统，设备dpi 480）上测试加载不同资源文件下的bitmap的参数，结果见下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWYwNDNjY2ZhMjNkZTMwYmYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzczL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>以上可以验证几个结论：</p>
<ul>
<li>同一张图片，放在不同资源目录下，其分辨率会有变化，</li>
<li>bitmap分辨率越高，其解析后的宽高越小，甚至会小于图片原有的尺寸（即缩放），从而内存占用也相应减少</li>
<li>图片不特别放置任何资源目录时，其默认使用mdpi分辨率：160</li>
<li>资源目录分辨率和设备分辨率一致时，图片尺寸不会缩放</li>
</ul>
<p>因此，关于Bitmap占用内存大小的公式，从之前：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 横向像素数量 × 纵向像素数量 × 每个像素的字节大小</p>
</blockquote>
<p>可以更细化为：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 图片宽 × 图片高× (设备分辨率/资源目录分辨率)^2 × 每个像素的字节大小</p>
</blockquote>
<p>对于本节中最开始的例子，如下：</p>
<blockquote>
<p>17,280,000 = 800 * 600 * (480 / 160 )^2 * 4</p>
</blockquote>
<h2><a id="Bitmap_183"></a>Bitmap内存优化</h2>
<p>图片占用的内存一般会分为运行时占用的运存和存储时本地开销（反映在包大小上），这里我们只关注运行时占用内存的优化。<br>
在上一节中，我们看到对于一张800 * 600 大小的图片，不加任何处理直接解析到内存中，将近占用了17.28M的内存大小。想象一下这样的开销发生在一个图片列表中，内存占用将达到非常夸张的地步。从之前Bitmap占用内存的计算公式来看，减少内存主要可以通过以下几种方式：</p>
<ol>
<li>使用低色彩的解析模式，如RGB565，减少单个像素的字节大小</li>
<li>资源文件合理放置，高分辨率图片可以放到高分辨率目录下</li>
<li>图片缩小，减少尺寸</li>
</ol>
<p><strong>第一种方式</strong>，大约能减少一半的内存开销。Android默认是使用ARGB8888配置来处理色彩，占用4字节，改用RGB565，将只占用2字节，代价是显示的色彩将相对少，适用于对色彩丰富程度要求不高的场景。<br>
<strong>第二种方式</strong>，和图片的具体分辨率有关，建议开发中，高分辨率的图像应该放置到合理的资源目录下，注意到Android默认放置的资源目录是对应于160dpi，目前手机屏幕分辨率越来越高，此处能节省下来的开销也是很可观的。理论上，图片放置的资源目录分辨率越高，其占用内存会越小，但是低分辨率图片会因此被拉伸，显示上出现失真。另一方面，高分辨率图片也意味着其占用的本地储存也变大。<br>
<strong>第三种方式</strong>，理论上根据适用的环境，是可以减少十几倍的内存使用的，它基于这样一个事实：源图片尺寸一般都大于目标需要显示的尺寸，因此可以通过缩放的方式，来减少显示时的图片宽高，从而大大减少占用的内存。</p>
<p>前两种方式，相对比较简单。第三种方式会涉及到一些编码，目前也有很多典型的使用方式，如下：</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), resId,options);
options.inJustDecodeBounds = false;
options.inSampleSize = BitmapUtil.computeSampleSize(options, -1, imageView.getWidth() * imageView.getHeight());
Bitmap newBitmap = BitmapFactory.decodeResource(getResources(), resId, options);

</code></pre>
<p>原理很简单，充分利用了Options类里的参数设置，也可以从native底层源码上看到对应的逻辑。第一次解析bitmap只获取尺寸信息，不生成像素数据，继而比较bitmap尺寸和目标尺寸得到缩放倍数，第二次根据缩放倍数去解析我们实际需要的尺寸大小。</p>
<pre><code>// Apply a fine scaling step if necessary.
    if (needsFineScale(codec-&gt;getInfo().dimensions(), size, sampleSize)) {
        willScale = true;
        scaledWidth = codec-&gt;getInfo().width() / sampleSize;
        scaledHeight = codec-&gt;getInfo().height() / sampleSize;
    }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTQxZWEzYmYxMGM5ZWUwNDkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzcxL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>上图是使用上述手段优化后的结果，可以看到现在占用的内存大小大约为960KB，从优化后的宽高来看，第三种方式并没有效果。应为目标ImageView尺寸也不小，而inSampleSize的值必须是2的整数幂，因此计算得到的值还是1。</p>
<p>PS: Bitmap内存占用的优化还有一个方式是复用和缓存</p>
<h2><a id="AndroidBitmap_227"></a>不同Android版本时的Bitmap内存模型</h2>
<p>我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.android.com%2Ftopic%2Fperformance%2Fgraphics%2Fmanage-memory.html" rel="nofollow">Android Developers</a>上列举了从API 8 到API 26之间的分配方式：</p>

<table>
<thead>
<tr>
<th>API级别</th>
<th>API 10 -</th>
<th>API 11 ~ API 25</th>
<th>API 26 +</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap对象存放</td>
<td>Java heap</td>
<td>Java heap</td>
<td>Java heap</td>
</tr>
<tr>
<td>像素(pixel data)数据存放</td>
<td>native heap</td>
<td>Java heap</td>
<td>native heap</td>
</tr>
</tbody>
</table><p>可以看到，最新的Android O之后，谷歌又把像素存放的位置，从java 堆改回到了 native堆。API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到Java堆，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWQ0MmExZDcyZjI0ODVhMzgucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt=""></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTM3ZGU3MDFjMzJkNTA2MDEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt=""></p>
<p>上面两幅图展示了不同系统，加载图片后，内存的变化，8.0的截图比较模糊。途中浅蓝色对应的是Java heap使用，深蓝色对应的是native heap的使用。<br>
跟踪一下8.0的native源码来看看具体的变化：</p>
<pre><code>// BitmapFactory.cpp
    if (!decodingBitmap.setInfo(bitmapInfo) ||
            !decodingBitmap.tryAllocPixels(decodeAllocator, colorTable.get())) {
        // SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()
        // should only only fail if the calculated value for rowBytes is too
        // large.
        // tryAllocPixels() can fail due to OOM on the Java heap, OOM on the
        // native heap, or the recycled javaBitmap being too small to reuse.
        return nullptr;
    }

// Graphics.cpp
bool HeapAllocator::allocPixelRef(SkBitmap* bitmap, SkColorTable* ctable) {
    mStorage = android::Bitmap::allocateHeapBitmap(bitmap, sk_ref_sp(ctable));
    return !!mStorage;
}

// https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/hwui/Bitmap.cpp
static sk_sp&lt;Bitmap&gt; allocateHeapBitmap(size_t size, const SkImageInfo&amp; info, size_t rowBytes) {
    void* addr = calloc(size, 1);
    if (!addr) {
        return nullptr;
    }
    return sk_sp&lt;Bitmap&gt;(new Bitmap(addr, size, info, rowBytes));
}

</code></pre>
<p>还是通过BitmapFactory.cpp#doDecode方法来跟踪，发现其中tryAllocPixels方法，应该是尝试去进行内存分配，其中decodeAllocator会被赋值为HeapAllocator，通过一系列的调用，最终通过calloc方法，在native分配内存。<br>
至于为什么Google 在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新使用。</p>

<table>
<thead>
<tr>
<th>（native存放）</th>
<th>退出Activity</th>
<th>退出App</th>
</tr>
</thead>
<tbody>
<tr>
<td>onStop中主动调用gc()和recycler()</td>
<td>内存不释放</td>
<td>内存释放</td>
</tr>
<tr>
<td>无调用</td>
<td>内存不释放</td>
<td>内存不释放</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>（gpu存放）</th>
<th>退出Activity</th>
<th>退出App</th>
</tr>
</thead>
<tbody>
<tr>
<td>onStop中主动调用gc()和recycler()</td>
<td>内存释放</td>
<td>内存释放</td>
</tr>
<tr>
<td>无调用</td>
<td>内存释放</td>
<td>内存释放</td>
</tr>
</tbody>
</table><h1><a id="_287"></a>总结</h1>
<pre><code>// 8.0源码
    Bitmap(long nativeBitmap, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets)
// 7.0源码
Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets)

</code></pre>
<p>一开始看两者java代码不同，少了存放像素的buffer字段，查阅相关资料到native源码对比，最终总结了下Bitmap内存相关的知识。另外，在Android 8.0中，关于Bitmap的改动有两方面还需深入探究的：1、Config配置为Hardware时的优劣。Hardware配置实际上没有改变像素的位储存大小（还是默认的ARGB8888），但是改变了bitmap像素的存储位置（存放到GPU内存中），对实际应用的影响会如何？；2、Bitmap在8.0后又回归到native存放bitmap像素数据，而这部分数据的回收时机和触发方式又是如何？一般测试下，可以通过native分配Bitmap超过1G的内存数据而不发生崩溃。</p>
<p>作者：Dragon_Boat<br>
链接：https://www.jianshu.com/p/3f6f6e4f1c88<br>
来源：简书</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android中Bitmap内存优化</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-26 20:23:22                    </span>
                    <span class="read-count">阅读数 16</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-26 20:23:22</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9429255.html">
                                       程序员                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9605682.html">
                                       字节跳动                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9721804.html">
                                       技术                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/105127123">https://blog.csdn.net/weixin_43901866/article/details/105127123</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>Android开发中，Bitmap是经常会遇到的对象，特别是在列表图片展示、大图显示等界面。而Bitmap实实在在是内存使用的“大客户”。如何更好的使用Bitmap，减少其对App内存的使用，是Android优化方面不可回避的问题。因此，本文从常规的Bitmap使用，到Bitmap内存计算进行了介绍，最后分析了Bitmap的源码和其内存模型在不同版本上的变化。</p>
<h2><a id="Bitmap_2"></a>Bitmap的使用</h2>
<p>一般来说，一个对象的使用，我们会尝试利用其构造函数去生成这个对象。在Bitmap中，其构造函数：</p>
<pre><code>// called from JNI
    Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets) 

</code></pre>
<p>通过构造函数的注释，得知这是一个给native层调用的方法，因此可以知道Bitmap的创建将会涉及到底层库的支持。为了方便从不同来源来创建Bitmap，Android中提供了BitmapFactory工具类。BitmapFactory类中有一系列的decodeXXX方法，用于解析资源文件、本地文件、流等方式，基本流程都很类似，读取目标文件，转换成输入流，调用native方法解析流，虽然Java层代码没有体现，但是我们可以猜想到，最后native方法解析完成后，必然会通过JNI调用Bitmap的构造函数，完成Java层的Bitmap对象创建。</p>
<pre><code>// BitmapFactory部分代码：
public static Bitmap decodeResource(Resources res, int id)
public static Bitmap decodeStream(InputStream is)
private static native Bitmap nativeDecodeStream

</code></pre>
<p>native层的代码稍后我们在看，先从Java层来看看常规的使用。典型的一个例子是，当我们需要从本地Resource中加载一个图片，并展示出来，我们可以通过BitmapFacotry来完成：</p>
<pre><code>Bitmap bitmapDecode = BitmapFactory.decodeResource(getResources(), resId);
imageView.setImageBitmap(bitmapDecode);

</code></pre>
<p>当然，这里简单的使用<code>imageView.setImageResource(int resId)</code>也能实现一样的效果，实际上setImageResource方法只是封装了bitmap的读入、解析的过程，并且这个过程是在UI线程完成的，对于性能是有所影响的。另外，也对接下来讨论的内容，Bitmap占用的内存有影响。</p>
<h2><a id="Bitmap_34"></a>Bitmap到底占用多大的内存</h2>
<p>Bitmap作为位图，需要读入一张图片每一个像素点的数据，其主要占用内存的地方也正是这些像素数据。对于像素数据总大小，我们可以猜想为：像素总数量 × 每个像素的字节大小，而像素总数量在矩形屏幕表现下，应该是：横向像素数量 × 纵向像素数量，结合得到：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 横向像素数量 × 纵向像素数量 × 每个像素的字节大小</p>
</blockquote>
<h3><a id="_40"></a>单个像素的字节大小</h3>
<p>单个像素的字节大小由Bitmap的一个可配置的参数Config来决定。<br>
Bitmap中，存在一个枚举类Config，定义了Android中支持的Bitmap配置：</p>

<table>
<thead>
<tr>
<th>Config</th>
<th>占用字节大小（byte）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALPHA_8 (1)</td>
<td>1</td>
<td>单透明通道</td>
</tr>
<tr>
<td>RGB_565 (3)</td>
<td>2</td>
<td>简易RGB色调</td>
</tr>
<tr>
<td>ARGB_4444 (4)</td>
<td>4</td>
<td>已废弃</td>
</tr>
<tr>
<td>ARGB_8888 (5)</td>
<td>4</td>
<td>24位真彩色</td>
</tr>
<tr>
<td>RGBA_F16 (6)</td>
<td>8</td>
<td>Android 8.0 新增（更丰富的色彩表现HDR）</td>
</tr>
<tr>
<td>HARDWARE (7)</td>
<td>Special</td>
<td>Android 8.0 新增 （Bitmap直接存储在graphic memory）<strong>注1</strong></td>
</tr>
</tbody>
</table><blockquote>
<p>**注1：**关于Android 8.0中新增的这个配置，<a href="https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F45511017%2Fbitmap-config-hardware-vs-bitmap-config-rgb-565" rel="nofollow">stackoverflow</a>已经有相关问题，可以关注下。</p>
</blockquote>
<p>之前我们分析到，Bitmap的decode实际上是在native层完成的，因此在native层也存在对应的Config枚举类。<br>
一般使用时，我们并未关注这个配置，在BitmapFactory中，有：</p>
<pre><code>  * Image are loaded with the {@link Bitmap.Config#ARGB_8888} config by default.
  */
  public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;

</code></pre>
<p>因此，Android系统中，默认Bitmap加载图片，使用24位真彩色模式。</p>
<h3><a id="Bitmap_68"></a>Bitmap占用内存大小实例</h3>
<p>首先准备了一张800×600分辨率的jpg图片，大小约135k,放置于res/drawable文件夹下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWRhMjY2NjQ5NTRkN2U4YTMuanBnP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvODAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>并将其加载到一个200dp×300dp大小的ImageView中，使用BitmapFactory。</p>
<pre><code>Bitmap bitmapDecode = BitmapFactory.decodeResource(getResources(), resId);
imageView.setImageBitmap(bitmapDecode);

</code></pre>
<p>打印出相关信息：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTJlZjBkYjI3YjlkNDU1Y2IucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzQ0L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>图中显示了从资源文件中decode得到的bitmap的长、宽和占用内存大小（byte）等信息。<br>
首先，从数据上可以验证：</p>
<blockquote>
<p>17280000 = 2400 * 1800 * 4</p>
</blockquote>
<p>这意味着，为了将单张800 * 600 的图片加载到内存当中，付出了近17.28M的代价，即使现在手机运存普遍上涨，这样的开销也是无法接受的，因此，对于Bitmap的使用，是需要非常小心的。好在，目前主流的图像加载库（Glide、Fresco等）基本上都不在需要开发者去关心Bitmap内存占用问题。<br>
先暂时回到Bitmap占用内存的计算上来，对比之前定义的公式和源图片的尺寸数据，我们会发现，这张800 * 600大小的图片，decode到内存中的Bitmap的横纵像素数量实际是：2400 * 1800，相当于缩放了3倍大小。为了探究这缩放来自何处，我们开始跟踪源码：之前提到过，Bitmap的decode过程实际上是在native层完成的，为此，需要从<a href="https://link.jianshu.com?t=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fframeworks%2Fbase%2F%2B%2Fandroid-8.0.0_r34%2Fcore%2Fjni%2Fandroid%2Fgraphics%2FBitmapFactory.cpp" rel="nofollow">BitmapFactory.cpp</a>#nativeDecodeXXX方法开始跟踪，这里省略其他decode代码，直接贴出和缩放相关的代码如下：</p>
<pre><code>if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) {
    const int density = env-&gt;GetIntField(options, gOptions_densityFieldID);
    const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);
    const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);
    if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) {
        scale = (float) targetDensity / density;
    }
}
...
int scaledWidth = decoded-&gt;width();
int scaledHeight = decoded-&gt;height();

if (willScale &amp;&amp; mode != SkImageDecoder::kDecodeBounds_Mode) {
    scaledWidth = int(scaledWidth * scale + 0.5f);
    scaledHeight = int(scaledHeight * scale + 0.5f);
}
...
if (willScale) {
    const float sx = scaledWidth / float(decoded-&gt;width());
    const float sy = scaledHeight / float(decoded-&gt;height());
    bitmap-&gt;setConfig(decoded-&gt;getConfig(), scaledWidth, scaledHeight);
    bitmap-&gt;allocPixels(&amp;javaAllocator, NULL);
    bitmap-&gt;eraseColor(0);
    SkPaint paint;
    paint.setFilterBitmap(true);
    SkCanvas canvas(*bitmap);
    canvas.scale(sx, sy);
    canvas.drawBitmap(*decoded, 0.0f, 0.0f, &amp;paint);
}

</code></pre>
<p>从上述代码中，我们看到bitmap最终通过canvas绘制出来，而canvas在绘制之前，有一个scale的操作，scale的值由</p>
<blockquote>
<p><code>scale = (float) targetDensity / density;</code></p>
</blockquote>
<p>这一行代码决定，即缩放的倍率和targetDensity和density相关，而这两个参数都是从传入的options中获取到的。这时候，需要回到Java层，看看options这个对象的定义和赋值。</p>
<h3><a id="BitmapFactoryOptions_133"></a>BitmapFactory#Options</h3>
<p>Options是BitmapFactory中的一个静态内部类，用于配置Bitmap在decode时的一些参数。</p>
<pre><code>// native层doDecode方法，传入了Options参数
static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)

</code></pre>
<p>其内部有很多可配置的参数，下面的类图，列举出了部分常用的参数。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWFkMWY0NDhmODRmODIyNWUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTIzL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>我们先关注之前提到的几个密度相关的参数，通过阅读源码的注释，大概可以知道这三个密度参数代表的涵义：</p>
<ul>
<li>inDensity：Bitmap位图自身的密度、分辨率</li>
<li>inTargetDensity: Bitmap最终绘制的目标位置的分辨率</li>
<li>inScreenDensity: 设备屏幕分辨率</li>
</ul>
<p>其中inDensity和图片存放的资源文件的目录有关，同一张图片放置在不同目录下会有不同的值：</p>

<table>
<thead>
<tr>
<th>density</th>
<th>0.75</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
<th>3</th>
<th>3.5</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>densityDpi</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>560</td>
<td>640</td>
</tr>
<tr>
<td>DpiFolder</td>
<td>ldpi</td>
<td>mdpi</td>
<td>hdpi</td>
<td>xhdpi</td>
<td>xxhdpi</td>
<td>xxxhdpi</td>
<td>xxxxhdpi</td>
</tr>
</tbody>
</table><p>inTargetDensity和inScreenDensity一般来说，很少手动去赋值，默认情况下，是和设备分辨率保持一致。为此，我在手机（红米4，Android 6.0系统，设备dpi 480）上测试加载不同资源文件下的bitmap的参数，结果见下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWYwNDNjY2ZhMjNkZTMwYmYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzczL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p>以上可以验证几个结论：</p>
<ul>
<li>同一张图片，放在不同资源目录下，其分辨率会有变化，</li>
<li>bitmap分辨率越高，其解析后的宽高越小，甚至会小于图片原有的尺寸（即缩放），从而内存占用也相应减少</li>
<li>图片不特别放置任何资源目录时，其默认使用mdpi分辨率：160</li>
<li>资源目录分辨率和设备分辨率一致时，图片尺寸不会缩放</li>
</ul>
<p>因此，关于Bitmap占用内存大小的公式，从之前：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 横向像素数量 × 纵向像素数量 × 每个像素的字节大小</p>
</blockquote>
<p>可以更细化为：</p>
<blockquote>
<p>Bitmap内存占用 ≈ 像素数据总大小 = 图片宽 × 图片高× (设备分辨率/资源目录分辨率)^2 × 每个像素的字节大小</p>
</blockquote>
<p>对于本节中最开始的例子，如下：</p>
<blockquote>
<p>17,280,000 = 800 * 600 * (480 / 160 )^2 * 4</p>
</blockquote>
<h2><a id="Bitmap_183"></a>Bitmap内存优化</h2>
<p>图片占用的内存一般会分为运行时占用的运存和存储时本地开销（反映在包大小上），这里我们只关注运行时占用内存的优化。<br>
在上一节中，我们看到对于一张800 * 600 大小的图片，不加任何处理直接解析到内存中，将近占用了17.28M的内存大小。想象一下这样的开销发生在一个图片列表中，内存占用将达到非常夸张的地步。从之前Bitmap占用内存的计算公式来看，减少内存主要可以通过以下几种方式：</p>
<ol>
<li>使用低色彩的解析模式，如RGB565，减少单个像素的字节大小</li>
<li>资源文件合理放置，高分辨率图片可以放到高分辨率目录下</li>
<li>图片缩小，减少尺寸</li>
</ol>
<p><strong>第一种方式</strong>，大约能减少一半的内存开销。Android默认是使用ARGB8888配置来处理色彩，占用4字节，改用RGB565，将只占用2字节，代价是显示的色彩将相对少，适用于对色彩丰富程度要求不高的场景。<br>
<strong>第二种方式</strong>，和图片的具体分辨率有关，建议开发中，高分辨率的图像应该放置到合理的资源目录下，注意到Android默认放置的资源目录是对应于160dpi，目前手机屏幕分辨率越来越高，此处能节省下来的开销也是很可观的。理论上，图片放置的资源目录分辨率越高，其占用内存会越小，但是低分辨率图片会因此被拉伸，显示上出现失真。另一方面，高分辨率图片也意味着其占用的本地储存也变大。<br>
<strong>第三种方式</strong>，理论上根据适用的环境，是可以减少十几倍的内存使用的，它基于这样一个事实：源图片尺寸一般都大于目标需要显示的尺寸，因此可以通过缩放的方式，来减少显示时的图片宽高，从而大大减少占用的内存。</p>
<p>前两种方式，相对比较简单。第三种方式会涉及到一些编码，目前也有很多典型的使用方式，如下：</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), resId,options);
options.inJustDecodeBounds = false;
options.inSampleSize = BitmapUtil.computeSampleSize(options, -1, imageView.getWidth() * imageView.getHeight());
Bitmap newBitmap = BitmapFactory.decodeResource(getResources(), resId, options);

</code></pre>
<p>原理很简单，充分利用了Options类里的参数设置，也可以从native底层源码上看到对应的逻辑。第一次解析bitmap只获取尺寸信息，不生成像素数据，继而比较bitmap尺寸和目标尺寸得到缩放倍数，第二次根据缩放倍数去解析我们实际需要的尺寸大小。</p>
<pre><code>// Apply a fine scaling step if necessary.
    if (needsFineScale(codec-&gt;getInfo().dimensions(), size, sampleSize)) {
        willScale = true;
        scaledWidth = codec-&gt;getInfo().width() / sampleSize;
        scaledHeight = codec-&gt;getInfo().height() / sampleSize;
    }

</code></pre>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTQxZWEzYmYxMGM5ZWUwNDkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMzcxL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>上图是使用上述手段优化后的结果，可以看到现在占用的内存大小大约为960KB，从优化后的宽高来看，第三种方式并没有效果。应为目标ImageView尺寸也不小，而inSampleSize的值必须是2的整数幂，因此计算得到的值还是1。</p>
<p>PS: Bitmap内存占用的优化还有一个方式是复用和缓存</p>
<h2><a id="AndroidBitmap_227"></a>不同Android版本时的Bitmap内存模型</h2>
<p>我们知道Android系统中，一个进程的内存可以简单分为Java内存和native内存两部分，而Bitmap对象占用的内存，有Bitmap对象内存和像素数据内存两部分，在不同的Android系统版本中，其所存放的位置也有变化。<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.android.com%2Ftopic%2Fperformance%2Fgraphics%2Fmanage-memory.html" rel="nofollow">Android Developers</a>上列举了从API 8 到API 26之间的分配方式：</p>

<table>
<thead>
<tr>
<th>API级别</th>
<th>API 10 -</th>
<th>API 11 ~ API 25</th>
<th>API 26 +</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap对象存放</td>
<td>Java heap</td>
<td>Java heap</td>
<td>Java heap</td>
</tr>
<tr>
<td>像素(pixel data)数据存放</td>
<td>native heap</td>
<td>Java heap</td>
<td>native heap</td>
</tr>
</tbody>
</table><p>可以看到，最新的Android O之后，谷歌又把像素存放的位置，从java 堆改回到了 native堆。API 11的那次改动，是源于native的内存释放不及时，会导致OOM，因此才将像素数据保存到Java堆，从而保证Bitmap对象释放时，能够同时把像素数据内存也释放掉。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LWQ0MmExZDcyZjI0ODVhMzgucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt=""></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTgyMTI2LTM3ZGU3MDFjMzJkNTA2MDEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt=""></p>
<p>上面两幅图展示了不同系统，加载图片后，内存的变化，8.0的截图比较模糊。途中浅蓝色对应的是Java heap使用，深蓝色对应的是native heap的使用。<br>
跟踪一下8.0的native源码来看看具体的变化：</p>
<pre><code>// BitmapFactory.cpp
    if (!decodingBitmap.setInfo(bitmapInfo) ||
            !decodingBitmap.tryAllocPixels(decodeAllocator, colorTable.get())) {
        // SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()
        // should only only fail if the calculated value for rowBytes is too
        // large.
        // tryAllocPixels() can fail due to OOM on the Java heap, OOM on the
        // native heap, or the recycled javaBitmap being too small to reuse.
        return nullptr;
    }

// Graphics.cpp
bool HeapAllocator::allocPixelRef(SkBitmap* bitmap, SkColorTable* ctable) {
    mStorage = android::Bitmap::allocateHeapBitmap(bitmap, sk_ref_sp(ctable));
    return !!mStorage;
}

// https://android.googlesource.com/platform/frameworks/base/+/master/libs/hwui/hwui/Bitmap.cpp
static sk_sp&lt;Bitmap&gt; allocateHeapBitmap(size_t size, const SkImageInfo&amp; info, size_t rowBytes) {
    void* addr = calloc(size, 1);
    if (!addr) {
        return nullptr;
    }
    return sk_sp&lt;Bitmap&gt;(new Bitmap(addr, size, info, rowBytes));
}

</code></pre>
<p>还是通过BitmapFactory.cpp#doDecode方法来跟踪，发现其中tryAllocPixels方法，应该是尝试去进行内存分配，其中decodeAllocator会被赋值为HeapAllocator，通过一系列的调用，最终通过calloc方法，在native分配内存。<br>
至于为什么Google 在8.0上改变了Bitmap像素数据的存放方式，我猜想和8.0中的GC算法调整有关系。GC算法的优化，使得Bitmap占用的大内存区域，在GC后也能够比较快速的回收、压缩，重新使用。</p>

<table>
<thead>
<tr>
<th>（native存放）</th>
<th>退出Activity</th>
<th>退出App</th>
</tr>
</thead>
<tbody>
<tr>
<td>onStop中主动调用gc()和recycler()</td>
<td>内存不释放</td>
<td>内存释放</td>
</tr>
<tr>
<td>无调用</td>
<td>内存不释放</td>
<td>内存不释放</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>（gpu存放）</th>
<th>退出Activity</th>
<th>退出App</th>
</tr>
</thead>
<tbody>
<tr>
<td>onStop中主动调用gc()和recycler()</td>
<td>内存释放</td>
<td>内存释放</td>
</tr>
<tr>
<td>无调用</td>
<td>内存释放</td>
<td>内存释放</td>
</tr>
</tbody>
</table><h1><a id="_287"></a>总结</h1>
<pre><code>// 8.0源码
    Bitmap(long nativeBitmap, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets)
// 7.0源码
Bitmap(long nativeBitmap, byte[] buffer, int width, int height, int density,
            boolean isMutable, boolean requestPremultiplied,
            byte[] ninePatchChunk, NinePatch.InsetStruct ninePatchInsets)

</code></pre>
<p>一开始看两者java代码不同，少了存放像素的buffer字段，查阅相关资料到native源码对比，最终总结了下Bitmap内存相关的知识。另外，在Android 8.0中，关于Bitmap的改动有两方面还需深入探究的：1、Config配置为Hardware时的优劣。Hardware配置实际上没有改变像素的位储存大小（还是默认的ARGB8888），但是改变了bitmap像素的存储位置（存放到GPU内存中），对实际应用的影响会如何？；2、Bitmap在8.0后又回归到native存放bitmap像素数据，而这部分数据的回收时机和触发方式又是如何？一般测试下，可以通过native分配Bitmap超过1G的内存数据而不发生崩溃。</p>
<p>作者：Dragon_Boat<br>
链接：https://www.jianshu.com/p/3f6f6e4f1c88<br>
来源：简书</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
