<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android 黑科技保活实现原理揭秘</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-16 17:16:43                    </span>
                    <span class="read-count">阅读数 21</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-16 17:16:43</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9584164.html">
                                       京东                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9605682.html">
                                       字节跳动                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104903490">https://blog.csdn.net/weixin_43901866/article/details/104903490</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>一直以来，App 进程保活都是各大厂商，特别是头部应用开发商永恒的追求。</p>
<p>毕竟App 进程死了，就什么也干不了了；一旦 App 进程死亡，那就再也无法在用户的手机上开展任何业务，所有的商业模型在用户侧都没有立足之地了。</p>
<p>早期的 Android 系统不完善，导致 App 侧有很多空子可以钻，因此它们有着有着各种各样的姿势进行保活。</p>
<p>譬如说在 Android 5.0 以前，App 内部通过 native 方式 fork 出来的进程是不受系统管控的，系统在杀 App 进程的时候，只会去杀 App 启动的 Java 进程。</p>
<p>因此诞生了一大批“毒瘤”，他们通过 fork native 进程，在 App 的 Java 进程被杀死的时候通过 am命令拉起自己从而实现永生。</p>
<p>那时候的 Android 可谓是魑魅横行，群魔乱舞；系统根本管不住应用，因此长期以来被人诟病耗电、卡顿。</p>
<p>同时，系统的软弱导致了 Xposed 框架、阻止运行、绿色守护、黑域、冰箱等一系列管制系统后台进程的框架和 App 出现。</p>
<p>不过，随着 Android 系统的发展，这一切都在往好的方向演变。</p>
<p>Android 5.0 以上，系统杀进程以 uid 为标识，通过杀死整个进程组来杀进程，因此 native 进程也躲不过系统的法眼。<br>
Android 6.0 引入了待机模式(doze)，一旦用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。<br>
Android 7.0 加强了之前鸡肋的待机模式（不再要求设备静止状态），同时对开启了 Project Svelte，Project Svelte 是专门用来优化 Android 系统后台的项目，在 Android 7.0 上直接移除了一些隐式广播，App 无法再通过监听这些广播拉起自己。<br>
Android 8.0 进一步加强了应用后台执行限制：一旦应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁。另外，系统会限制未在前台运行的应用的某些行为，比如说应用的后台服务的访问受到限制，也无法使用 Mainifest 注册大部分隐式广播。<br>
Android 9.0 进一步改进了省电模式的功能并加入了应用待机分组，长时间不用的 App 会被打入冷宫；另外，系统监测到应用消耗过多资源时，系统会通知并询问用户是否需要限制该应用的后台活动。</p>
<p>然而，道高一尺，魔高一丈。系统在不断演进，保活方法也在不断发展。大约在 4 年前出现过一个 MarsDaemon，这个库通过双进程守护的方式实现保活，一时间风头无两。</p>
<p>不过好景不长，进入 Android 8.0 时代之后，这个库就逐渐消亡。</p>
<p>一般来说，Android 进程保活分为两个方面：</p>
<p>保持进程不被系统杀死。<br>
进程被系统杀死之后，可以重新复活。</p>
<p>随着 Android 系统变得越来越完善，单单通过自己拉活自己逐渐变得不可能了；因此后面的所谓「保活」基本上是两条路：</p>
<p>提升自己进程的优先级，让系统不要轻易弄死自己；<br>
App 之间互相结盟，一个兄弟死了其他兄弟把它拉起来。</p>
<p>当然，还有一种终极方法，那就是跟各大系统厂商建立 PY 关系，把自己加入系统内存清理的白名单；比如说国民应用微信。当然这条路一般人是没有资格走的。</p>
<p>大约一年以前，大神 gityuan 在其博客上公布了 TIM 使用的一种可以称之为「终极永生术」的保活方法；这种方法在当前 Android 内核的实现上可以大大提升进程的存活率。笔者研究了这种保活思路的实现原理，并且提供了一个参考实现 Leoric。</p>
<p>接下来就给大家分享一下这个终极保活黑科技的实现原理。</p>
<h2><a id="1_42"></a>1保活的底层技术原理</h2>
<p>知己知彼，百战不殆。</p>
<p>既然我们想要保活，那么首先得知道我们是怎么死的。</p>
<p>一般来说，系统杀进程有两种方法，这两个方法都通过 ActivityManagerService 提供：</p>
<p>killBackgroundProcesses<br>
forceStopPackage</p>
<p>在原生系统上，很多时候杀进程是通过第一种方式，除非用户主动在 App 的设置界面点击「强制停止」。</p>
<p>不过国内各厂商以及一加三星等 ROM 现在一般使用第二种方法。</p>
<p>第一种方法太过温柔，根本治不住想要搞事情的应用。</p>
<p>第二种方法就比较强力了，一般来说被 force-stop 之后，App 就只能乖乖等死了。</p>
<p>因此，要实现保活，我们就得知道 force-stop 到底是如何运作的。既然如此，我们就跟踪一下系统的 forceStopPackage 这个方法的执行流程：</p>
<p>首先是 ActivityManagerService里面的 forceStopPackage 这方法：</p>
<pre><code>public void forceStopPackage(final String packageName, int userId) {
    // .. 权限检查，省略
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized(this) {
            int[] users = userId == UserHandle.USER_ALL
                    ? mUserController.getUsers() : new int[] { userId };
            for (int user : users) {
                // 状态判断，省略..
                int pkgUid = -1;
                try {
                    pkgUid = pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING,
                            user);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    Slog.w(TAG, "Invalid packageName: " + packageName);
                    continue;
                }
                try {
                    pm.setPackageStoppedState(packageName, true, user);
                } catch (RemoteException e) {
                } catch (IllegalArgumentException e) {
                    Slog.w(TAG, "Failed trying to unstop package "
                            + packageName + ": " + e);
                }
                if (mUserController.isUserRunning(user, 0)) {
                    // 根据 UID 和包名杀进程
                    forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                    finishForceStopPackageLocked(packageName, pkgUid);
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
</code></pre>
<p>在这里我们可以知道，系统是通过 uid 为单位 force-stop 进程的，因此不论你是 native 进程还是 Java 进程，force-stop 都会将你统统杀死。我们继续跟踪 forceStopPackageLocked 这个方法：</p>
<pre><code>final boolean forceStopPackageLocked(String packageName, int appId,
        boolean callerWillRestart, boolean purgeCache, boolean doit,
        boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    // .. 状态判断，省略
    boolean didSomething = mProcessList.killPackageProcessesLocked(packageName, appId, userId,
            ProcessList.INVALID_ADJ, callerWillRestart, true /* allowRestart */, doit,
            evenPersistent, true /* setRemoved */,
            packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    didSomething |=
            mAtmInternal.onForceStopPackage(packageName, doit, evenPersistent, userId);
    // 清理 service
    // 清理 broadcastreceiver
    // 清理 providers
    // 清理其他
    return didSomething;
}
</code></pre>
<p>这个方法实现很清晰：</p>
<p>先杀死这个 App 内部的所有进程，然后清理残留在 system_server 内的四大组件信息；我们关心进程是如何被杀死的，因此继续跟踪 killPackageProcessesLocked，这个方法最终会调用到 ProcessList 内部的 removeProcessLocked 方法， removeProcessLocked 会调用 ProcessRecord 的 kill 方法，我们看看这个 kill：</p>
<pre><code>void kill(String reason, boolean noisy) {
    if (!killedByAm) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "kill");
        if (mService != null &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) {
            mService.reportUidInfoMessageLocked(TAG,
                    "Killing " + toShortString() + " (adj " + setAdj + "): " + reason,
                    info.uid);
        }
        if (pid &gt; 0) {
            EventLog.writeEvent(EventLogTags.AM_KILL, userId, pid, processName, setAdj, reason);
            Process.killProcessQuiet(pid);
            ProcessList.killProcessGroup(uid, pid);
        } else {
            pendingStart = false;
        }
        if (!mPersistent) {
            killed = true;
            killedByAm = true;
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
}
</code></pre>
<p>这里我们可以看到，首先杀掉了目标进程，然后会以 uid为单位杀掉目标进程组。</p>
<p>如果只杀掉目标进程，那么我们可以通过双进程守护的方式实现保活；</p>
<p>关键就在于这个 killProcessGroup，继续跟踪之后发现这是一个 native 方法，它的最终实现在 libprocessgroup中，代码如下：</p>
<pre><code>int killProcessGroup(uid_t uid, int initialPid, int signal) {
    return KillProcessGroup(uid, initialPid, signal, 40 /*retries*/);
}

注意这里有个奇怪的数字：40。

我们继续跟踪：

static int KillProcessGroup(uid_t uid, int initialPid, int signal, int retries) {
    // 省略
    int retry = retries;
    int processes;
    while ((processes = DoKillProcessGroupOnce(cgroup, uid, initialPid, signal)) &gt; 0) {
        LOG(VERBOSE) &lt;&lt; "Killed " &lt;&lt; processes &lt;&lt; " processes for processgroup " &lt;&lt; initialPid;
        if (retry &gt; 0) {
            std::this_thread::sleep_for(5ms);
            --retry;
        } else {
            break;
        }
    }
    // 省略
}
</code></pre>
<p>瞧瞧我们的系统做了什么骚操作？循环 40 遍不停滴杀进程，每次杀完之后等 5ms，循环完毕之后就算过去了。</p>
<p>看到这段代码，我想任何人都会蹦出一个疑问：假设经历连续 40 次的杀进程之后，如果 App 还有进程存在，那不就侥幸逃脱了吗？</p>
<h2><a id="2__185"></a>2 实现方法</h2>
<p>那么，如何实现这个目的呢？</p>
<p>我们看这个关键的 5ms。假设，App 进程在被杀掉之后，能够以足够快的速度（5ms 内）启动一堆新的进程，那么系统在一次循环杀掉老的所有进程之后，sleep 5ms 之后又会遇到一堆新的进程；如此循环 40 次，只要我们每次都能够拉起新的进程，那我们的 App 就能逃过系统的追杀，实现永生。</p>
<p>是的，炼狱般的 200ms，只要我们熬过 200ms 就能渡劫成功，得道飞升。</p>
<p>不知道大家有没有玩过打地鼠这个游戏，整个过程非常类似，按下去一个又冒出一个，只要每次都能足够快地冒出来，我们就赢了。</p>
<p>现在问题的关键就在于：</p>
<p>如何在 5ms 内启动一堆新的进程？</p>
<p>再回过头来看原来的保活方式，它们拉起进程最开始通过 am命令，这个命令实际上是一个 java 程序，它会经历启动一个进程然后启动一个 ART 虚拟机，接着获取 ams 的 binder 代理，然后与 ams 进行 binder 同步通信。</p>
<p>这个过程实在是太慢了，在这与死神赛跑的 5ms 里，它的速度的确是不敢恭维。</p>
<p>后来，MarsDaemon 提出了一种新的方式，它用 binder 引用直接给 ams 发送 Parcel，这个过程相比 am命令快了很多，从而大大提高了成功率。其实这里还有改进的空间，毕竟这里还是在 Java 层调用，Java 语言在这种实时性要求极高的场合有一个非常令人诟病的特性：</p>
<p>垃圾回收（GC）；虽然我们在这 5ms 内直接碰上 gc 引发停顿的可能性非常小，但是由于 GC 的存在，ART 中的 Java 代码存在非常多的 checkpoint；</p>
<p>想象一下你现在是一个信使有重要军情要报告，但是在路上却碰到很多关隘，而且很可能被勒令暂时停止一下，这种情况是不可接受的。因此，最好的方法是通过 native code 给 ams 发送 binder 调用；</p>
<p>当然，如果再底层一点，我们甚至可以通过 ioctl 直接给 binder 驱动发送数据进而完成调用，但是这种方法的兼容性比较差，没有用 native 方式省心。</p>
<p>通过在 native 层给 ams 发送 binder 消息拉起进程，我们算是解决了「快速拉起进程」这个问题。但是这个还是不够。还是回到打地鼠这个游戏，假设你摁下一个地鼠，会冒起一个新的地鼠，那么你每次都能摁下去最后获取胜利的概率还是比较高的；</p>
<p>但如果你每次摁下一个地鼠，其他所有地鼠都能冒出来呢？这个难度系数可是要高多了。如果我们的进程能够在任意一个进程死亡之后，都能让把其他所有进程全部拉起，这样系统就很难杀死我们了。</p>
<p>新的黑科技保活中通过 2 个机制来保证进程之间的互相拉起：</p>
<p>2 个进程通过互相监听文件锁的方式，来感知彼此的死亡。<br>
通过 fork 产生子进程，fork 的进程同属一个进程组，一个被杀之后会触发另外一个进程被杀，从而被文件锁感知。</p>
<p>具体来说，创建 2 个进程 p1, p2，这两个进程通过文件锁互相关联，一个被杀之后拉起另外一个；同时 p1 经过 2 次 fork 产生孤儿进程 c1，p2 经过 2 次 fork 产生孤儿进程 c2，c1 和 c2 之间建立文件锁关联。这样假设 p1 被杀，那么 p2 会立马感知到，然后 p1 和 c1 同属一个进程组，p1 被杀会触发 c1 被杀，c1 死后 c2 立马感受到从而拉起 p1，因此这四个进程三三之间形成了铁三角，从而保证了存活率。</p>
<p>分析到这里，这种方案的大致原理我们已经清晰了。</p>
<p>基于以上原理，我写了一个简单的 PoC，代码在这里：<br>
https://github.com/tiann/Leoric</p>
<p>有兴趣的可以看一下。</p>
<p>为了文章的严谨性（注一位读者Rikka的回复）：</p>
<p>文章中说需要“在 5ms 内启动一堆新的进程”，但其实并不需要。</p>
<p>AMS 在执行杀进程时是一个 ProcessRecord 一个地来的（ https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java#5766），也就是最终会执行多次 libprocessgroup 里的 killProcessgroup。</p>
<p>这样只要在杀死属于某个 cgroup 的进程时，另外的进程只要成功启动一次 android:process 是另外的的进程即可活下来。因为新对应新的 ProcessRecord，不会在上面那个循环里被杀死。此外，循环四十次反而给了超长的时间来启动新的，观察 log 可以发现 killProcessgroup 的间隔长达几十到一百多 ms。</p>
<h2><a id="3__237"></a>3 改进空间</h2>
<p>本方案的原理还是比较简单直观的，但是要实现稳定的保活，还需要很多细节要补充；特别是那与死神赛跑的 5ms，需要不计一切代价去优化才能提升成功率。</p>
<p>具体来说，就是当前的实现是在 Java 层用 binder 调用的，我们应该在 native 层完成。笔者曾经实现过这个方案，但是这个库本质上是有损用户利益的，因此并不打算公开代码，这里简单提一下实现思路供大家学习：</p>
<p>如何在 native 层进行 binder 通信？</p>
<p>libbinder 是 NDK 公开库，拿到对应头文件，动态链接即可。</p>
<p>难点：依赖繁多，剥离头文件是个体力活。</p>
<p>如何组织 binder 通信的数据？</p>
<p>通信的数据其实就是二进制流；具体表现就是 (C++/Java) Parcel 对象。native 层没有对应的 Intent Parcel，兼容性差。</p>
<p><strong>方案：</strong></p>
<p>Java 层创建 Parcel （含 Intent），拿到 Parcel 对象的 mNativePtr(native peer)，传到 Native 层。<br>
native 层直接把 mNativePtr 强转为结构体指针。<br>
fork 子进程，建立管道，准备传输 parcel 数据。<br>
子进程读管道，拿到二进制流，重组为 parcel。</p>
<h2><a id="4__260"></a>4 如何应对？</h2>
<p>今天我把这个实现原理公开，并且提供 PoC 代码，并不是鼓励大家使用这种方式保活，而是希望各大系统厂商能感知到这种黑科技的存在，推动自己的系统彻底解决这个问题。</p>
<p>两年前我就知道了这个方案的存在，不过当时鲜为人知。</p>
<p>最近一个月我发现很多 App 都使用了这种方案，把我的 Android 手机折腾的惨不忍睹；毕竟本人手机上安装了将近 800 个 App，假设每个 App 都用这个方案保活，那这系统就没法用了。</p>
<p>系统如何应对？</p>
<p>如果我们把系统杀进程比喻为斩首，那么这个保活方案的精髓在于能快速长出一个新的头；因此应对之法也很简单，只要我们在斩杀一个进程的时候，让别的进程老老实实呆着别搞事情就 OK 了。具体的实现方法多种多样，不赘述。</p>
<p>用户如何应对？</p>
<p>在厂商没有推出解决方案之前，用户可以有一些方案来缓解使用这个方案进行保活的流氓 App。</p>
<p>这里推荐两个应用给大家：</p>
<p>冰箱<br>
Island</p>
<p>通过冰箱的冻结和 Island 的深度休眠可以彻底阻止 App 的这种保活行为。当然，如果你喜欢别的这种“冻结”类型的应用，比如小黑屋或者太极的阴阳之门也是可以的。</p>
<p>其他不是通过“冻结”这种机制来压制后台的应用理论上对这种保活方案的作用非常有限。</p>
<h2><a id="_285"></a>总结</h2>
<ol>
<li>
<p>对技术来说，黑科技没有什么黑的，不过是对系统底层原理的深入了解从而反过来对抗系统的一种手段。很多人会说，了解系统底层有什么用，本文应该可以给出一个答案：可以实现别人永远也无法实现的功能，通过技术推动产品，从而产生巨大的商业价值。</p>
</li>
<li>
<p>黑科技虽强，但是它不该存在于这世上。没有规矩，不成方圆。黑科技黑的了一时，黑不了一世。要提升产品的存活率，终归要落到产品本身上面来，尊重用户，提升体验方是正途。</p>
</li>
</ol>
<h2><a id="_291"></a>结尾</h2>
<p>最后小编想说：不论以后选择什么方向发展，目前重要的是把Android方面的技术学好，毕竟其实对于程序员来说，要学习的知识内容、技术有太多太多，要想不被环境淘汰就只有不断提升自己，<strong>从来都是我们去适应环境，而不是环境来适应我们！</strong></p>
<p>当程序员容易，当一个优秀的程序员是需要不断学习的，从初级程序员到高级程序员，从初级架构师到资深架构师，或者走向管理，从技术经理到技术总监，每个阶段都需要掌握不同的能力。早早确定自己的职业方向，才能在工作和能力提升中甩开同龄人。</p>
<p>想要拿高薪实现技术提升薪水得到质的飞跃。最快捷的方式，就是有人可以带着你一起分析，这样学习起来最为高效，所以为了大家能够顺利进阶中高级、架构师，我特地为大家准备了<strong>一套高手学习的源码和框架视频等精品Android架构师教程</strong>，保证你学了以后保证薪资上升一个台阶。（以下是一小部分，获取更多其他精讲进阶架构视频资料可以关注【我的主页】或者【简信我】获取免费领取方式）</p>
<p><strong>当你有了学习线路，学习哪些内容，也知道以后的路怎么走了，理论看多了总要实践的。</strong></p>
<p>以下是今天给大家分享的一些独家干货：</p>
<p>[Android学习PDF+架构视频+面试文档+源码笔记]</p>
<p><strong>【Android开发核心知识点笔记】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDk1OTAwLTZmOTkyYjEyMDZiMzM5MjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjQwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android思维脑图（技能树）】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03YTgzNGM2NzMxNjJjNGYzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android核心高级技术PDF文档，BAT大厂面试真题解析】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDk1OTAwLTFiNzAxNDQ2YzE0MjgwYzUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzg4L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android高级架构视频学习资源】</strong></p>
<p>**Android精讲视频领取学习后更加是如虎添翼！**进军BATJ大厂等（备战）！现在都说互联网寒冬，其实无非就是你上错了车，且穿的少（技能），要是你上对车，自身技术能力够强，公司换掉的代价大，怎么可能会被裁掉，都是淘汰末端的业务Curd而已！现如今市场上初级程序员泛滥，这套教程针对Android开发工程师1-6年的人员、正处于瓶颈期，想要年后突破自己涨薪的，进阶Android中高级、架构师对你更是如鱼得水，赶快领取吧！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0wZThhNjYwOGUzMjk5M2M3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1jYzRhMzJiNjc2N2I3MDE4LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android进阶学习视频】、【全套Android面试秘籍】【私信我学习】查看免费领取方式！</strong><br>
分享不易！喜欢的朋友别忘了关注+点赞！<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1lM2QyNzViYzVkNWEzZTk4LmpwZw?x-oss-process=image/format,png" alt=""></p>
<p>原文作者：鸿洋<br>
原文链接：https://mp.weixin.qq.com/s/bkHP-BiwTeQhqKvze2jtdQ</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">Android 黑科技保活实现原理揭秘</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-16 17:16:43                    </span>
                    <span class="read-count">阅读数 21</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-16 17:16:43</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9584164.html">
                                       京东                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9605682.html">
                                       字节跳动                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104903490">https://blog.csdn.net/weixin_43901866/article/details/104903490</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>一直以来，App 进程保活都是各大厂商，特别是头部应用开发商永恒的追求。</p>
<p>毕竟App 进程死了，就什么也干不了了；一旦 App 进程死亡，那就再也无法在用户的手机上开展任何业务，所有的商业模型在用户侧都没有立足之地了。</p>
<p>早期的 Android 系统不完善，导致 App 侧有很多空子可以钻，因此它们有着有着各种各样的姿势进行保活。</p>
<p>譬如说在 Android 5.0 以前，App 内部通过 native 方式 fork 出来的进程是不受系统管控的，系统在杀 App 进程的时候，只会去杀 App 启动的 Java 进程。</p>
<p>因此诞生了一大批“毒瘤”，他们通过 fork native 进程，在 App 的 Java 进程被杀死的时候通过 am命令拉起自己从而实现永生。</p>
<p>那时候的 Android 可谓是魑魅横行，群魔乱舞；系统根本管不住应用，因此长期以来被人诟病耗电、卡顿。</p>
<p>同时，系统的软弱导致了 Xposed 框架、阻止运行、绿色守护、黑域、冰箱等一系列管制系统后台进程的框架和 App 出现。</p>
<p>不过，随着 Android 系统的发展，这一切都在往好的方向演变。</p>
<p>Android 5.0 以上，系统杀进程以 uid 为标识，通过杀死整个进程组来杀进程，因此 native 进程也躲不过系统的法眼。<br>
Android 6.0 引入了待机模式(doze)，一旦用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。<br>
Android 7.0 加强了之前鸡肋的待机模式（不再要求设备静止状态），同时对开启了 Project Svelte，Project Svelte 是专门用来优化 Android 系统后台的项目，在 Android 7.0 上直接移除了一些隐式广播，App 无法再通过监听这些广播拉起自己。<br>
Android 8.0 进一步加强了应用后台执行限制：一旦应用进入已缓存状态时，如果没有活动的组件，系统将解除应用具有的所有唤醒锁。另外，系统会限制未在前台运行的应用的某些行为，比如说应用的后台服务的访问受到限制，也无法使用 Mainifest 注册大部分隐式广播。<br>
Android 9.0 进一步改进了省电模式的功能并加入了应用待机分组，长时间不用的 App 会被打入冷宫；另外，系统监测到应用消耗过多资源时，系统会通知并询问用户是否需要限制该应用的后台活动。</p>
<p>然而，道高一尺，魔高一丈。系统在不断演进，保活方法也在不断发展。大约在 4 年前出现过一个 MarsDaemon，这个库通过双进程守护的方式实现保活，一时间风头无两。</p>
<p>不过好景不长，进入 Android 8.0 时代之后，这个库就逐渐消亡。</p>
<p>一般来说，Android 进程保活分为两个方面：</p>
<p>保持进程不被系统杀死。<br>
进程被系统杀死之后，可以重新复活。</p>
<p>随着 Android 系统变得越来越完善，单单通过自己拉活自己逐渐变得不可能了；因此后面的所谓「保活」基本上是两条路：</p>
<p>提升自己进程的优先级，让系统不要轻易弄死自己；<br>
App 之间互相结盟，一个兄弟死了其他兄弟把它拉起来。</p>
<p>当然，还有一种终极方法，那就是跟各大系统厂商建立 PY 关系，把自己加入系统内存清理的白名单；比如说国民应用微信。当然这条路一般人是没有资格走的。</p>
<p>大约一年以前，大神 gityuan 在其博客上公布了 TIM 使用的一种可以称之为「终极永生术」的保活方法；这种方法在当前 Android 内核的实现上可以大大提升进程的存活率。笔者研究了这种保活思路的实现原理，并且提供了一个参考实现 Leoric。</p>
<p>接下来就给大家分享一下这个终极保活黑科技的实现原理。</p>
<h2><a id="1_42"></a>1保活的底层技术原理</h2>
<p>知己知彼，百战不殆。</p>
<p>既然我们想要保活，那么首先得知道我们是怎么死的。</p>
<p>一般来说，系统杀进程有两种方法，这两个方法都通过 ActivityManagerService 提供：</p>
<p>killBackgroundProcesses<br>
forceStopPackage</p>
<p>在原生系统上，很多时候杀进程是通过第一种方式，除非用户主动在 App 的设置界面点击「强制停止」。</p>
<p>不过国内各厂商以及一加三星等 ROM 现在一般使用第二种方法。</p>
<p>第一种方法太过温柔，根本治不住想要搞事情的应用。</p>
<p>第二种方法就比较强力了，一般来说被 force-stop 之后，App 就只能乖乖等死了。</p>
<p>因此，要实现保活，我们就得知道 force-stop 到底是如何运作的。既然如此，我们就跟踪一下系统的 forceStopPackage 这个方法的执行流程：</p>
<p>首先是 ActivityManagerService里面的 forceStopPackage 这方法：</p>
<pre><code>public void forceStopPackage(final String packageName, int userId) {
    // .. 权限检查，省略
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized(this) {
            int[] users = userId == UserHandle.USER_ALL
                    ? mUserController.getUsers() : new int[] { userId };
            for (int user : users) {
                // 状态判断，省略..
                int pkgUid = -1;
                try {
                    pkgUid = pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING,
                            user);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    Slog.w(TAG, "Invalid packageName: " + packageName);
                    continue;
                }
                try {
                    pm.setPackageStoppedState(packageName, true, user);
                } catch (RemoteException e) {
                } catch (IllegalArgumentException e) {
                    Slog.w(TAG, "Failed trying to unstop package "
                            + packageName + ": " + e);
                }
                if (mUserController.isUserRunning(user, 0)) {
                    // 根据 UID 和包名杀进程
                    forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                    finishForceStopPackageLocked(packageName, pkgUid);
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
</code></pre>
<p>在这里我们可以知道，系统是通过 uid 为单位 force-stop 进程的，因此不论你是 native 进程还是 Java 进程，force-stop 都会将你统统杀死。我们继续跟踪 forceStopPackageLocked 这个方法：</p>
<pre><code>final boolean forceStopPackageLocked(String packageName, int appId,
        boolean callerWillRestart, boolean purgeCache, boolean doit,
        boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    // .. 状态判断，省略
    boolean didSomething = mProcessList.killPackageProcessesLocked(packageName, appId, userId,
            ProcessList.INVALID_ADJ, callerWillRestart, true /* allowRestart */, doit,
            evenPersistent, true /* setRemoved */,
            packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    didSomething |=
            mAtmInternal.onForceStopPackage(packageName, doit, evenPersistent, userId);
    // 清理 service
    // 清理 broadcastreceiver
    // 清理 providers
    // 清理其他
    return didSomething;
}
</code></pre>
<p>这个方法实现很清晰：</p>
<p>先杀死这个 App 内部的所有进程，然后清理残留在 system_server 内的四大组件信息；我们关心进程是如何被杀死的，因此继续跟踪 killPackageProcessesLocked，这个方法最终会调用到 ProcessList 内部的 removeProcessLocked 方法， removeProcessLocked 会调用 ProcessRecord 的 kill 方法，我们看看这个 kill：</p>
<pre><code>void kill(String reason, boolean noisy) {
    if (!killedByAm) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "kill");
        if (mService != null &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) {
            mService.reportUidInfoMessageLocked(TAG,
                    "Killing " + toShortString() + " (adj " + setAdj + "): " + reason,
                    info.uid);
        }
        if (pid &gt; 0) {
            EventLog.writeEvent(EventLogTags.AM_KILL, userId, pid, processName, setAdj, reason);
            Process.killProcessQuiet(pid);
            ProcessList.killProcessGroup(uid, pid);
        } else {
            pendingStart = false;
        }
        if (!mPersistent) {
            killed = true;
            killedByAm = true;
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
}
</code></pre>
<p>这里我们可以看到，首先杀掉了目标进程，然后会以 uid为单位杀掉目标进程组。</p>
<p>如果只杀掉目标进程，那么我们可以通过双进程守护的方式实现保活；</p>
<p>关键就在于这个 killProcessGroup，继续跟踪之后发现这是一个 native 方法，它的最终实现在 libprocessgroup中，代码如下：</p>
<pre><code>int killProcessGroup(uid_t uid, int initialPid, int signal) {
    return KillProcessGroup(uid, initialPid, signal, 40 /*retries*/);
}

注意这里有个奇怪的数字：40。

我们继续跟踪：

static int KillProcessGroup(uid_t uid, int initialPid, int signal, int retries) {
    // 省略
    int retry = retries;
    int processes;
    while ((processes = DoKillProcessGroupOnce(cgroup, uid, initialPid, signal)) &gt; 0) {
        LOG(VERBOSE) &lt;&lt; "Killed " &lt;&lt; processes &lt;&lt; " processes for processgroup " &lt;&lt; initialPid;
        if (retry &gt; 0) {
            std::this_thread::sleep_for(5ms);
            --retry;
        } else {
            break;
        }
    }
    // 省略
}
</code></pre>
<p>瞧瞧我们的系统做了什么骚操作？循环 40 遍不停滴杀进程，每次杀完之后等 5ms，循环完毕之后就算过去了。</p>
<p>看到这段代码，我想任何人都会蹦出一个疑问：假设经历连续 40 次的杀进程之后，如果 App 还有进程存在，那不就侥幸逃脱了吗？</p>
<h2><a id="2__185"></a>2 实现方法</h2>
<p>那么，如何实现这个目的呢？</p>
<p>我们看这个关键的 5ms。假设，App 进程在被杀掉之后，能够以足够快的速度（5ms 内）启动一堆新的进程，那么系统在一次循环杀掉老的所有进程之后，sleep 5ms 之后又会遇到一堆新的进程；如此循环 40 次，只要我们每次都能够拉起新的进程，那我们的 App 就能逃过系统的追杀，实现永生。</p>
<p>是的，炼狱般的 200ms，只要我们熬过 200ms 就能渡劫成功，得道飞升。</p>
<p>不知道大家有没有玩过打地鼠这个游戏，整个过程非常类似，按下去一个又冒出一个，只要每次都能足够快地冒出来，我们就赢了。</p>
<p>现在问题的关键就在于：</p>
<p>如何在 5ms 内启动一堆新的进程？</p>
<p>再回过头来看原来的保活方式，它们拉起进程最开始通过 am命令，这个命令实际上是一个 java 程序，它会经历启动一个进程然后启动一个 ART 虚拟机，接着获取 ams 的 binder 代理，然后与 ams 进行 binder 同步通信。</p>
<p>这个过程实在是太慢了，在这与死神赛跑的 5ms 里，它的速度的确是不敢恭维。</p>
<p>后来，MarsDaemon 提出了一种新的方式，它用 binder 引用直接给 ams 发送 Parcel，这个过程相比 am命令快了很多，从而大大提高了成功率。其实这里还有改进的空间，毕竟这里还是在 Java 层调用，Java 语言在这种实时性要求极高的场合有一个非常令人诟病的特性：</p>
<p>垃圾回收（GC）；虽然我们在这 5ms 内直接碰上 gc 引发停顿的可能性非常小，但是由于 GC 的存在，ART 中的 Java 代码存在非常多的 checkpoint；</p>
<p>想象一下你现在是一个信使有重要军情要报告，但是在路上却碰到很多关隘，而且很可能被勒令暂时停止一下，这种情况是不可接受的。因此，最好的方法是通过 native code 给 ams 发送 binder 调用；</p>
<p>当然，如果再底层一点，我们甚至可以通过 ioctl 直接给 binder 驱动发送数据进而完成调用，但是这种方法的兼容性比较差，没有用 native 方式省心。</p>
<p>通过在 native 层给 ams 发送 binder 消息拉起进程，我们算是解决了「快速拉起进程」这个问题。但是这个还是不够。还是回到打地鼠这个游戏，假设你摁下一个地鼠，会冒起一个新的地鼠，那么你每次都能摁下去最后获取胜利的概率还是比较高的；</p>
<p>但如果你每次摁下一个地鼠，其他所有地鼠都能冒出来呢？这个难度系数可是要高多了。如果我们的进程能够在任意一个进程死亡之后，都能让把其他所有进程全部拉起，这样系统就很难杀死我们了。</p>
<p>新的黑科技保活中通过 2 个机制来保证进程之间的互相拉起：</p>
<p>2 个进程通过互相监听文件锁的方式，来感知彼此的死亡。<br>
通过 fork 产生子进程，fork 的进程同属一个进程组，一个被杀之后会触发另外一个进程被杀，从而被文件锁感知。</p>
<p>具体来说，创建 2 个进程 p1, p2，这两个进程通过文件锁互相关联，一个被杀之后拉起另外一个；同时 p1 经过 2 次 fork 产生孤儿进程 c1，p2 经过 2 次 fork 产生孤儿进程 c2，c1 和 c2 之间建立文件锁关联。这样假设 p1 被杀，那么 p2 会立马感知到，然后 p1 和 c1 同属一个进程组，p1 被杀会触发 c1 被杀，c1 死后 c2 立马感受到从而拉起 p1，因此这四个进程三三之间形成了铁三角，从而保证了存活率。</p>
<p>分析到这里，这种方案的大致原理我们已经清晰了。</p>
<p>基于以上原理，我写了一个简单的 PoC，代码在这里：<br>
https://github.com/tiann/Leoric</p>
<p>有兴趣的可以看一下。</p>
<p>为了文章的严谨性（注一位读者Rikka的回复）：</p>
<p>文章中说需要“在 5ms 内启动一堆新的进程”，但其实并不需要。</p>
<p>AMS 在执行杀进程时是一个 ProcessRecord 一个地来的（ https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java#5766），也就是最终会执行多次 libprocessgroup 里的 killProcessgroup。</p>
<p>这样只要在杀死属于某个 cgroup 的进程时，另外的进程只要成功启动一次 android:process 是另外的的进程即可活下来。因为新对应新的 ProcessRecord，不会在上面那个循环里被杀死。此外，循环四十次反而给了超长的时间来启动新的，观察 log 可以发现 killProcessgroup 的间隔长达几十到一百多 ms。</p>
<h2><a id="3__237"></a>3 改进空间</h2>
<p>本方案的原理还是比较简单直观的，但是要实现稳定的保活，还需要很多细节要补充；特别是那与死神赛跑的 5ms，需要不计一切代价去优化才能提升成功率。</p>
<p>具体来说，就是当前的实现是在 Java 层用 binder 调用的，我们应该在 native 层完成。笔者曾经实现过这个方案，但是这个库本质上是有损用户利益的，因此并不打算公开代码，这里简单提一下实现思路供大家学习：</p>
<p>如何在 native 层进行 binder 通信？</p>
<p>libbinder 是 NDK 公开库，拿到对应头文件，动态链接即可。</p>
<p>难点：依赖繁多，剥离头文件是个体力活。</p>
<p>如何组织 binder 通信的数据？</p>
<p>通信的数据其实就是二进制流；具体表现就是 (C++/Java) Parcel 对象。native 层没有对应的 Intent Parcel，兼容性差。</p>
<p><strong>方案：</strong></p>
<p>Java 层创建 Parcel （含 Intent），拿到 Parcel 对象的 mNativePtr(native peer)，传到 Native 层。<br>
native 层直接把 mNativePtr 强转为结构体指针。<br>
fork 子进程，建立管道，准备传输 parcel 数据。<br>
子进程读管道，拿到二进制流，重组为 parcel。</p>
<h2><a id="4__260"></a>4 如何应对？</h2>
<p>今天我把这个实现原理公开，并且提供 PoC 代码，并不是鼓励大家使用这种方式保活，而是希望各大系统厂商能感知到这种黑科技的存在，推动自己的系统彻底解决这个问题。</p>
<p>两年前我就知道了这个方案的存在，不过当时鲜为人知。</p>
<p>最近一个月我发现很多 App 都使用了这种方案，把我的 Android 手机折腾的惨不忍睹；毕竟本人手机上安装了将近 800 个 App，假设每个 App 都用这个方案保活，那这系统就没法用了。</p>
<p>系统如何应对？</p>
<p>如果我们把系统杀进程比喻为斩首，那么这个保活方案的精髓在于能快速长出一个新的头；因此应对之法也很简单，只要我们在斩杀一个进程的时候，让别的进程老老实实呆着别搞事情就 OK 了。具体的实现方法多种多样，不赘述。</p>
<p>用户如何应对？</p>
<p>在厂商没有推出解决方案之前，用户可以有一些方案来缓解使用这个方案进行保活的流氓 App。</p>
<p>这里推荐两个应用给大家：</p>
<p>冰箱<br>
Island</p>
<p>通过冰箱的冻结和 Island 的深度休眠可以彻底阻止 App 的这种保活行为。当然，如果你喜欢别的这种“冻结”类型的应用，比如小黑屋或者太极的阴阳之门也是可以的。</p>
<p>其他不是通过“冻结”这种机制来压制后台的应用理论上对这种保活方案的作用非常有限。</p>
<h2><a id="_285"></a>总结</h2>
<ol>
<li>
<p>对技术来说，黑科技没有什么黑的，不过是对系统底层原理的深入了解从而反过来对抗系统的一种手段。很多人会说，了解系统底层有什么用，本文应该可以给出一个答案：可以实现别人永远也无法实现的功能，通过技术推动产品，从而产生巨大的商业价值。</p>
</li>
<li>
<p>黑科技虽强，但是它不该存在于这世上。没有规矩，不成方圆。黑科技黑的了一时，黑不了一世。要提升产品的存活率，终归要落到产品本身上面来，尊重用户，提升体验方是正途。</p>
</li>
</ol>
<h2><a id="_291"></a>结尾</h2>
<p>最后小编想说：不论以后选择什么方向发展，目前重要的是把Android方面的技术学好，毕竟其实对于程序员来说，要学习的知识内容、技术有太多太多，要想不被环境淘汰就只有不断提升自己，<strong>从来都是我们去适应环境，而不是环境来适应我们！</strong></p>
<p>当程序员容易，当一个优秀的程序员是需要不断学习的，从初级程序员到高级程序员，从初级架构师到资深架构师，或者走向管理，从技术经理到技术总监，每个阶段都需要掌握不同的能力。早早确定自己的职业方向，才能在工作和能力提升中甩开同龄人。</p>
<p>想要拿高薪实现技术提升薪水得到质的飞跃。最快捷的方式，就是有人可以带着你一起分析，这样学习起来最为高效，所以为了大家能够顺利进阶中高级、架构师，我特地为大家准备了<strong>一套高手学习的源码和框架视频等精品Android架构师教程</strong>，保证你学了以后保证薪资上升一个台阶。（以下是一小部分，获取更多其他精讲进阶架构视频资料可以关注【我的主页】或者【简信我】获取免费领取方式）</p>
<p><strong>当你有了学习线路，学习哪些内容，也知道以后的路怎么走了，理论看多了总要实践的。</strong></p>
<p>以下是今天给大家分享的一些独家干货：</p>
<p>[Android学习PDF+架构视频+面试文档+源码笔记]</p>
<p><strong>【Android开发核心知识点笔记】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDk1OTAwLTZmOTkyYjEyMDZiMzM5MjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjQwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android思维脑图（技能树）】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy03YTgzNGM2NzMxNjJjNGYzLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android核心高级技术PDF文档，BAT大厂面试真题解析】</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDk1OTAwLTFiNzAxNDQ2YzE0MjgwYzUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNzg4L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android高级架构视频学习资源】</strong></p>
<p>**Android精讲视频领取学习后更加是如虎添翼！**进军BATJ大厂等（备战）！现在都说互联网寒冬，其实无非就是你上错了车，且穿的少（技能），要是你上对车，自身技术能力够强，公司换掉的代价大，怎么可能会被裁掉，都是淘汰末端的业务Curd而已！现如今市场上初级程序员泛滥，这套教程针对Android开发工程师1-6年的人员、正处于瓶颈期，想要年后突破自己涨薪的，进阶Android中高级、架构师对你更是如鱼得水，赶快领取吧！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0wZThhNjYwOGUzMjk5M2M3LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1jYzRhMzJiNjc2N2I3MDE4LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><strong>【Android进阶学习视频】、【全套Android面试秘籍】【私信我学习】查看免费领取方式！</strong><br>
分享不易！喜欢的朋友别忘了关注+点赞！<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy1lM2QyNzViYzVkNWEzZTk4LmpwZw?x-oss-process=image/format,png" alt=""></p>
<p>原文作者：鸿洋<br>
原文链接：https://mp.weixin.qq.com/s/bkHP-BiwTeQhqKvze2jtdQ</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
