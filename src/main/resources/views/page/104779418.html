<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">面试官：“会不会熟练使用Jetpack”  我：“......”</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-10 17:49:46                    </span>
                    <span class="read-count">阅读数 28</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-10 17:49:46</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9787385.html">
                                       framework                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104779418">https://blog.csdn.net/weixin_43901866/article/details/104779418</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a id="_0"></a>面向标准化开发已成现实</h2>
<p>金三银四，相信有不少读者在抓紧机会面试。</p>
<p>Android 市场已今非昔比。在过去，迫于招人的压力，应试者只需了解四大组件、视图、网络请求，即可谋得一份满意的工作。</p>
<p>现如今，Jetpack 架构组件 及 标准化开发模式 的确立，意味着 Android 开发已步入成熟阶段：</p>
<blockquote>
<p>许多 样板代码 不再需要开发者手写，而是可以通过模版工具 自动生成，在取缔繁杂耗时的重复工作的同时，<strong>避免因人工操作的疏忽，而造成难以排查、不可预期的错误</strong>。</p>
</blockquote>
<p>这十分符合企业的利益，因而面试官在招人的时候，也更加看重应试者对 架构组件 —— 至少是 MVVM 的理解程度。🧐</p>
<p>像“解耦”等 含糊其辞的说法，已经不能够被面试官所认可，稍微对 MVVM 有一点经验的面试官都会请你举例说明，好证明你确实对 MVVM 有着正确、深入的理解，能够自然而然地写出标准化、规范化的代码，能够迅速适应 各家公司自制的 自动化模版工具。</p>
<h2><a id="_14"></a>本文的目标</h2>
<p>本人拥有 3 年的 移动端架构 践行和设计经验，领导团队重构的中大型项目多达十数个，对 Jetpack MVVM 架构在确立规范化、标准化 开发模式 以减少不可预期的错误 所作的努力，有着深入的理解。</p>
<p>因而本文的目标，就是结合前几期我们分别 深入浅出 介绍过的 Lifecycle、LiveData、ViewModel、DataBinding，来融汇贯通地演绎一下：</p>
<p><strong>作为 应用开发骨架 的 标准化状态管理框架</strong>，究竟为 快速开发过程中 减少不可预期的错误 做了哪些努力。</p>
<p>不同于 东拼西凑、人云亦云、徒添困扰 的网文，愿意将 标准化开发模式的 <strong>深度思考知识</strong> 和 <strong>实战反思经验</strong> 无保留地分享，全网仅此一家。<strong>这样的文章可以说是 看一篇、少一篇</strong>，因此，就算不去 hold 住面试官，也请务必跟随本文的脚步，无障碍地将 Jetpack MVVM 过一遍！😉</p>
<h2><a id="_24"></a>文章目录一览</h2>
<ul>
<li>前言</li>
<li>面向标准化开发已成现实</li>
<li>本文的目标</li>
<li>Jetpack Lifecycle
<ul>
<li>Lifecycle 存在前的混沌世界</li>
<li>Lifecycle 为什么能解决上述这些问题？</li>
</ul>
</li>
<li>Jetpack LiveData
<ul>
<li>LiveData 存在前的混沌世界</li>
<li>LiveData 为什么能解决上述这些问题？</li>
<li><strong>LiveData 有个坑需要注意</strong></li>
</ul>
</li>
<li>Jetpack ViewModel
<ul>
<li>ViewModel 存在前的混沌世界</li>
<li>ViewModel 为什么能做到这几点？</li>
</ul>
</li>
<li>Jetpack DataBinding
<ul>
<li>DataBinding 存在前的混沌世界</li>
<li>DataBinding 就是来解决这些问题</li>
</ul>
</li>
<li>综上</li>
</ul>
<h2><a id="Jetpack_Lifecycle_44"></a>Jetpack Lifecycle</h2>
<blockquote>
<p><strong>Lifecycle 的存在，主要是为了解决 生命周期管理 的一致性问题</strong></p>
</blockquote>
<h3><a id="Lifecycle__48"></a>Lifecycle 存在前的混沌世界</h3>
<p>在 Lifecycle 面市前，生命周期管理 纯靠手工维持，这样就容易滋生大量的一致性问题。</p>
<p>例如跨页面共享的 GpsManager 组件，在每个依赖它的 Activity 的 onResume 和 onPause 中都需要 <strong>手工 激活、解绑 和 叫停</strong>。</p>
<p>那么 <strong>随着 Activity 的增多，这种手工操作 埋下的一致性隐患 就会指数级增长</strong>：</p>
<blockquote>
<p>一方面，凡是手工维持的，开发者容易疏忽，特别是工作交接给其他同事时，同事并不能及时注意到这些细节。</p>
</blockquote>
<blockquote>
<p>另一方面，分散的代码不利于修改，日后除了激活、叫停，若有其他操作需要补充（例如状态监听），那么每个 Activity 都需要额外书写一遍。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy01MDc1ODQzYTYzNWQyNjJlLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="Lifecycle__62"></a>Lifecycle 为什么能解决上述这些问题？</h3>
<p>Lifecycle 通过 模板方法模式 和 观察者模式，将生命周期管理的复杂操作，全部在作为 LifecycleOwner 的基类中（例如视图控制器的基类）封装好，默默地在背后为开发者运筹帷幄，</p>
<p>开发者因而得以在视图控制器（子类）中只需一句 <code>getLifecycle().addObserver(GpsManager.getInstance)</code> ，优雅地完成 第三方组件在自己内部 对 LifecycleOwner 生命周期的感知。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0zZWIwYWY2ZDZlNmMyYmRmLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>除了解决一致性问题，这样做还 <strong>顺带地提供了其他 2 个好处</strong>：</p>
<blockquote>
<p><strong>1.规避 为监听状态 而 注入视图控制器 的做法</strong></p>
</blockquote>
<p>当需要监听状态时，以往我们的做法是 通过方法手工注入 Activity 等参数，这埋下了内存泄漏的隐患 —— 因为团队中的新手容易因这是个 Activity，而在日后误将其依赖给组件中的其他成员。</p>
<p>现如今，我们可以直接在组件内部 点到为止 地监听 LifecycleOwner 的状态，从而规避这种不恰当的使用。</p>
<blockquote>
<p><strong>2.规避 为追溯事故来源 而 注入视图控制器 的做法</strong></p>
</blockquote>
<p>当发生事故时，以往我们若想在组件中 <strong>追溯事故来源</strong>，同样不得不从方法中直接注入 Activity 等，这同样埋下了内存泄漏的隐患。现如今组件因实现了 DefaultLifecycleObserver，而得以通过生命周期回调方法中的 LifecycleOwner 参数，<strong>在方法作用域中 即可得知事故来源</strong>，无需更多带有隐患的操作。</p>
<blockquote>
<p>如果这么说还不理解的话，可具体参考我在 <a href="https://xiaozhuanlan.com/topic/3684721950" rel="nofollow">《为你还原一个真实的 Jetpack Lifecycle》</a> 中提供的 GpsManager 案例，本文不再累述。</p>
</blockquote>
<h2><a id="Jetpack_LiveData_85"></a>Jetpack LiveData</h2>
<blockquote>
<p>LiveData 的存在，主要是为了帮助 <strong>新手老手 都能不假思索地遵循 通过唯一可信源分发状态 的标准化开发理念</strong>，从而使在快速开发过程中 难以追溯、难以排查、不可预期 的问题所发生的概率降低到最小。</p>
</blockquote>
<h3><a id="LiveData__89"></a>LiveData 存在前的混沌世界</h3>
<p>在 LiveData 面市前，我们分发状态，多是通过 EventBus 或 Java Interface 来完成的。不管你是用于网络请求回调的情况，还是跨页面通信的情况。</p>
<p>那这造成了什么问题呢？首先，EventBus 只是纯粹的 Bus，它 <strong>缺乏上述提到的 标准化开发理念 的约束，那么人们在使用这个框架时，容易因 去中心化 地滥用，而造成 诸如 毫无防备地收到 预期外的 不明来源的推送、拿到过时的数据 及 事件源追溯复杂度 为 n² 的局面</strong>。</p>
<p>并且，<strong>EventBus 本身缺乏 Lifecycle 的加持，存在生命周期管理的一致性问题。这是 EventBus 的硬伤</strong>，也是我拒绝使用 EventBus 的最主要因素。</p>
<blockquote>
<p>对上述状况不理解的，可具体参考我在 <a href="https://xiaozhuanlan.com/topic/0168753249" rel="nofollow">《LiveData 鲜为人知的 身世背景 和 独特使命》</a> 中提供的 播放器状态全局通知 的案例</p>
</blockquote>
<h3><a id="LiveData__99"></a>LiveData 为什么能解决上述这些问题？</h3>
<p>首先，<strong>LiveData 是在 Google 希望确立 标准化、规范化 的开发模式 —— 这样一种背景下诞生的</strong>，因而为了达成这个艰巨的 <strong>使命</strong>，Google 十分克制地将其设计为，仅支持状态的输入和监听，从而，它不得不 <strong>在单例的配合下，承上启下地完成 状态 从 唯一可信源 到 视图控制器 的输送</strong>。</p>
<blockquote>
<p>（ViewModel 姑且也算是一种单例，一种工厂模式实现的伪单例。<strong>唯一可信源是指 生命周期独立于 视图控制器的 数据组件</strong>，通常是 单例 或共享 ViewModel）</p>
</blockquote>
<p><strong>这使得任何一次状态推送，都可预期、都能方便地追溯来源，而不至于在 事件追溯复杂度为 n² 的迷宫中白费时间。</strong>（即，无论是从哪个视图控制器发起的 对某个共享状态改变的请求，状态最终的改变 都由 作为唯一可信源的 单例或 SharedViewModel 来一对多地通知改变）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy02ZGY4MGFiMzI3NTVhMjg4LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>并且，这种承上启下的方式，使得单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避了视图控制器 被生命周期更长的单例 依赖 所埋下的内存泄漏的隐患。</p>
<h3><a id="LiveData__112"></a>LiveData 有个坑需要注意</h3>
<p>不过，LiveData 的设计有个坑，这里我顺带提一下。</p>
<p>为了在视图控制器发生重建后，能够 自动倒灌 所观察的 LiveData 的最后一次数据，<strong>LiveData 被设计为粘性事件</strong>。</p>
<blockquote>
<p>—— 我姑且认为这是个拓展性不佳的设计，甚至可以说是一个 bug，</p>
</blockquote>
<p>因为 MVVM 是一个整体，既然 <strong>ViewModel 支持共享作用域，并且官方文档都承认了通过 共享 ViewModel 来实现跨页面通信的需求</strong>，</p>
<p>那么基于 “开闭原则”，LiveData 理应提供一个与 MutableLiveData 平级的底层支持，专门用于非粘性的事件通信的情况，否则直接在跨页面通信中使用 MutableLiveData <strong>必造成 事件回调的一致性问题 及 难以预期的错误</strong>。</p>
<p>关于非粘性 LiveData 的实现，网上存在通过 “事件包装类”（只适合 kotlin 的情况） 和 “反射干预 LastVersion” （适用于 Java 的情况）两种方式来解决：</p>
<blockquote>
<p><a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" rel="nofollow">juejin.im/post/5b2b1b…</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/geyuecang/article/details/89028283">blog.csdn.net/geyuecang/a…</a></p>
</blockquote>
<p>无论是使用哪一种实现，我都建议 遵循传统 LiveData 所遵循的开发理念，通过唯一可信源分发状态，来方便事件源头的追溯。对于 “去中心化” 的 Bus 方式，我拒绝在项目中这样使用。</p>
<blockquote>
<p>（具体我会在未来开源的最佳实践项目中 展示 UnPeekLiveData 的使用）</p>
</blockquote>
<h2><a id="Jetpack_ViewModel_134"></a>Jetpack ViewModel</h2>
<blockquote>
<p>ViewModel 的存在，主要是为了解决 状态管理 和 页面通信 的问题。</p>
</blockquote>
<h3><a id="ViewModel__138"></a>ViewModel 存在前的混沌世界</h3>
<p>ViewModel 的本职工作是 <strong>状态托管</strong> 和 <strong>状态管理的分治</strong>，也即当视图控制器重建时，</p>
<blockquote>
<p>对于轻量的状态，可以通过视图控制器基类的 saveInstanceState 机制，以序列化的方式完成存储和恢复。</p>
</blockquote>
<blockquote>
<p>对于重量级的状态，例如通过网络请求得到的 List，可以通过生命周期长于视图控制器的 ViewModel 持有，从而得以直接从 ViewModel 恢复，而不是以效率较低的序列化方式。</p>
</blockquote>
<p>在 Jetpack ViewModel 面市之前，MVP 的 Presenter 和 MVVM - Clean 的 ViewModel 都不具备状态管理分治的能力。</p>
<p>Presenter 和 Clean ViewModel 的生命周期都与视图控制器同生共死，因而它们顶多是为 DataBinding 提供状态的托管，而无法实现状态的分治。</p>
<p>到了 Jetpack 这一版，ViewModel 以精妙的设计，达成了状态管理，以及可共享的作用域。</p>
<h3><a id="ViewModel__152"></a>ViewModel 为什么能做到这几点？</h3>
<p>其实这版主要是基于 <strong>工厂模式</strong>，使得 ViewModel <strong>被 LifecycleOwner 所持有、通过 ViewModelProvider 来引用</strong>，</p>
<p>所以 <strong>它既类似于单例：</strong> —— 当被作为 LifecycleOwner 的 Activity 持有时，能够脱离 Activity 旗下 Fragment 的生命周期，从而实现作用域共享，</p>
<p><strong>实际上又不是单例：</strong> —— 生命周期跟随 作为 LifecycleOwner 的视图控制器，当 Owner（Activity 或 Fragment）被销毁时，它也被 clear。</p>
<blockquote>
<p>此外，出于对视图控制器重建的考虑，Google 在视图控制器基类中通过 retain 机制对 ViewModel 进行了保留。</p>
</blockquote>
<blockquote>
<p>因此，对于 作用域共享 和 视图重建 的情况，状态因完好地被保留，而得以被视图控制器在恢复时直接使用。</p>
</blockquote>
<p>再者，由于存在 共享作用域的考虑，所以 ViewModel 本身也承担了跨页面通信（例如事件回调）的职责。前面在介绍 LiveData 时，对于 LiveData 在事件通信时粘性设计的问题已经介绍过了，这里不再累述。</p>
<blockquote>
<p>截至 2020.2.1，ViewModel 在 Fragment 中的 retain 设计已发生剧变，具体缘由可参考我在 <a href="https://xiaozhuanlan.com/topic/6257931840" rel="nofollow">《有了 Jetpack ViewModel . . . 真的可以为所欲为！》</a> 文末及评论区的最新补充。</p>
</blockquote>
<h2><a id="Jetpack_DataBinding_168"></a>Jetpack DataBinding</h2>
<blockquote>
<p>DataBinding 的存在，主要是为了解决 视图调用 的一致性问题。</p>
</blockquote>
<h3><a id="DataBinding__172"></a>DataBinding 存在前的混沌世界</h3>
<p>在 DataBinding 面市前，我们若要改变视图的状态，首先就要引用该视图，例如 textView.setText()，</p>
<p>这造成什么问题呢？</p>
<blockquote>
<p>当页面存在横、竖布局，且两种布局的控件存在差异，例如横屏存在 textView 控件，而竖屏没有，那么我们就不得不在视图控制器中为 textView 做判空处理，这就造成了一致性问题 —— 容易疏忽而忘记判空，毕竟页面多达数十个、每个页面的控件也无数。</p>
</blockquote>
<p>那怎么办呢？</p>
<h3><a id="DataBinding__182"></a>DataBinding 就是来解决这些问题</h3>
<p>通过在布局中与可观察的数据发生绑定，那么当该数据被 set 新的内容时，控件也将得到通知和刷新。</p>
<p>换言之，在使用 DataBinding 后，唯一的改变是，你无需手工调用视图来 set 新状态，你只需 set 数据本身。</p>
<p>因而，<strong>DataBinding 并非许多人不假思索认为的，将 UI 逻辑搬到 XML 中写 从而难以调试 —— 事实根本不是这样的：</strong></p>
<p><strong>DataBinding 只负责绑定数据、负责作为 UI 逻辑末端的状态的改变</strong>（也即它是一个不可再分的原子操作，本来就不需要调试），原本在视图控制器中 UI 逻辑怎么写，现在还是怎么写，只不过不再需要 textView.setText(xxx)，而是直接 xxx.set()。</p>
<p>所以在 DataBinding 的帮助下，好处总共有多少个呢？</p>
<blockquote>
<p>1.规避了视图状态的 一致性问题 —— 无需手工判空。</p>
</blockquote>
<blockquote>
<p>2.规避了视图状态的 一致性问题，乃至无需视图调用，从而完全不用编写 findViewById。</p>
</blockquote>
<blockquote>
<p>3.就算要调用视图，也不用 findViewById，而是直接通过 binding 来引用。</p>
</blockquote>
<blockquote>
<p>4.先前的 UI 逻辑基本不用改动，改的只是作为末端的状态改变的方式。</p>
</blockquote>
<p>……</p>
<p>此外，<strong>DataBinding 有个大杀器就是，能为控件提供自定义属性的 BindingAdapter</strong>，它不仅可以解决 圆角 Drawable 复用的问题（你懂得），还可以实现 imageView 直接绑定 url 等需求，总之，没有它办不到的，只有你想不到的，DataBinding 的好处等着你挖掘。😉</p>
<p>关于 DataBinding 的注意事项，以及屡试不爽的排坑技巧，可具体参考 <a href="https://xiaozhuanlan.com/topic/9816742350" rel="nofollow">《从 被误解 到 真香 的 Jetpack DataBinding！》</a>，这里不做累述。</p>
<h2><a id="_208"></a>综上</h2>
<p>Lifecycle 的存在，主要是为了解决 <strong>生命周期管理 的一致性问题</strong>。</p>
<p>LiveData 的存在，主要是为了帮助 新手老手 都能不假思索地 <strong>遵循 通过唯一可信源分发状态 的标准化开发理念</strong>，从而在快速开发过程中 规避一系列 <strong>难以追溯、难以排查、不可预期</strong> 的问题。</p>
<p>ViewModel 的存在，主要是为了解决 <strong>状态管理 和 页面通信 的问题</strong>。</p>
<p>DataBinding 的存在，主要是为了解决 <strong>视图调用 的一致性问题</strong>。</p>
<p>它们的存在 大都是为了 在软件工程的背景下 解决一致性的问题、将容易出错的操作在后台封装好，<strong>方便使用者快速、稳定、不产生预期外错误地编码</strong>。</p>
<p>这样说，你理解了吗？😉</p>
<p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice">GitHub : Jetpack-MVVM-Best-Practice</a></p>
<p>作者：KunMinX<br>
链接：https://juejin.im/post/5dafc49b6fb9a04e17209922</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">面试官：“会不会熟练使用Jetpack”  我：“......”</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-10 17:49:46                    </span>
                    <span class="read-count">阅读数 28</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-10 17:49:46</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9337526.html">
                                       阿里                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9416379.html">
                                       Android                                   </a>
                                                                                                                            <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9787385.html">
                                       framework                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104779418">https://blog.csdn.net/weixin_43901866/article/details/104779418</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <h2><a id="_0"></a>面向标准化开发已成现实</h2>
<p>金三银四，相信有不少读者在抓紧机会面试。</p>
<p>Android 市场已今非昔比。在过去，迫于招人的压力，应试者只需了解四大组件、视图、网络请求，即可谋得一份满意的工作。</p>
<p>现如今，Jetpack 架构组件 及 标准化开发模式 的确立，意味着 Android 开发已步入成熟阶段：</p>
<blockquote>
<p>许多 样板代码 不再需要开发者手写，而是可以通过模版工具 自动生成，在取缔繁杂耗时的重复工作的同时，<strong>避免因人工操作的疏忽，而造成难以排查、不可预期的错误</strong>。</p>
</blockquote>
<p>这十分符合企业的利益，因而面试官在招人的时候，也更加看重应试者对 架构组件 —— 至少是 MVVM 的理解程度。🧐</p>
<p>像“解耦”等 含糊其辞的说法，已经不能够被面试官所认可，稍微对 MVVM 有一点经验的面试官都会请你举例说明，好证明你确实对 MVVM 有着正确、深入的理解，能够自然而然地写出标准化、规范化的代码，能够迅速适应 各家公司自制的 自动化模版工具。</p>
<h2><a id="_14"></a>本文的目标</h2>
<p>本人拥有 3 年的 移动端架构 践行和设计经验，领导团队重构的中大型项目多达十数个，对 Jetpack MVVM 架构在确立规范化、标准化 开发模式 以减少不可预期的错误 所作的努力，有着深入的理解。</p>
<p>因而本文的目标，就是结合前几期我们分别 深入浅出 介绍过的 Lifecycle、LiveData、ViewModel、DataBinding，来融汇贯通地演绎一下：</p>
<p><strong>作为 应用开发骨架 的 标准化状态管理框架</strong>，究竟为 快速开发过程中 减少不可预期的错误 做了哪些努力。</p>
<p>不同于 东拼西凑、人云亦云、徒添困扰 的网文，愿意将 标准化开发模式的 <strong>深度思考知识</strong> 和 <strong>实战反思经验</strong> 无保留地分享，全网仅此一家。<strong>这样的文章可以说是 看一篇、少一篇</strong>，因此，就算不去 hold 住面试官，也请务必跟随本文的脚步，无障碍地将 Jetpack MVVM 过一遍！😉</p>
<h2><a id="_24"></a>文章目录一览</h2>
<ul>
<li>前言</li>
<li>面向标准化开发已成现实</li>
<li>本文的目标</li>
<li>Jetpack Lifecycle
<ul>
<li>Lifecycle 存在前的混沌世界</li>
<li>Lifecycle 为什么能解决上述这些问题？</li>
</ul>
</li>
<li>Jetpack LiveData
<ul>
<li>LiveData 存在前的混沌世界</li>
<li>LiveData 为什么能解决上述这些问题？</li>
<li><strong>LiveData 有个坑需要注意</strong></li>
</ul>
</li>
<li>Jetpack ViewModel
<ul>
<li>ViewModel 存在前的混沌世界</li>
<li>ViewModel 为什么能做到这几点？</li>
</ul>
</li>
<li>Jetpack DataBinding
<ul>
<li>DataBinding 存在前的混沌世界</li>
<li>DataBinding 就是来解决这些问题</li>
</ul>
</li>
<li>综上</li>
</ul>
<h2><a id="Jetpack_Lifecycle_44"></a>Jetpack Lifecycle</h2>
<blockquote>
<p><strong>Lifecycle 的存在，主要是为了解决 生命周期管理 的一致性问题</strong></p>
</blockquote>
<h3><a id="Lifecycle__48"></a>Lifecycle 存在前的混沌世界</h3>
<p>在 Lifecycle 面市前，生命周期管理 纯靠手工维持，这样就容易滋生大量的一致性问题。</p>
<p>例如跨页面共享的 GpsManager 组件，在每个依赖它的 Activity 的 onResume 和 onPause 中都需要 <strong>手工 激活、解绑 和 叫停</strong>。</p>
<p>那么 <strong>随着 Activity 的增多，这种手工操作 埋下的一致性隐患 就会指数级增长</strong>：</p>
<blockquote>
<p>一方面，凡是手工维持的，开发者容易疏忽，特别是工作交接给其他同事时，同事并不能及时注意到这些细节。</p>
</blockquote>
<blockquote>
<p>另一方面，分散的代码不利于修改，日后除了激活、叫停，若有其他操作需要补充（例如状态监听），那么每个 Activity 都需要额外书写一遍。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy01MDc1ODQzYTYzNWQyNjJlLnBuZw?x-oss-process=image/format,png" alt=""></p>
<h3><a id="Lifecycle__62"></a>Lifecycle 为什么能解决上述这些问题？</h3>
<p>Lifecycle 通过 模板方法模式 和 观察者模式，将生命周期管理的复杂操作，全部在作为 LifecycleOwner 的基类中（例如视图控制器的基类）封装好，默默地在背后为开发者运筹帷幄，</p>
<p>开发者因而得以在视图控制器（子类）中只需一句 <code>getLifecycle().addObserver(GpsManager.getInstance)</code> ，优雅地完成 第三方组件在自己内部 对 LifecycleOwner 生命周期的感知。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy0zZWIwYWY2ZDZlNmMyYmRmLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>除了解决一致性问题，这样做还 <strong>顺带地提供了其他 2 个好处</strong>：</p>
<blockquote>
<p><strong>1.规避 为监听状态 而 注入视图控制器 的做法</strong></p>
</blockquote>
<p>当需要监听状态时，以往我们的做法是 通过方法手工注入 Activity 等参数，这埋下了内存泄漏的隐患 —— 因为团队中的新手容易因这是个 Activity，而在日后误将其依赖给组件中的其他成员。</p>
<p>现如今，我们可以直接在组件内部 点到为止 地监听 LifecycleOwner 的状态，从而规避这种不恰当的使用。</p>
<blockquote>
<p><strong>2.规避 为追溯事故来源 而 注入视图控制器 的做法</strong></p>
</blockquote>
<p>当发生事故时，以往我们若想在组件中 <strong>追溯事故来源</strong>，同样不得不从方法中直接注入 Activity 等，这同样埋下了内存泄漏的隐患。现如今组件因实现了 DefaultLifecycleObserver，而得以通过生命周期回调方法中的 LifecycleOwner 参数，<strong>在方法作用域中 即可得知事故来源</strong>，无需更多带有隐患的操作。</p>
<blockquote>
<p>如果这么说还不理解的话，可具体参考我在 <a href="https://xiaozhuanlan.com/topic/3684721950" rel="nofollow">《为你还原一个真实的 Jetpack Lifecycle》</a> 中提供的 GpsManager 案例，本文不再累述。</p>
</blockquote>
<h2><a id="Jetpack_LiveData_85"></a>Jetpack LiveData</h2>
<blockquote>
<p>LiveData 的存在，主要是为了帮助 <strong>新手老手 都能不假思索地遵循 通过唯一可信源分发状态 的标准化开发理念</strong>，从而使在快速开发过程中 难以追溯、难以排查、不可预期 的问题所发生的概率降低到最小。</p>
</blockquote>
<h3><a id="LiveData__89"></a>LiveData 存在前的混沌世界</h3>
<p>在 LiveData 面市前，我们分发状态，多是通过 EventBus 或 Java Interface 来完成的。不管你是用于网络请求回调的情况，还是跨页面通信的情况。</p>
<p>那这造成了什么问题呢？首先，EventBus 只是纯粹的 Bus，它 <strong>缺乏上述提到的 标准化开发理念 的约束，那么人们在使用这个框架时，容易因 去中心化 地滥用，而造成 诸如 毫无防备地收到 预期外的 不明来源的推送、拿到过时的数据 及 事件源追溯复杂度 为 n² 的局面</strong>。</p>
<p>并且，<strong>EventBus 本身缺乏 Lifecycle 的加持，存在生命周期管理的一致性问题。这是 EventBus 的硬伤</strong>，也是我拒绝使用 EventBus 的最主要因素。</p>
<blockquote>
<p>对上述状况不理解的，可具体参考我在 <a href="https://xiaozhuanlan.com/topic/0168753249" rel="nofollow">《LiveData 鲜为人知的 身世背景 和 独特使命》</a> 中提供的 播放器状态全局通知 的案例</p>
</blockquote>
<h3><a id="LiveData__99"></a>LiveData 为什么能解决上述这些问题？</h3>
<p>首先，<strong>LiveData 是在 Google 希望确立 标准化、规范化 的开发模式 —— 这样一种背景下诞生的</strong>，因而为了达成这个艰巨的 <strong>使命</strong>，Google 十分克制地将其设计为，仅支持状态的输入和监听，从而，它不得不 <strong>在单例的配合下，承上启下地完成 状态 从 唯一可信源 到 视图控制器 的输送</strong>。</p>
<blockquote>
<p>（ViewModel 姑且也算是一种单例，一种工厂模式实现的伪单例。<strong>唯一可信源是指 生命周期独立于 视图控制器的 数据组件</strong>，通常是 单例 或共享 ViewModel）</p>
</blockquote>
<p><strong>这使得任何一次状态推送，都可预期、都能方便地追溯来源，而不至于在 事件追溯复杂度为 n² 的迷宫中白费时间。</strong>（即，无论是从哪个视图控制器发起的 对某个共享状态改变的请求，状态最终的改变 都由 作为唯一可信源的 单例或 SharedViewModel 来一对多地通知改变）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTk1NjEyNy02ZGY4MGFiMzI3NTVhMjg4LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>并且，这种承上启下的方式，使得单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避了视图控制器 被生命周期更长的单例 依赖 所埋下的内存泄漏的隐患。</p>
<h3><a id="LiveData__112"></a>LiveData 有个坑需要注意</h3>
<p>不过，LiveData 的设计有个坑，这里我顺带提一下。</p>
<p>为了在视图控制器发生重建后，能够 自动倒灌 所观察的 LiveData 的最后一次数据，<strong>LiveData 被设计为粘性事件</strong>。</p>
<blockquote>
<p>—— 我姑且认为这是个拓展性不佳的设计，甚至可以说是一个 bug，</p>
</blockquote>
<p>因为 MVVM 是一个整体，既然 <strong>ViewModel 支持共享作用域，并且官方文档都承认了通过 共享 ViewModel 来实现跨页面通信的需求</strong>，</p>
<p>那么基于 “开闭原则”，LiveData 理应提供一个与 MutableLiveData 平级的底层支持，专门用于非粘性的事件通信的情况，否则直接在跨页面通信中使用 MutableLiveData <strong>必造成 事件回调的一致性问题 及 难以预期的错误</strong>。</p>
<p>关于非粘性 LiveData 的实现，网上存在通过 “事件包装类”（只适合 kotlin 的情况） 和 “反射干预 LastVersion” （适用于 Java 的情况）两种方式来解决：</p>
<blockquote>
<p><a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" rel="nofollow">juejin.im/post/5b2b1b…</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/geyuecang/article/details/89028283">blog.csdn.net/geyuecang/a…</a></p>
</blockquote>
<p>无论是使用哪一种实现，我都建议 遵循传统 LiveData 所遵循的开发理念，通过唯一可信源分发状态，来方便事件源头的追溯。对于 “去中心化” 的 Bus 方式，我拒绝在项目中这样使用。</p>
<blockquote>
<p>（具体我会在未来开源的最佳实践项目中 展示 UnPeekLiveData 的使用）</p>
</blockquote>
<h2><a id="Jetpack_ViewModel_134"></a>Jetpack ViewModel</h2>
<blockquote>
<p>ViewModel 的存在，主要是为了解决 状态管理 和 页面通信 的问题。</p>
</blockquote>
<h3><a id="ViewModel__138"></a>ViewModel 存在前的混沌世界</h3>
<p>ViewModel 的本职工作是 <strong>状态托管</strong> 和 <strong>状态管理的分治</strong>，也即当视图控制器重建时，</p>
<blockquote>
<p>对于轻量的状态，可以通过视图控制器基类的 saveInstanceState 机制，以序列化的方式完成存储和恢复。</p>
</blockquote>
<blockquote>
<p>对于重量级的状态，例如通过网络请求得到的 List，可以通过生命周期长于视图控制器的 ViewModel 持有，从而得以直接从 ViewModel 恢复，而不是以效率较低的序列化方式。</p>
</blockquote>
<p>在 Jetpack ViewModel 面市之前，MVP 的 Presenter 和 MVVM - Clean 的 ViewModel 都不具备状态管理分治的能力。</p>
<p>Presenter 和 Clean ViewModel 的生命周期都与视图控制器同生共死，因而它们顶多是为 DataBinding 提供状态的托管，而无法实现状态的分治。</p>
<p>到了 Jetpack 这一版，ViewModel 以精妙的设计，达成了状态管理，以及可共享的作用域。</p>
<h3><a id="ViewModel__152"></a>ViewModel 为什么能做到这几点？</h3>
<p>其实这版主要是基于 <strong>工厂模式</strong>，使得 ViewModel <strong>被 LifecycleOwner 所持有、通过 ViewModelProvider 来引用</strong>，</p>
<p>所以 <strong>它既类似于单例：</strong> —— 当被作为 LifecycleOwner 的 Activity 持有时，能够脱离 Activity 旗下 Fragment 的生命周期，从而实现作用域共享，</p>
<p><strong>实际上又不是单例：</strong> —— 生命周期跟随 作为 LifecycleOwner 的视图控制器，当 Owner（Activity 或 Fragment）被销毁时，它也被 clear。</p>
<blockquote>
<p>此外，出于对视图控制器重建的考虑，Google 在视图控制器基类中通过 retain 机制对 ViewModel 进行了保留。</p>
</blockquote>
<blockquote>
<p>因此，对于 作用域共享 和 视图重建 的情况，状态因完好地被保留，而得以被视图控制器在恢复时直接使用。</p>
</blockquote>
<p>再者，由于存在 共享作用域的考虑，所以 ViewModel 本身也承担了跨页面通信（例如事件回调）的职责。前面在介绍 LiveData 时，对于 LiveData 在事件通信时粘性设计的问题已经介绍过了，这里不再累述。</p>
<blockquote>
<p>截至 2020.2.1，ViewModel 在 Fragment 中的 retain 设计已发生剧变，具体缘由可参考我在 <a href="https://xiaozhuanlan.com/topic/6257931840" rel="nofollow">《有了 Jetpack ViewModel . . . 真的可以为所欲为！》</a> 文末及评论区的最新补充。</p>
</blockquote>
<h2><a id="Jetpack_DataBinding_168"></a>Jetpack DataBinding</h2>
<blockquote>
<p>DataBinding 的存在，主要是为了解决 视图调用 的一致性问题。</p>
</blockquote>
<h3><a id="DataBinding__172"></a>DataBinding 存在前的混沌世界</h3>
<p>在 DataBinding 面市前，我们若要改变视图的状态，首先就要引用该视图，例如 textView.setText()，</p>
<p>这造成什么问题呢？</p>
<blockquote>
<p>当页面存在横、竖布局，且两种布局的控件存在差异，例如横屏存在 textView 控件，而竖屏没有，那么我们就不得不在视图控制器中为 textView 做判空处理，这就造成了一致性问题 —— 容易疏忽而忘记判空，毕竟页面多达数十个、每个页面的控件也无数。</p>
</blockquote>
<p>那怎么办呢？</p>
<h3><a id="DataBinding__182"></a>DataBinding 就是来解决这些问题</h3>
<p>通过在布局中与可观察的数据发生绑定，那么当该数据被 set 新的内容时，控件也将得到通知和刷新。</p>
<p>换言之，在使用 DataBinding 后，唯一的改变是，你无需手工调用视图来 set 新状态，你只需 set 数据本身。</p>
<p>因而，<strong>DataBinding 并非许多人不假思索认为的，将 UI 逻辑搬到 XML 中写 从而难以调试 —— 事实根本不是这样的：</strong></p>
<p><strong>DataBinding 只负责绑定数据、负责作为 UI 逻辑末端的状态的改变</strong>（也即它是一个不可再分的原子操作，本来就不需要调试），原本在视图控制器中 UI 逻辑怎么写，现在还是怎么写，只不过不再需要 textView.setText(xxx)，而是直接 xxx.set()。</p>
<p>所以在 DataBinding 的帮助下，好处总共有多少个呢？</p>
<blockquote>
<p>1.规避了视图状态的 一致性问题 —— 无需手工判空。</p>
</blockquote>
<blockquote>
<p>2.规避了视图状态的 一致性问题，乃至无需视图调用，从而完全不用编写 findViewById。</p>
</blockquote>
<blockquote>
<p>3.就算要调用视图，也不用 findViewById，而是直接通过 binding 来引用。</p>
</blockquote>
<blockquote>
<p>4.先前的 UI 逻辑基本不用改动，改的只是作为末端的状态改变的方式。</p>
</blockquote>
<p>……</p>
<p>此外，<strong>DataBinding 有个大杀器就是，能为控件提供自定义属性的 BindingAdapter</strong>，它不仅可以解决 圆角 Drawable 复用的问题（你懂得），还可以实现 imageView 直接绑定 url 等需求，总之，没有它办不到的，只有你想不到的，DataBinding 的好处等着你挖掘。😉</p>
<p>关于 DataBinding 的注意事项，以及屡试不爽的排坑技巧，可具体参考 <a href="https://xiaozhuanlan.com/topic/9816742350" rel="nofollow">《从 被误解 到 真香 的 Jetpack DataBinding！》</a>，这里不做累述。</p>
<h2><a id="_208"></a>综上</h2>
<p>Lifecycle 的存在，主要是为了解决 <strong>生命周期管理 的一致性问题</strong>。</p>
<p>LiveData 的存在，主要是为了帮助 新手老手 都能不假思索地 <strong>遵循 通过唯一可信源分发状态 的标准化开发理念</strong>，从而在快速开发过程中 规避一系列 <strong>难以追溯、难以排查、不可预期</strong> 的问题。</p>
<p>ViewModel 的存在，主要是为了解决 <strong>状态管理 和 页面通信 的问题</strong>。</p>
<p>DataBinding 的存在，主要是为了解决 <strong>视图调用 的一致性问题</strong>。</p>
<p>它们的存在 大都是为了 在软件工程的背景下 解决一致性的问题、将容易出错的操作在后台封装好，<strong>方便使用者快速、稳定、不产生预期外错误地编码</strong>。</p>
<p>这样说，你理解了吗？😉</p>
<p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice">GitHub : Jetpack-MVVM-Best-Practice</a></p>
<p>作者：KunMinX<br>
链接：https://juejin.im/post/5dafc49b6fb9a04e17209922</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
