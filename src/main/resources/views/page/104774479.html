<html>
<head>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-4bfa3af0c6.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-c9d2f651cc.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css">
<link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">
<style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>
</head>
<body class="nodata " > 
    <link rel="stylesheet" href="https://csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">
    <script id="toolbar-tpl-scriptId" src="https://csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="https://blog.csdn.net/"></script>
    <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/vendor/pagination/paging-e040f0c7c8.css">

<script type="text/javascript">
	var NEWS_FEED = function(){}
</script>

<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/chart-3456820cac.css" />
<div class="main_father clearfix d-flex justify-content-center" style="height:100%;"> 
    <div class="container clearfix" id="mainBox">
        <div  class='space_container'></div>
        <main>
            <div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">看完这篇文章，LiveData的用法竟然还可以这样用？</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-10 14:48:43                    </span>
                    <span class="read-count">阅读数 16</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-10 14:48:43</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9790707.html">
                                       livedata                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104774479">https://blog.csdn.net/weixin_43901866/article/details/104774479</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>本文主要内容：</p>
<ol>
<li>作用介绍</li>
<li>核心类介绍</li>
<li>基本使用</li>
<li>源码分析<br>
– 横竖屏切换恢复<br>
– 后台销毁恢复</li>
</ol>
<hr>
<h3><a id="ViewModel_11"></a>ViewModel的主要工作：</h3>
<p>本身主要是一个数据维护工具<br>
将数据维护的工作从<code>Activity</code>上剥离，提供一个储存数据环境，自身机制可以解决开发中，数据受<code>Activity</code>生命周期影响产生数据丢失的问题 (主要为横竖屏切换以及在后台被销毁)。<br>
通常结合<code>LiveData</code>使用。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTMzYzlmMTkwMTQxM2JkNDEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTIyL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>作为一个纯数据维护工具，可以加入到<code>MVP</code>架构中负责数据保存。<br>
而官方推选作为<code>AAC</code>架构<code>MVVM</code>中的<code>VM</code>层。</p>
<hr>
<h3><a id="ViewModel_24"></a>ViewModel的主要类：</h3>
<ul>
<li>
<p><code>ViewModel (下称VM)</code>：<br>
数据储存类，架构的核心类。<br>
使用时，直接继承该类，根据需求选择重写<code>onCleared()</code>方法。<br>
如需在<code>Activity</code>被系统销毁后依然保存数据，定义一个参数为<code>(SavedStateHandle)</code>的构造方法，并将数据保存<code>SavedStateHandle</code>中。<br>
<em>实际上通过<code>SavedInstanceState</code>存取</em></p>
</li>
<li>
<p><code>AndroidViewModel</code>：<br>
<code>VM</code>子类，维护了<code>Application</code>的引用，由架构中的<code>SavedStateViewModelFactory</code>创建时传入。<br>
同样，需要接收<code>SavedStateHandle</code>时，需要定义参数为 <code>(Application, SavedStateHandle)</code>的构造方法。</p>
</li>
<li>
<p><code>ViewModelStore</code>：<br>
用于保存<code>VM</code>，内部维护了一个用于储存<code>VM</code>的<code>HashMap</code>。<br>
一般情况下，直接使用本类创建实例。</p>
</li>
<li>
<p><code>ViewModelStoreOwner</code>：<br>
接口，实现该接口的类，表示自身能够向外提供<code>VM</code>。<br>
androidx 的<code>AppCompatActivity</code>/<code>Fragment</code>实现了该接口。</p>
</li>
<li>
<p><code>ViewModelProvider</code>：<br>
<code>VM</code>的提供者，获取<code>VM</code>的基本入口。<br>
实际依赖<code>ViewModelStore</code>存取<code>VM</code>，<code>Factory</code>生成/恢复<code>VM</code>。</p>
</li>
<li>
<p><code>Factory</code>：<br>
接口，实现该接口的类主要用于创建<code>VM</code>实例。<br>
不建议直接实现该接口，除非你清楚框架内容和自己的需求。<br>
一般情况下，如果无需<code>SavedStateHandle</code>机制，可以使用<code>AndroidViewModelFactory</code>。<br>
否则应该使用或继承<code>SavedStateViewModelFactory</code>。</p>
</li>
</ul>
<hr>
<h3><a id="ViewModel_56"></a>ViewModel的基本使用：</h3>
<ul>
<li><strong>一般使用：</strong></li>
</ul>
<pre><code>// VM
class ViewModelA : ViewModel()
// AVM
class ViewModelB(app: Application) : AndroidViewModel(app)

// Activity/Fragment .onCreate中
override fun onCreate() {
  ...
  val provider = ViewModelProvider(this)
  val vmA = provider.get(ViewModelA::class.java)
  val vmB = provider.get(ViewModelB::class.java)
  ...
}

</code></pre>
<ul>
<li><strong>接受 SavedStateHandle</strong></li>
</ul>
<pre><code>// VM
class ViewModelC(
        val handle: SavedStateHandle
) : ViewModel()

// AVM
class ViewModelD(
        app: Application, 
        val handle: SavedStateHandle
) : AndroidViewModel(app)

</code></pre>
<ul>
<li><strong>跨 Fragment 共享数据</strong><br>
Fragment中直接以Activity作为ViewModel的Key</li>
</ul>
<pre><code>...
val provider = ViewModelProvider(requireActivity())
val vmA = provider.get(ViewModelA::class.java)

</code></pre>
<ul>
<li><strong>通过 Application 创建全局共享的 VM</strong></li>
</ul>
<pre><code>class App : Application(), ViewModelStoreOwner {
    private lateinit var mAppViewModelStore: ViewModelStore
    private lateinit var mFactory: ViewModelProvider.Factory

    override fun onCreate() {
        super.onCreate()
        mAppViewModelStore = ViewModelStore()
        mFactory = ViewModelProvider
                      .AndroidViewModelFactory
                      .getInstance(this)
    }

    override fun getViewModelStore(): ViewModelStore {
        return mAppViewModelStore
    }

    private fun getAppFactory(): ViewModelProvider.Factory {
        return mFactory
    }

    fun getAppViewModelProvider(activity: Activity): ViewModelProvider {
        val app = checkApplication(activity) as App
        return ViewModelProvider(app, app.getAppFactory())
    }

    fun getAppViewModelProvider(fragment: Fragment): ViewModelProvider {
        return getAppViewModelProvider(fragment.requireActivity())
    }

    private fun checkApplication(activity: Activity): Application {
        return activity.application
                ?: throw IllegalStateException(
                      "Your activity is not yet attached to the Application instance." + 
                      "You can't request ViewModel before onCreate call.")
    }
}

</code></pre>
<hr>
<h3><a id="ViewModel_147"></a>ViewModel的关键源码分析：</h3>
<p><em><strong>以下源码分析将会去除非相关代码以简化</strong></em></p>
<ul>
<li><strong>ViewModelProvider 实现相关：</strong></li>
</ul>
<p>前面提到，<code>ViewModelProvider</code>的工作完全依赖传入的<code>ViewModelStore</code>和<code>Factory</code>，可以直接从构造方法得知：</p>
<pre><code>ViewModelProvider.java
----------------------

private final Factory mFactory;
private final ViewModelStore mViewModelStore;

public ViewModelProvider(ViewModelStoreOwner owner) {
  this(owner.getViewModelStore(), 
        owner instanceof HasDefaultViewModelProviderFactory
        ? ((HasDefaultViewModelProviderFactory) owner)
            .getDefaultViewModelProviderFactory()
        : NewInstanceFactory.getInstance());
}

public ViewModelProvider(ViewModelStoreOwner owner, Factory factory) {
    this(owner.getViewModelStore(), factory);
}

public ViewModelProvider(ViewModelStore store, Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}

// 简单的反射创建实例的工厂
public static class NewInstanceFactory implements Factory {
    public &lt;T extends ViewModel&gt; T create(Class&lt;T&gt; modelClass) {
        return modelClass.newInstance()
    }
}

</code></pre>
<p>而<code>androidx.activity.ComponentActivity</code>，<code>androidx.fragment.app.Fragment</code>都实现了<code>ViewModelStoreOwner</code>，<code>HasDefaultViewModelProviderFactory</code>接口。</p>
<pre><code>public class AppCompatActivity extends FragmentActivity...{}
public class FragmentActivity extends ComponentActivity...{}

public class ComponentActivity extends ... implements
        ViewModelStoreOwner,
        HasDefaultViewModelProviderFactory,
        SavedStateRegistryOwner ... {}

public class Fragment implements 
        ViewModelStoreOwner, 
        HasDefaultViewModelProviderFactory, 
        SavedStateRegistryOwner ... {}

</code></pre>
<p><code>ViewModelProvider</code>的<code>get()</code>方法中返回<code>VM</code>实例，其中<code>mFactory</code>为 <code>SavedStateViewModelFactory</code>：</p>
<pre><code>ViewModelProvider.java
----------------------

private static final String DEFAULT_KEY 
      = "androidx.lifecycle.ViewModelProvider.DefaultKey";

public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) {
    String canonicalName = modelClass.getCanonicalName();
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}

public &lt;T extends ViewModel&gt; T get(String key, Class&lt;T&gt; modelClass) {
    ViewModel viewModel = mViewModelStore.get(key);

    // 一个确保机制
    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    }

    // 正常以及基本的逻辑
    if (mFactory instanceof KeyedFactory) {
        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);
    } else {
        viewModel = (mFactory).create(modelClass);
    }

    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}

</code></pre>
<p><code>SavedStateViewModelFactory</code>在后面解析。</p>
<hr>
<ul>
<li><strong>ViewModel 的屏幕横竖屏切换恢复机制：</strong></li>
</ul>
<p>前面说到，创建<code>VM</code>是通过<code>ViewModelProvider</code>实现的，而<code>ViewModelProvider</code>又是依赖<code>ViewModelStore</code>进行<code>VM</code>的保存。<br>
当使用<code>ComponentActivity</code>/<code>Fragment</code>作为<code>ViewModelProvider</code>的初始化参数时，实际<code>VM</code>的储存容器是参数提供的。</p>
<ol>
<li><strong>ComponentActivity 实现：</strong></li>
</ol>
<p>从源码中，可以看出横竖屏切换是直接通过<code>NonConfigurationInstances</code>进行恢复的。</p>
<p><code>ComponentActivity</code>包含一个<code>NonConfigurationInstances</code>类，其中持有<code>ViewModelStore</code>的引用：</p>
<pre><code>ComponentActivity.java
----------------------

static final class NonConfigurationInstances {
    Object custom;
    ViewModelStore viewModelStore;
}

</code></pre>
<p>保存<code>ViewModelStore</code>：<br>
通过<code>onRetainNonConfigurationInstance()</code>在横竖屏切换中保存<code>ViewModelStore</code></p>
<pre><code>ComponentActivity.java
----------------------

public final Object onRetainNonConfigurationInstance() {
    Object custom = onRetainCustomNonConfigurationInstance();

    // 从上一个 NonConfigurationInstances 中恢复 ViewModelStore
    ViewModelStore viewModelStore = mViewModelStore;
    if (viewModelStore == null) {
        NonConfigurationInstances nc = 
                (NonConfigurationInstances) getLastNonConfigurationInstance();

        if (nc != null) {
            viewModelStore = nc.viewModelStore;
        }
    }

    if (viewModelStore == null &amp;&amp; custom == null) {
        return null;
    }

    // 保存当前 ViewModelStore
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.custom = custom;
    nci.viewModelStore = viewModelStore;
    return nci;
}

</code></pre>
<p>在使用时尝试通过<code>getLastNonConfigurationInstance()</code>恢复<code>ViewModelStore</code>：</p>
<pre><code>ComponentActivity.java
----------------------

public ViewModelStore getViewModelStore() {
    if (mViewModelStore == null) {
        NonConfigurationInstances nc = 
                (NonConfigurationInstances) getLastNonConfigurationInstance();

        if (nc != null) {
            // 通过 NonConfigurationInstances 对象直接恢复 ViewModelStore
            mViewModelStore = nc.viewModelStore;
        }
        if (mViewModelStore == null) {
            mViewModelStore = new ViewModelStore();
        }
    }
    return mViewModelStore;
}

</code></pre>
<ol start="2">
<li><strong>Fragment 实现：</strong></li>
</ol>
<p>要看懂该部分源码，需要对FragmentManager有基础了解，参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fazurelaker%2Farticle%2Fdetails%2F84310053" rel="nofollow">深入理解FragmentManager</a></p>
<p><code>Fragment</code>的<code>ViewModelStore</code>由<code>FragmentManager</code>维护的<code>FragmentManagerViewModel</code>管理。</p>
<ul>
<li><strong>注意这里使用了一个<code>VM</code>来维护一个<code>ViewModelStore</code></strong></li>
</ul>
<pre><code>Fragment.java
-------------

public ViewModelStore getViewModelStore() {
    return mFragmentManager.getViewModelStore(this);
}

FragmentManager.java
--------------------

private FragmentManagerViewModel mNonConfig;

ViewModelStore getViewModelStore(Fragment f) {
    return mNonConfig.getViewModelStore(f);
}

</code></pre>
<p>处理<code>FragmentManagerViewModel</code>的实例化：</p>
<pre><code>FragmentManager.java
--------------------

void attachController(FragmentHostCallback&lt;?&gt; host, 
                      FragmentContainer container,
                      final Fragment parent) {
    mHost = host;
    mParent = parent;

    if (parent != null) {
        // 从父类的FM中获取
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        // 假如 host 对象是实现了 ViewModelStoreOwner
        // 则使用这个ViewModelStoreOwner的viewModelStore创建一个 FragmentManagerViewModel
        ViewModelStore viewModelStore = 
                ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        // 生成一个不支持自动保存ViewModel的 FragmentManagerViewModel
        mNonConfig = new FragmentManagerViewModel(false);
    }
}

</code></pre>
<p>但从源码注释可以了解到，第三种情况已废弃，理想情况下并不支持。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTczMzUxNmFkZjY4NWM0MjEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjAxL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>所以基本上，出现的应该为第一、第二种情况。</p>
<p><code>host</code>对象实际是实现的<code>ViewModelStoreOwner</code>接口的<code>FragmentActivity$HostCallbacks</code>：</p>
<pre><code>FragmentActivity.java
---------------------

class HostCallbacks 
            extends FragmentHostCallback&lt;FragmentActivity&gt; 
            implements ViewModelStoreOwner ... {...}

</code></pre>
<p>第二种情况，<code>attachController()</code>传入参数为null，可以理解为直接附着在<code>FragmentActivity</code>上的<code>Fragment</code>:</p>
<pre><code>FragmentActivity.java
---------------------

protected void onCreate(@Nullable Bundle savedInstanceState) {
    mFragments.attachHost(null /*parent*/);
}

FragmentController.java
-----------------------

public void attachHost(Fragment parent) {
    mHost.mFragmentManager.attachController(mHost, mHost, parent);
}

</code></pre>
<p>而第一种情况，<code>attachController()</code>传入参数为<code>Fragment</code>，在<code>Fragment</code>的<code>performAttach()</code>中调用：</p>
<pre><code>Fragment.java
-------------

void performAttach() {
    mChildFragmentManager.attachController(mHost, new FragmentContainer(), this)
}

</code></pre>
<p>…<br>
解决了<code>FragmentManagerViewModel</code>的来源，下面看看它的作用。<br>
上文提到，<code>FragmentManagerViewModel</code>是一个<code>VM</code>，实际上可以联想到可能是通过<code>Activity</code>的<code>ViewModelStore</code>，使用相同的<code>NonConfigurationInstances</code>机制实现的恢复。</p>
<p>先看第二种情况：</p>
<pre><code>FragmentManager.java
--------------------

ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);

</code></pre>
<p>其中的<code>host</code>为<code>FragmentActivity$HostCallbacks</code>，而<code>getViewModelStore()</code>返回的实际上是<code>FragmentActivity</code>的<code>ViewModelStore</code>：</p>
<pre><code>FragmentActivity$HostCallbacks.java
-----------------------------------

public ViewModelStore getViewModelStore() {
    return FragmentActivity.this.getViewModelStore();
}

</code></pre>
<p>而<code>FragmentManagerViewModel.getInstance()</code>内部实际上是通过<code>ViewModelProvider</code>返回一个本类<code>VM</code>实例：</p>
<pre><code>FragmentManagerViewModel .java
------------------------------

static FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) {
    ViewModelProvider viewModelProvider = 
                new ViewModelProvider(viewModelStore, FACTORY);
    return viewModelProvider.get(FragmentManagerViewModel.class);
}

</code></pre>
<p>由于<code>VM</code>在创建时，会被储存到对应的<code>ViewModelStore</code>，所以该<code>VM</code>会存放到<code>FragmentActivity</code>的<code>ViewModelStore</code>中。</p>
<p>第一种情况：<br>
实际上是顶级<code>FragmentManager</code>的<code>FragmentManagerViewModel</code>中，维护一个子级的<code>FragmentManagerViewModel</code>仓库，然后通过顶级<code>FragmentManagerViewModel</code>直接维护所有子级<code>FragmentManagerViewModel</code>。</p>
<pre><code>FragmentManagerViewModel .java
------------------------------

private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();

FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
    FragmentManagerViewModel childNonConfig = mChildNonConfigs.get(f.mWho);
    if (childNonConfig == null) {
        childNonConfig = new FragmentManagerViewModel(mStateAutomaticallySaved);
        mChildNonConfigs.put(f.mWho, childNonConfig);
    }
    return childNonConfig;
}

</code></pre>
<p>…<br>
从以上源码中可以看出，<code>Fragment</code>的横竖屏切换恢复机制实际上是：</p>
<ul>
<li><strong>通过一个持有自身<code>ViewModelStore</code>引用的<code>VM</code>，依附到<code>Activity</code>的<code>ViewModelStore</code>中，通过<code>Activity</code>的机制进行恢复。</strong></li>
</ul>
<p>其实这里引申一点的是，源码中提及到，<code>NonConfigurationInstances</code>机制有可能在调用<code>getLastNonConfigurationInstance</code>时返回<code>null</code>，如需确保横竖屏切换时的数据保存，可以使用<code>Fragment</code>的<code>onSaveInstanceState(true)</code>，以<code>Fragment</code>作为保存数据的容器。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTNiZDU0NzhlZmExNTFmNzQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTU1L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>而事实上，在旧版的ViewModel中，确实是通过<code>Fragment</code>的<code>onSaveInstanceState(true)</code>进行的。</p>
<hr>
<ul>
<li><strong>ViewModel 的后台销毁恢复机制：</strong></li>
</ul>
<p>前文提到，<code>SavedStateViewModelFactory</code>是实现该机制的一部分，由<code>SavedStateViewModelFactory</code>生成的<code>VM</code>才具有在后台销毁前后通过<code>SavedStateHandle</code>存取数据的特性。</p>
<hr>
<p>先看<code>SavedStateViewModelFactory</code>的构造方法：</p>
<pre><code>SavedStateViewModelFactory.java
-------------------------------

public SavedStateViewModelFactory(Application application,
                                  SavedStateRegistryOwner owner,
                                  Bundle defaultArgs) {

    mSavedStateRegistry = owner.getSavedStateRegistry();
    mLifecycle = owner.getLifecycle();
    mDefaultArgs = defaultArgs;
    mApplication = application;
    mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);
}

</code></pre>
<p><code>SavedStateViewModelFactory</code>在<code>ComponentActivity</code>中实例化传入的参数为：</p>
<pre><code>ComponentActivity.java
----------------------

mDefaultFactory = new SavedStateViewModelFactory(
                            getApplication(), 
                            this, 
                            getIntent() != null ? getIntent().getExtras() : null);

</code></pre>
<p><code>ComponentActivity</code>实现了<code>SavedStateRegistryOwner</code>接口，该接口的实现类可以提供<code>SavedStateRegistry</code>实例。</p>
<hr>
<p><code>SavedStateRegistry</code>即是流程的关键对象之一。<br>
这里涉及到androidx提供的一个新的组件<code>androidx.savedstate</code>：“该组件允许以插件方式，将组件添加到<code>SaveInstanceState</code>过程中”。</p>
<p>个人理解：<br>
这是一套针对SavedState操作Bundle的封装工具，但<strong>仅适用于系统</strong>实现。<br>
因为流程繁琐，系统源码在实现的过程中还包含了自动重建，自动还原数据，生命周期确保等一系列操作。<br>
而且当你实现关键的<code>SavedStateProvider</code>接口时，同样要编写Bundle，这和传统的<code>onSaveInstanceState()</code>区别不大。<br>
因为系统实现了对<code>VM</code>提供的存取操作，建议直接使用<code>VM</code>，或者直接在<code>onSaveInstanceState()</code>对数据进行操作。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLThhZTBjMzEwNTFmZTJkNjAucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvOTA3L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<ul>
<li>链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fsavedstate%3Fhl%3Dzh-cn" rel="nofollow">https://developer.android.google.cn/jetpack/androidx/releases/savedstate?hl=zh-cn</a></li>
</ul>
<p>我后面有空会另行写一篇文章去讨论系统对该组件的实现。</p>
<hr>
<p><code>ComponentActivity</code>实例化时，创建成员<code>SavedStateRegistryController</code>，后者实例化时，创建成员<code>SavedStateRegistry</code>：</p>
<pre><code>ComponentActivity.java
----------------------

private final SavedStateRegistryController mSavedStateRegistryController =
                SavedStateRegistryController.create(this);

SavedStateRegistryController.java
---------------------------------

public static SavedStateRegistryController create(SavedStateRegistryOwner owner) {
    return new SavedStateRegistryController(owner);
}

private SavedStateRegistryController(SavedStateRegistryOwner owner) {
    mOwner = owner;
    mRegistry = new SavedStateRegistry();
}

</code></pre>
<p><code>ComponentActivity</code>在<code>onSaveInstanceState()</code>中调用<code>SavedStateRegistryController.performSave()</code>，内部实际调用<code>SavedStateRegistry.performSave()</code>：</p>
<pre><code>ComponentActivity.java
----------------------

protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    mSavedStateRegistryController.performSave(outState);
}

SavedStateRegistryController.java
---------------------------------

public void performSave(Bundle outBundle) {
    mRegistry.performSave(outBundle);
}

</code></pre>
<p><code>SavedStateRegistry</code>会把所有注册到自身的<code>SavedStateProvider</code>，通过<code>saveState()</code>提取数据，并保存到一个<code>Bundle</code>中：</p>
<pre><code>SavedStateRegistry.java
-----------------------

void performSave(@NonNull Bundle outBundle) {
    Bundle components = new Bundle();
    for (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = 
                    mComponents.iteratorWithAdditions(); it.hasNext(); ) {

        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();
        components.putBundle(entry1.getKey(), entry1.getValue().saveState());
    }
    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);
}

</code></pre>
<p>至此，说明数据保存的发起，最终通知到<code>SavedStateRegistry</code>。</p>
<hr>
<p>先看<code>SavedStateProvider</code>接口：</p>
<p>注册到<code>SavedStateRegistry</code>中实现类，会在<code>SavedStateRegistry</code>保存过程将会调用<code>saveState()</code>获取数据。<br>
而稍后(在恢复数据时)，将会通过<code>SavedStateRegistry.consumeRestoredStateForKey()</code>取出保存的数据。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTUwZmI2YjJmZDE3OTU5NGUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTY3L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p><code>SavedStateProvider</code>通过<code>SavedStateRegistry.registerSavedStateProvider()</code>注册到<code>SavedStateRegistry</code>：</p>
<pre><code>SavedStateRegistry.java
-----------------------

public void registerSavedStateProvider(String key, SavedStateProvider provider) {
    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);
    if (previous != null) {
        throw new IllegalArgumentException(
                "SavedStateProvider with the given key is already registered");
    }
}

</code></pre>
<p>到此，说明储存数据的提供者，是注册到<code>SavedStateRegistry</code>中的<code>SavedStateProvider</code>。</p>
<hr>
<p>前文提及，<code>VM</code>的存取核心是<code>SavedStateHandle</code>，那么说明<code>SavedStateProvider</code>和<code>SavedStateHandle</code>存在必然的关联。<br>
实际上，<code>SavedStateHandle</code>实例中，维护一个<code>SavedStateProvider</code>匿名内部类实例，而<code>SavedStateHandle</code>的读写和<code>SavedStateProvider</code>实例的数据读取操作，都是对实际数据容器<code>mRegular</code>读写。</p>
<p>先看<code>SavedStateHandle</code>：</p>
<ul>
<li>
<p>前文提到，最终该机制的实现，实际为<code>SaveInstanceState</code>机制，则反映<code>VM</code>并不会对数据进行自动存取。<br>
事实上<code>VM</code>确实需要手动将后台销毁前保存的数据放到<code>SaveInstanceState</code>中，<code>SavedStateHandle</code>确实是这么用的，所以提供了一系列的<code>get</code>/<code>set</code>操作，而最终还要编写<code>SavedStateProvider</code>的<code>Bundle</code>转换操作。</p>
</li>
<li>
<p>同时可以看出，<code>SavedStateHandle</code>提供了对<code>LiveData</code>的存取支持。<br>
<code>SavedStateHandle</code>对<code>LiveData</code>的支持，来自对<code>LiveData</code>的内部的静态包装类<code>SavingStateLiveData</code>。<br>
<code>SavingStateLiveData</code>包装了<code>setValue()</code>，传入的参数会被优先储存到<code>mRegular</code>中。</p>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLWYwMDkwOGU2NTdiMjUxZDAucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvODk1L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<ul>
<li>链接 ：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.google.cn%2Freference%2Fandroidx%2Flifecycle%2FSavedStateHandle%3Fhl%3Dzh-cn" rel="nofollow">https://developer.android.google.cn/reference/androidx/lifecycle/SavedStateHandle?hl=zh-cn</a></li>
</ul>
<p>用于提取数据的<code>SavedStateProvider</code>：</p>
<p>需要编写<code>SavedStateProvider</code>数据的<code>Bundle</code>转换操作。<br>
所以如无必要，无需自定义该组件，建议在<code>onSaveInstanceState()</code>中直接操作。</p>
<pre><code>SavedStateHandle.java
---------------------

// 最终的数据容器主体
// initialState为构造时参入的上次SavedInstanceState产生的旧数据
// 既 SavedStateHandle.createHandle 时传入的参数，下面会说明
final Map&lt;String, Object&gt; mRegular = new HashMap&lt;&gt;(initialState);

// SavedStateProvider 对数据主体 mRegular 进行处理并生成一个Bundle
private final SavedStateProvider mSavedStateProvider = new SavedStateProvider() {
        public Bundle saveState() {
            Set&lt;String&gt; keySet = mRegular.keySet();
            ArrayList keys = new ArrayList(keySet.size());
            ArrayList value = new ArrayList(keys.size());
            for (String key : keySet) {
                keys.add(key);
                value.add(mRegular.get(key));
            }
            Bundle res = new Bundle();
            // "parcelable" arraylists - lol
            res.putParcelableArrayList("keys", keys);
            res.putParcelableArrayList("values", value);
            return res;
        }
};

</code></pre>
<p>至此，<code>SavedStateHandle</code>和<code>SavedStateProvider</code>实现关联。</p>
<hr>
<p>前文提及，<code>SavedStateProvider</code>通过<code>SavedStateRegistry.registerSavedStateProvider()</code>注册到<code>SavedStateRegistry</code>：</p>
<p>而该方法的调用，则是通过<code>SavedStateHandleController</code>进行的。<br>
<code>SavedStateHandleController</code>的实例化则是通过<code>SavedStateViewModelFactory</code>进行的，最终回到了<code>SavedStateViewModelFactory</code>。</p>
<p>先看<code>SavedStateViewModelFactory</code>：</p>
<p>通过调用<code>SavedStateHandleController.create()</code>返回<code>SavedStateHandleController</code>实例。<br>
同时，<code>VM</code>在创建时，传入了<code>SavedStateHandleController</code>的<code>SavedStateHandle</code>实例作为参数，即<code>VM</code>和<code>SavedStateHandle</code>进行了绑定。</p>
<pre><code>SavedStateViewModelFactory.java
-------------------------------

public &lt;T extends ViewModel&gt; T create(String key, Class&lt;T&gt; modelClass) {

    // 判断是否是AVM
    boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);
    Constructor&lt;T&gt; constructor;
    if (isAndroidViewModel) {
        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);
    } else {
        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);
    }

    // 如果不需要SavedStateHandle，则直接创建一个普通的VM/AVM
    if (constructor == null) {
        return mFactory.create(modelClass);
    }

    // 创建了 SavedStateHandleController 
    SavedStateHandleController controller = SavedStateHandleController.create(
                                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);

    // VM 在创建的时候持有了SavedStateHandleController内维护的SavedStateHandle对象
    try {
        T viewmodel;
        if (isAndroidViewModel) {
            viewmodel = constructor.newInstance(mApplication, controller.getHandle());
        } else {
            viewmodel = constructor.newInstance(controller.getHandle());
        }
        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);
        return viewmodel;
        ...
}

</code></pre>
<p>再看<code>SavedStateHandleController .create()</code>：</p>
<p><code>SavedStateHandle</code>在实例化时，通过<code>consumeRestoredStateForKey()</code>传入上次保存的数据，此时<code>SavedStateHandle</code>数据已完成恢复。<br>
<code>SavedStateHandleController</code>创建后，通过<code>attachToLifecycle()</code>方法，在方法内部将<code>SavedStateHandle</code>维护的<code>SavedStateProvider</code>注册到<code>SavedStateRegistry</code>。</p>
<p>前面说到<code>SavedStateViewModelFactory</code>是框架骨架之一，实际就是通过这个过程，最终允许<code>VM</code>能够把数据的存取加入到<code>SaveInstanceState</code>流程。</p>
<pre><code>SavedStateHandleController.java
-------------------------------

static SavedStateHandleController create(SavedStateRegistry registry, 
                      Lifecycle lifecycle, String key, Bundle defaultArgs) {

    // 通过consumeRestoredStateForKey获取前次状态
    Bundle restoredState = registry.consumeRestoredStateForKey(key);
    // 创建一个Handle
    SavedStateHandle handle = 
                SavedStateHandle.createHandle(restoredState, defaultArgs);

    // 生成SavedStateHandleController实例
    SavedStateHandleController controller = 
                new SavedStateHandleController(key, handle);

    // 这里进行了绑定
    controller.attachToLifecycle(registry, lifecycle);
    tryToAddRecreator(registry, lifecycle);
    return controller;
}

void attachToLifecycle(SavedStateRegistry registry, Lifecycle lifecycle) {
    registry.registerSavedStateProvider(mKey, mHandle.savedStateProvider());
}

</code></pre>
<p>至此，<code>SavedStateProvider</code>和<code>SavedStateRegistry</code>实现关联。</p>
<hr>
<p>以上就是整个保存流程的概况，而还原流程差距不大，只是在<code>onCreate()</code>中调用<code>SavedStateRegistryController.performRestore()</code>，最终通知<code>SavedStateRegistry</code>在<code>Bundle</code>中恢复设置的数据。</p>
<hr>
<p>忽略<code>SavedStateHandleController</code>对<code>VM</code>的确保机制 (包含<code>Recreator</code>)，最后总结：</p>
<ul>
<li>
<h2><a id="_810"></a>简化称呼以缩短阅读量：</h2>
<h2><a id="VM
ViewModel__VM
SavedStateViewModelFactory__Factory_812"></a>VM组：<br>
<code>ViewModel</code> = <code>VM</code><br>
<code>SavedStateViewModelFactory</code> = <code>Factory</code></h2>
<h2><a id="Registry
SavedStateRegistryController__RegistryController
SavedStateRegistry__Registry_816"></a>Registry组：<br>
<code>SavedStateRegistryController</code> = <code>RegistryController</code><br>
<code>SavedStateRegistry</code> = <code>Registry</code></h2>
<h2><a id="Handle
SavedStateHandleController__HandleController
SavedStateHandle__Handle_820"></a>Handle组：<br>
<code>SavedStateHandleController</code> = <code>HandleController</code><br>
<code>SavedStateHandle</code> = <code>Handle</code></h2>
<h2><a id="Provider
SavedStateProvider__Provider_824"></a>Provider组：<br>
<code>SavedStateProvider</code> = <code>Provider</code></h2>
</li>
<li>
<p>初始化阶段：<br>
<code>ComponentActivity</code>创建了<code>RegistryController</code>实例<br>
<code>RegistryController</code>创建了内部的<code>Registry</code>实例<br>
<code>ComponentActivity</code>创建了<code>Factory</code>，并传入<code>RegistryController</code>维护的<code>Registry</code></p>
</li>
<li>
<p>恢复阶段<br>
<code>ComponentActivity</code>在<code>onCreate</code>调用<code>RegistryController</code>的<code>performRestore</code><br>
<code>RegistryController</code>的<code>performRestore</code>中，调用<code>Registry</code>的<code>performRestore</code><br>
<code>Registry</code>的<code>performRestore</code>中，把数据从<code>savedInstanceState (Bundle)</code>取出，并储存到<code>mRestoredState</code>中<br>
<em><strong>在此处<code>Registry</code>已把数据恢复</strong></em></p>
</li>
<li>
<p>VM生成阶段：<br>
<code>VM</code>需要通过<code>Factory</code>创建，创建过程：<br>
– 创建<code>VM</code>对应的<code>HandleController</code>实例，创建过程：<br>
------ 通过<code>Registry</code>的<code>consumeRestoredStateForKey</code>把数据取出生成<code>Handle</code><br>
------ <code>Handle</code>内部维护一个<code>Provider</code>实例，共享数据容器<code>mRegular</code><br>
------ <code>HandleController</code>被注入<code>Handle</code><br>
------ <code>Provider</code>绑定到<code>Registry</code><br>
------ <em><strong>在此处实现了 (<code>RegistryController</code>-<code>Registry</code>-<code>Provider</code>-<code>Handle</code>) 绑定</strong></em><br>
–<code>VM</code>被<code>Factory</code>注入<code>Handle</code><br>
–<em><strong>在此处实现了 (<code>RegistryController</code>-<code>Registry</code>-<code>Provider</code>-<code>Handle-VM</code>) 绑定</strong></em><br>
–***<code>VM</code>数据最终通过<code>Registry</code>恢复***</p>
</li>
<li>
<p>写数据阶段<br>
<code>VM</code>读写的数据最终存放到<code>Handle</code>的<code>mRegular</code>中<br>
<em><strong><code>VM</code>数据最终通过<code>Registry</code>保存</strong></em></p>
</li>
<li>
<p>保存阶段<br>
<code>ComponentActivity</code>在<code>onSaveInstanceState</code>调用<code>RegistryController</code>的<code>performSave</code><br>
<code>RegistryController</code>的<code>performSave</code>中，调用<code>Registry</code>的<code>performSave</code><br>
<code>Registry</code>的<code>performSave</code>中，将所有注册的<code>Provider</code>数据打包成一个<code>Bundle</code>保存到<code>onSaveInstanceState</code>的<code>Bundle</code>中<br>
<em><strong>在此处<code>Registry</code>已把数据保存</strong></em></p>
</li>
</ul>
<p>作者：七零八落问号<br>
链接：https://www.jianshu.com/p/4a65ee05e6a1</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style>
</head>
<body>
<div style="width:852px;margin:0 auto;">
<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article">看完这篇文章，LiveData的用法竟然还可以这样用？</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                    <span class="article-type type-1 float-left">原创</span>                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weixin_43901866" target="_blank" rel="noopener">Android Developer</a>
                    <span class="time">最后发布于2020-03-10 14:48:43                    </span>
                    <span class="read-count">阅读数 16</span>
                    <a id='blog_detail_zk_collection' class="un-collection" data-report-click='{"mod":"popu_823"}'>
                        <svg class="icon">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg>
                        <span>收藏</span>
                    </a>
                                    </div>
                                <div class="up-time">发布于2020-03-10 14:48:43</div>
                <div class="slide-content-box">
                                                        <div class="tags-box artic-tag-box">
                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener"
                                      href="https://blog.csdn.net/weixin_43901866/category_9790707.html">
                                       livedata                                   </a>
                                                                                  </div>
                                                                                                           <div class="article-copyright">
                        <span class="creativecommons">
                            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            <span>
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </span>
                            <div class="article-source-link2222">
                                本文链接：<a href="https://blog.csdn.net/weixin_43901866/article/details/104774479">https://blog.csdn.net/weixin_43901866/article/details/104774479</a>
                            </div>
                        </span> 
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">展开</a>
                                    </div>
            </div>
        </div>
    </div>
    <article class="baidu_pl">
        <!--python安装手册开始-->
                <!--python安装手册结束-->
                <!--####专栏广告位图文切换开始-->
                                    <!--####专栏广告位图文切换结束-->
         <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" />
                            <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p>本文主要内容：</p>
<ol>
<li>作用介绍</li>
<li>核心类介绍</li>
<li>基本使用</li>
<li>源码分析<br>
– 横竖屏切换恢复<br>
– 后台销毁恢复</li>
</ol>
<hr>
<h3><a id="ViewModel_11"></a>ViewModel的主要工作：</h3>
<p>本身主要是一个数据维护工具<br>
将数据维护的工作从<code>Activity</code>上剥离，提供一个储存数据环境，自身机制可以解决开发中，数据受<code>Activity</code>生命周期影响产生数据丢失的问题 (主要为横竖屏切换以及在后台被销毁)。<br>
通常结合<code>LiveData</code>使用。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTMzYzlmMTkwMTQxM2JkNDEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTIyL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>作为一个纯数据维护工具，可以加入到<code>MVP</code>架构中负责数据保存。<br>
而官方推选作为<code>AAC</code>架构<code>MVVM</code>中的<code>VM</code>层。</p>
<hr>
<h3><a id="ViewModel_24"></a>ViewModel的主要类：</h3>
<ul>
<li>
<p><code>ViewModel (下称VM)</code>：<br>
数据储存类，架构的核心类。<br>
使用时，直接继承该类，根据需求选择重写<code>onCleared()</code>方法。<br>
如需在<code>Activity</code>被系统销毁后依然保存数据，定义一个参数为<code>(SavedStateHandle)</code>的构造方法，并将数据保存<code>SavedStateHandle</code>中。<br>
<em>实际上通过<code>SavedInstanceState</code>存取</em></p>
</li>
<li>
<p><code>AndroidViewModel</code>：<br>
<code>VM</code>子类，维护了<code>Application</code>的引用，由架构中的<code>SavedStateViewModelFactory</code>创建时传入。<br>
同样，需要接收<code>SavedStateHandle</code>时，需要定义参数为 <code>(Application, SavedStateHandle)</code>的构造方法。</p>
</li>
<li>
<p><code>ViewModelStore</code>：<br>
用于保存<code>VM</code>，内部维护了一个用于储存<code>VM</code>的<code>HashMap</code>。<br>
一般情况下，直接使用本类创建实例。</p>
</li>
<li>
<p><code>ViewModelStoreOwner</code>：<br>
接口，实现该接口的类，表示自身能够向外提供<code>VM</code>。<br>
androidx 的<code>AppCompatActivity</code>/<code>Fragment</code>实现了该接口。</p>
</li>
<li>
<p><code>ViewModelProvider</code>：<br>
<code>VM</code>的提供者，获取<code>VM</code>的基本入口。<br>
实际依赖<code>ViewModelStore</code>存取<code>VM</code>，<code>Factory</code>生成/恢复<code>VM</code>。</p>
</li>
<li>
<p><code>Factory</code>：<br>
接口，实现该接口的类主要用于创建<code>VM</code>实例。<br>
不建议直接实现该接口，除非你清楚框架内容和自己的需求。<br>
一般情况下，如果无需<code>SavedStateHandle</code>机制，可以使用<code>AndroidViewModelFactory</code>。<br>
否则应该使用或继承<code>SavedStateViewModelFactory</code>。</p>
</li>
</ul>
<hr>
<h3><a id="ViewModel_56"></a>ViewModel的基本使用：</h3>
<ul>
<li><strong>一般使用：</strong></li>
</ul>
<pre><code>// VM
class ViewModelA : ViewModel()
// AVM
class ViewModelB(app: Application) : AndroidViewModel(app)

// Activity/Fragment .onCreate中
override fun onCreate() {
  ...
  val provider = ViewModelProvider(this)
  val vmA = provider.get(ViewModelA::class.java)
  val vmB = provider.get(ViewModelB::class.java)
  ...
}

</code></pre>
<ul>
<li><strong>接受 SavedStateHandle</strong></li>
</ul>
<pre><code>// VM
class ViewModelC(
        val handle: SavedStateHandle
) : ViewModel()

// AVM
class ViewModelD(
        app: Application, 
        val handle: SavedStateHandle
) : AndroidViewModel(app)

</code></pre>
<ul>
<li><strong>跨 Fragment 共享数据</strong><br>
Fragment中直接以Activity作为ViewModel的Key</li>
</ul>
<pre><code>...
val provider = ViewModelProvider(requireActivity())
val vmA = provider.get(ViewModelA::class.java)

</code></pre>
<ul>
<li><strong>通过 Application 创建全局共享的 VM</strong></li>
</ul>
<pre><code>class App : Application(), ViewModelStoreOwner {
    private lateinit var mAppViewModelStore: ViewModelStore
    private lateinit var mFactory: ViewModelProvider.Factory

    override fun onCreate() {
        super.onCreate()
        mAppViewModelStore = ViewModelStore()
        mFactory = ViewModelProvider
                      .AndroidViewModelFactory
                      .getInstance(this)
    }

    override fun getViewModelStore(): ViewModelStore {
        return mAppViewModelStore
    }

    private fun getAppFactory(): ViewModelProvider.Factory {
        return mFactory
    }

    fun getAppViewModelProvider(activity: Activity): ViewModelProvider {
        val app = checkApplication(activity) as App
        return ViewModelProvider(app, app.getAppFactory())
    }

    fun getAppViewModelProvider(fragment: Fragment): ViewModelProvider {
        return getAppViewModelProvider(fragment.requireActivity())
    }

    private fun checkApplication(activity: Activity): Application {
        return activity.application
                ?: throw IllegalStateException(
                      "Your activity is not yet attached to the Application instance." + 
                      "You can't request ViewModel before onCreate call.")
    }
}

</code></pre>
<hr>
<h3><a id="ViewModel_147"></a>ViewModel的关键源码分析：</h3>
<p><em><strong>以下源码分析将会去除非相关代码以简化</strong></em></p>
<ul>
<li><strong>ViewModelProvider 实现相关：</strong></li>
</ul>
<p>前面提到，<code>ViewModelProvider</code>的工作完全依赖传入的<code>ViewModelStore</code>和<code>Factory</code>，可以直接从构造方法得知：</p>
<pre><code>ViewModelProvider.java
----------------------

private final Factory mFactory;
private final ViewModelStore mViewModelStore;

public ViewModelProvider(ViewModelStoreOwner owner) {
  this(owner.getViewModelStore(), 
        owner instanceof HasDefaultViewModelProviderFactory
        ? ((HasDefaultViewModelProviderFactory) owner)
            .getDefaultViewModelProviderFactory()
        : NewInstanceFactory.getInstance());
}

public ViewModelProvider(ViewModelStoreOwner owner, Factory factory) {
    this(owner.getViewModelStore(), factory);
}

public ViewModelProvider(ViewModelStore store, Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}

// 简单的反射创建实例的工厂
public static class NewInstanceFactory implements Factory {
    public &lt;T extends ViewModel&gt; T create(Class&lt;T&gt; modelClass) {
        return modelClass.newInstance()
    }
}

</code></pre>
<p>而<code>androidx.activity.ComponentActivity</code>，<code>androidx.fragment.app.Fragment</code>都实现了<code>ViewModelStoreOwner</code>，<code>HasDefaultViewModelProviderFactory</code>接口。</p>
<pre><code>public class AppCompatActivity extends FragmentActivity...{}
public class FragmentActivity extends ComponentActivity...{}

public class ComponentActivity extends ... implements
        ViewModelStoreOwner,
        HasDefaultViewModelProviderFactory,
        SavedStateRegistryOwner ... {}

public class Fragment implements 
        ViewModelStoreOwner, 
        HasDefaultViewModelProviderFactory, 
        SavedStateRegistryOwner ... {}

</code></pre>
<p><code>ViewModelProvider</code>的<code>get()</code>方法中返回<code>VM</code>实例，其中<code>mFactory</code>为 <code>SavedStateViewModelFactory</code>：</p>
<pre><code>ViewModelProvider.java
----------------------

private static final String DEFAULT_KEY 
      = "androidx.lifecycle.ViewModelProvider.DefaultKey";

public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) {
    String canonicalName = modelClass.getCanonicalName();
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}

public &lt;T extends ViewModel&gt; T get(String key, Class&lt;T&gt; modelClass) {
    ViewModel viewModel = mViewModelStore.get(key);

    // 一个确保机制
    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    }

    // 正常以及基本的逻辑
    if (mFactory instanceof KeyedFactory) {
        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);
    } else {
        viewModel = (mFactory).create(modelClass);
    }

    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}

</code></pre>
<p><code>SavedStateViewModelFactory</code>在后面解析。</p>
<hr>
<ul>
<li><strong>ViewModel 的屏幕横竖屏切换恢复机制：</strong></li>
</ul>
<p>前面说到，创建<code>VM</code>是通过<code>ViewModelProvider</code>实现的，而<code>ViewModelProvider</code>又是依赖<code>ViewModelStore</code>进行<code>VM</code>的保存。<br>
当使用<code>ComponentActivity</code>/<code>Fragment</code>作为<code>ViewModelProvider</code>的初始化参数时，实际<code>VM</code>的储存容器是参数提供的。</p>
<ol>
<li><strong>ComponentActivity 实现：</strong></li>
</ol>
<p>从源码中，可以看出横竖屏切换是直接通过<code>NonConfigurationInstances</code>进行恢复的。</p>
<p><code>ComponentActivity</code>包含一个<code>NonConfigurationInstances</code>类，其中持有<code>ViewModelStore</code>的引用：</p>
<pre><code>ComponentActivity.java
----------------------

static final class NonConfigurationInstances {
    Object custom;
    ViewModelStore viewModelStore;
}

</code></pre>
<p>保存<code>ViewModelStore</code>：<br>
通过<code>onRetainNonConfigurationInstance()</code>在横竖屏切换中保存<code>ViewModelStore</code></p>
<pre><code>ComponentActivity.java
----------------------

public final Object onRetainNonConfigurationInstance() {
    Object custom = onRetainCustomNonConfigurationInstance();

    // 从上一个 NonConfigurationInstances 中恢复 ViewModelStore
    ViewModelStore viewModelStore = mViewModelStore;
    if (viewModelStore == null) {
        NonConfigurationInstances nc = 
                (NonConfigurationInstances) getLastNonConfigurationInstance();

        if (nc != null) {
            viewModelStore = nc.viewModelStore;
        }
    }

    if (viewModelStore == null &amp;&amp; custom == null) {
        return null;
    }

    // 保存当前 ViewModelStore
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.custom = custom;
    nci.viewModelStore = viewModelStore;
    return nci;
}

</code></pre>
<p>在使用时尝试通过<code>getLastNonConfigurationInstance()</code>恢复<code>ViewModelStore</code>：</p>
<pre><code>ComponentActivity.java
----------------------

public ViewModelStore getViewModelStore() {
    if (mViewModelStore == null) {
        NonConfigurationInstances nc = 
                (NonConfigurationInstances) getLastNonConfigurationInstance();

        if (nc != null) {
            // 通过 NonConfigurationInstances 对象直接恢复 ViewModelStore
            mViewModelStore = nc.viewModelStore;
        }
        if (mViewModelStore == null) {
            mViewModelStore = new ViewModelStore();
        }
    }
    return mViewModelStore;
}

</code></pre>
<ol start="2">
<li><strong>Fragment 实现：</strong></li>
</ol>
<p>要看懂该部分源码，需要对FragmentManager有基础了解，参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fazurelaker%2Farticle%2Fdetails%2F84310053" rel="nofollow">深入理解FragmentManager</a></p>
<p><code>Fragment</code>的<code>ViewModelStore</code>由<code>FragmentManager</code>维护的<code>FragmentManagerViewModel</code>管理。</p>
<ul>
<li><strong>注意这里使用了一个<code>VM</code>来维护一个<code>ViewModelStore</code></strong></li>
</ul>
<pre><code>Fragment.java
-------------

public ViewModelStore getViewModelStore() {
    return mFragmentManager.getViewModelStore(this);
}

FragmentManager.java
--------------------

private FragmentManagerViewModel mNonConfig;

ViewModelStore getViewModelStore(Fragment f) {
    return mNonConfig.getViewModelStore(f);
}

</code></pre>
<p>处理<code>FragmentManagerViewModel</code>的实例化：</p>
<pre><code>FragmentManager.java
--------------------

void attachController(FragmentHostCallback&lt;?&gt; host, 
                      FragmentContainer container,
                      final Fragment parent) {
    mHost = host;
    mParent = parent;

    if (parent != null) {
        // 从父类的FM中获取
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        // 假如 host 对象是实现了 ViewModelStoreOwner
        // 则使用这个ViewModelStoreOwner的viewModelStore创建一个 FragmentManagerViewModel
        ViewModelStore viewModelStore = 
                ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        // 生成一个不支持自动保存ViewModel的 FragmentManagerViewModel
        mNonConfig = new FragmentManagerViewModel(false);
    }
}

</code></pre>
<p>但从源码注释可以了解到，第三种情况已废弃，理想情况下并不支持。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTczMzUxNmFkZjY4NWM0MjEucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNjAxL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>所以基本上，出现的应该为第一、第二种情况。</p>
<p><code>host</code>对象实际是实现的<code>ViewModelStoreOwner</code>接口的<code>FragmentActivity$HostCallbacks</code>：</p>
<pre><code>FragmentActivity.java
---------------------

class HostCallbacks 
            extends FragmentHostCallback&lt;FragmentActivity&gt; 
            implements ViewModelStoreOwner ... {...}

</code></pre>
<p>第二种情况，<code>attachController()</code>传入参数为null，可以理解为直接附着在<code>FragmentActivity</code>上的<code>Fragment</code>:</p>
<pre><code>FragmentActivity.java
---------------------

protected void onCreate(@Nullable Bundle savedInstanceState) {
    mFragments.attachHost(null /*parent*/);
}

FragmentController.java
-----------------------

public void attachHost(Fragment parent) {
    mHost.mFragmentManager.attachController(mHost, mHost, parent);
}

</code></pre>
<p>而第一种情况，<code>attachController()</code>传入参数为<code>Fragment</code>，在<code>Fragment</code>的<code>performAttach()</code>中调用：</p>
<pre><code>Fragment.java
-------------

void performAttach() {
    mChildFragmentManager.attachController(mHost, new FragmentContainer(), this)
}

</code></pre>
<p>…<br>
解决了<code>FragmentManagerViewModel</code>的来源，下面看看它的作用。<br>
上文提到，<code>FragmentManagerViewModel</code>是一个<code>VM</code>，实际上可以联想到可能是通过<code>Activity</code>的<code>ViewModelStore</code>，使用相同的<code>NonConfigurationInstances</code>机制实现的恢复。</p>
<p>先看第二种情况：</p>
<pre><code>FragmentManager.java
--------------------

ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);

</code></pre>
<p>其中的<code>host</code>为<code>FragmentActivity$HostCallbacks</code>，而<code>getViewModelStore()</code>返回的实际上是<code>FragmentActivity</code>的<code>ViewModelStore</code>：</p>
<pre><code>FragmentActivity$HostCallbacks.java
-----------------------------------

public ViewModelStore getViewModelStore() {
    return FragmentActivity.this.getViewModelStore();
}

</code></pre>
<p>而<code>FragmentManagerViewModel.getInstance()</code>内部实际上是通过<code>ViewModelProvider</code>返回一个本类<code>VM</code>实例：</p>
<pre><code>FragmentManagerViewModel .java
------------------------------

static FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) {
    ViewModelProvider viewModelProvider = 
                new ViewModelProvider(viewModelStore, FACTORY);
    return viewModelProvider.get(FragmentManagerViewModel.class);
}

</code></pre>
<p>由于<code>VM</code>在创建时，会被储存到对应的<code>ViewModelStore</code>，所以该<code>VM</code>会存放到<code>FragmentActivity</code>的<code>ViewModelStore</code>中。</p>
<p>第一种情况：<br>
实际上是顶级<code>FragmentManager</code>的<code>FragmentManagerViewModel</code>中，维护一个子级的<code>FragmentManagerViewModel</code>仓库，然后通过顶级<code>FragmentManagerViewModel</code>直接维护所有子级<code>FragmentManagerViewModel</code>。</p>
<pre><code>FragmentManagerViewModel .java
------------------------------

private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();

FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
    FragmentManagerViewModel childNonConfig = mChildNonConfigs.get(f.mWho);
    if (childNonConfig == null) {
        childNonConfig = new FragmentManagerViewModel(mStateAutomaticallySaved);
        mChildNonConfigs.put(f.mWho, childNonConfig);
    }
    return childNonConfig;
}

</code></pre>
<p>…<br>
从以上源码中可以看出，<code>Fragment</code>的横竖屏切换恢复机制实际上是：</p>
<ul>
<li><strong>通过一个持有自身<code>ViewModelStore</code>引用的<code>VM</code>，依附到<code>Activity</code>的<code>ViewModelStore</code>中，通过<code>Activity</code>的机制进行恢复。</strong></li>
</ul>
<p>其实这里引申一点的是，源码中提及到，<code>NonConfigurationInstances</code>机制有可能在调用<code>getLastNonConfigurationInstance</code>时返回<code>null</code>，如需确保横竖屏切换时的数据保存，可以使用<code>Fragment</code>的<code>onSaveInstanceState(true)</code>，以<code>Fragment</code>作为保存数据的容器。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTNiZDU0NzhlZmExNTFmNzQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTU1L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<p>而事实上，在旧版的ViewModel中，确实是通过<code>Fragment</code>的<code>onSaveInstanceState(true)</code>进行的。</p>
<hr>
<ul>
<li><strong>ViewModel 的后台销毁恢复机制：</strong></li>
</ul>
<p>前文提到，<code>SavedStateViewModelFactory</code>是实现该机制的一部分，由<code>SavedStateViewModelFactory</code>生成的<code>VM</code>才具有在后台销毁前后通过<code>SavedStateHandle</code>存取数据的特性。</p>
<hr>
<p>先看<code>SavedStateViewModelFactory</code>的构造方法：</p>
<pre><code>SavedStateViewModelFactory.java
-------------------------------

public SavedStateViewModelFactory(Application application,
                                  SavedStateRegistryOwner owner,
                                  Bundle defaultArgs) {

    mSavedStateRegistry = owner.getSavedStateRegistry();
    mLifecycle = owner.getLifecycle();
    mDefaultArgs = defaultArgs;
    mApplication = application;
    mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);
}

</code></pre>
<p><code>SavedStateViewModelFactory</code>在<code>ComponentActivity</code>中实例化传入的参数为：</p>
<pre><code>ComponentActivity.java
----------------------

mDefaultFactory = new SavedStateViewModelFactory(
                            getApplication(), 
                            this, 
                            getIntent() != null ? getIntent().getExtras() : null);

</code></pre>
<p><code>ComponentActivity</code>实现了<code>SavedStateRegistryOwner</code>接口，该接口的实现类可以提供<code>SavedStateRegistry</code>实例。</p>
<hr>
<p><code>SavedStateRegistry</code>即是流程的关键对象之一。<br>
这里涉及到androidx提供的一个新的组件<code>androidx.savedstate</code>：“该组件允许以插件方式，将组件添加到<code>SaveInstanceState</code>过程中”。</p>
<p>个人理解：<br>
这是一套针对SavedState操作Bundle的封装工具，但<strong>仅适用于系统</strong>实现。<br>
因为流程繁琐，系统源码在实现的过程中还包含了自动重建，自动还原数据，生命周期确保等一系列操作。<br>
而且当你实现关键的<code>SavedStateProvider</code>接口时，同样要编写Bundle，这和传统的<code>onSaveInstanceState()</code>区别不大。<br>
因为系统实现了对<code>VM</code>提供的存取操作，建议直接使用<code>VM</code>，或者直接在<code>onSaveInstanceState()</code>对数据进行操作。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLThhZTBjMzEwNTFmZTJkNjAucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvOTA3L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<ul>
<li>链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fsavedstate%3Fhl%3Dzh-cn" rel="nofollow">https://developer.android.google.cn/jetpack/androidx/releases/savedstate?hl=zh-cn</a></li>
</ul>
<p>我后面有空会另行写一篇文章去讨论系统对该组件的实现。</p>
<hr>
<p><code>ComponentActivity</code>实例化时，创建成员<code>SavedStateRegistryController</code>，后者实例化时，创建成员<code>SavedStateRegistry</code>：</p>
<pre><code>ComponentActivity.java
----------------------

private final SavedStateRegistryController mSavedStateRegistryController =
                SavedStateRegistryController.create(this);

SavedStateRegistryController.java
---------------------------------

public static SavedStateRegistryController create(SavedStateRegistryOwner owner) {
    return new SavedStateRegistryController(owner);
}

private SavedStateRegistryController(SavedStateRegistryOwner owner) {
    mOwner = owner;
    mRegistry = new SavedStateRegistry();
}

</code></pre>
<p><code>ComponentActivity</code>在<code>onSaveInstanceState()</code>中调用<code>SavedStateRegistryController.performSave()</code>，内部实际调用<code>SavedStateRegistry.performSave()</code>：</p>
<pre><code>ComponentActivity.java
----------------------

protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    mSavedStateRegistryController.performSave(outState);
}

SavedStateRegistryController.java
---------------------------------

public void performSave(Bundle outBundle) {
    mRegistry.performSave(outBundle);
}

</code></pre>
<p><code>SavedStateRegistry</code>会把所有注册到自身的<code>SavedStateProvider</code>，通过<code>saveState()</code>提取数据，并保存到一个<code>Bundle</code>中：</p>
<pre><code>SavedStateRegistry.java
-----------------------

void performSave(@NonNull Bundle outBundle) {
    Bundle components = new Bundle();
    for (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = 
                    mComponents.iteratorWithAdditions(); it.hasNext(); ) {

        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();
        components.putBundle(entry1.getKey(), entry1.getValue().saveState());
    }
    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);
}

</code></pre>
<p>至此，说明数据保存的发起，最终通知到<code>SavedStateRegistry</code>。</p>
<hr>
<p>先看<code>SavedStateProvider</code>接口：</p>
<p>注册到<code>SavedStateRegistry</code>中实现类，会在<code>SavedStateRegistry</code>保存过程将会调用<code>saveState()</code>获取数据。<br>
而稍后(在恢复数据时)，将会通过<code>SavedStateRegistry.consumeRestoredStateForKey()</code>取出保存的数据。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLTUwZmI2YjJmZDE3OTU5NGUucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvNTY3L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt="image"></p>
<p><code>SavedStateProvider</code>通过<code>SavedStateRegistry.registerSavedStateProvider()</code>注册到<code>SavedStateRegistry</code>：</p>
<pre><code>SavedStateRegistry.java
-----------------------

public void registerSavedStateProvider(String key, SavedStateProvider provider) {
    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);
    if (previous != null) {
        throw new IllegalArgumentException(
                "SavedStateProvider with the given key is already registered");
    }
}

</code></pre>
<p>到此，说明储存数据的提供者，是注册到<code>SavedStateRegistry</code>中的<code>SavedStateProvider</code>。</p>
<hr>
<p>前文提及，<code>VM</code>的存取核心是<code>SavedStateHandle</code>，那么说明<code>SavedStateProvider</code>和<code>SavedStateHandle</code>存在必然的关联。<br>
实际上，<code>SavedStateHandle</code>实例中，维护一个<code>SavedStateProvider</code>匿名内部类实例，而<code>SavedStateHandle</code>的读写和<code>SavedStateProvider</code>实例的数据读取操作，都是对实际数据容器<code>mRegular</code>读写。</p>
<p>先看<code>SavedStateHandle</code>：</p>
<ul>
<li>
<p>前文提到，最终该机制的实现，实际为<code>SaveInstanceState</code>机制，则反映<code>VM</code>并不会对数据进行自动存取。<br>
事实上<code>VM</code>确实需要手动将后台销毁前保存的数据放到<code>SaveInstanceState</code>中，<code>SavedStateHandle</code>确实是这么用的，所以提供了一系列的<code>get</code>/<code>set</code>操作，而最终还要编写<code>SavedStateProvider</code>的<code>Bundle</code>转换操作。</p>
</li>
<li>
<p>同时可以看出，<code>SavedStateHandle</code>提供了对<code>LiveData</code>的存取支持。<br>
<code>SavedStateHandle</code>对<code>LiveData</code>的支持，来自对<code>LiveData</code>的内部的静态包装类<code>SavingStateLiveData</code>。<br>
<code>SavingStateLiveData</code>包装了<code>setValue()</code>，传入的参数会被优先储存到<code>mRegular</code>中。</p>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDcyMjUzLWYwMDkwOGU2NTdiMjUxZDAucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvODk1L2Zvcm1hdC93ZWJw?x-oss-process=image/format,png" alt=""></p>
<ul>
<li>链接 ：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.google.cn%2Freference%2Fandroidx%2Flifecycle%2FSavedStateHandle%3Fhl%3Dzh-cn" rel="nofollow">https://developer.android.google.cn/reference/androidx/lifecycle/SavedStateHandle?hl=zh-cn</a></li>
</ul>
<p>用于提取数据的<code>SavedStateProvider</code>：</p>
<p>需要编写<code>SavedStateProvider</code>数据的<code>Bundle</code>转换操作。<br>
所以如无必要，无需自定义该组件，建议在<code>onSaveInstanceState()</code>中直接操作。</p>
<pre><code>SavedStateHandle.java
---------------------

// 最终的数据容器主体
// initialState为构造时参入的上次SavedInstanceState产生的旧数据
// 既 SavedStateHandle.createHandle 时传入的参数，下面会说明
final Map&lt;String, Object&gt; mRegular = new HashMap&lt;&gt;(initialState);

// SavedStateProvider 对数据主体 mRegular 进行处理并生成一个Bundle
private final SavedStateProvider mSavedStateProvider = new SavedStateProvider() {
        public Bundle saveState() {
            Set&lt;String&gt; keySet = mRegular.keySet();
            ArrayList keys = new ArrayList(keySet.size());
            ArrayList value = new ArrayList(keys.size());
            for (String key : keySet) {
                keys.add(key);
                value.add(mRegular.get(key));
            }
            Bundle res = new Bundle();
            // "parcelable" arraylists - lol
            res.putParcelableArrayList("keys", keys);
            res.putParcelableArrayList("values", value);
            return res;
        }
};

</code></pre>
<p>至此，<code>SavedStateHandle</code>和<code>SavedStateProvider</code>实现关联。</p>
<hr>
<p>前文提及，<code>SavedStateProvider</code>通过<code>SavedStateRegistry.registerSavedStateProvider()</code>注册到<code>SavedStateRegistry</code>：</p>
<p>而该方法的调用，则是通过<code>SavedStateHandleController</code>进行的。<br>
<code>SavedStateHandleController</code>的实例化则是通过<code>SavedStateViewModelFactory</code>进行的，最终回到了<code>SavedStateViewModelFactory</code>。</p>
<p>先看<code>SavedStateViewModelFactory</code>：</p>
<p>通过调用<code>SavedStateHandleController.create()</code>返回<code>SavedStateHandleController</code>实例。<br>
同时，<code>VM</code>在创建时，传入了<code>SavedStateHandleController</code>的<code>SavedStateHandle</code>实例作为参数，即<code>VM</code>和<code>SavedStateHandle</code>进行了绑定。</p>
<pre><code>SavedStateViewModelFactory.java
-------------------------------

public &lt;T extends ViewModel&gt; T create(String key, Class&lt;T&gt; modelClass) {

    // 判断是否是AVM
    boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);
    Constructor&lt;T&gt; constructor;
    if (isAndroidViewModel) {
        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);
    } else {
        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);
    }

    // 如果不需要SavedStateHandle，则直接创建一个普通的VM/AVM
    if (constructor == null) {
        return mFactory.create(modelClass);
    }

    // 创建了 SavedStateHandleController 
    SavedStateHandleController controller = SavedStateHandleController.create(
                                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);

    // VM 在创建的时候持有了SavedStateHandleController内维护的SavedStateHandle对象
    try {
        T viewmodel;
        if (isAndroidViewModel) {
            viewmodel = constructor.newInstance(mApplication, controller.getHandle());
        } else {
            viewmodel = constructor.newInstance(controller.getHandle());
        }
        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);
        return viewmodel;
        ...
}

</code></pre>
<p>再看<code>SavedStateHandleController .create()</code>：</p>
<p><code>SavedStateHandle</code>在实例化时，通过<code>consumeRestoredStateForKey()</code>传入上次保存的数据，此时<code>SavedStateHandle</code>数据已完成恢复。<br>
<code>SavedStateHandleController</code>创建后，通过<code>attachToLifecycle()</code>方法，在方法内部将<code>SavedStateHandle</code>维护的<code>SavedStateProvider</code>注册到<code>SavedStateRegistry</code>。</p>
<p>前面说到<code>SavedStateViewModelFactory</code>是框架骨架之一，实际就是通过这个过程，最终允许<code>VM</code>能够把数据的存取加入到<code>SaveInstanceState</code>流程。</p>
<pre><code>SavedStateHandleController.java
-------------------------------

static SavedStateHandleController create(SavedStateRegistry registry, 
                      Lifecycle lifecycle, String key, Bundle defaultArgs) {

    // 通过consumeRestoredStateForKey获取前次状态
    Bundle restoredState = registry.consumeRestoredStateForKey(key);
    // 创建一个Handle
    SavedStateHandle handle = 
                SavedStateHandle.createHandle(restoredState, defaultArgs);

    // 生成SavedStateHandleController实例
    SavedStateHandleController controller = 
                new SavedStateHandleController(key, handle);

    // 这里进行了绑定
    controller.attachToLifecycle(registry, lifecycle);
    tryToAddRecreator(registry, lifecycle);
    return controller;
}

void attachToLifecycle(SavedStateRegistry registry, Lifecycle lifecycle) {
    registry.registerSavedStateProvider(mKey, mHandle.savedStateProvider());
}

</code></pre>
<p>至此，<code>SavedStateProvider</code>和<code>SavedStateRegistry</code>实现关联。</p>
<hr>
<p>以上就是整个保存流程的概况，而还原流程差距不大，只是在<code>onCreate()</code>中调用<code>SavedStateRegistryController.performRestore()</code>，最终通知<code>SavedStateRegistry</code>在<code>Bundle</code>中恢复设置的数据。</p>
<hr>
<p>忽略<code>SavedStateHandleController</code>对<code>VM</code>的确保机制 (包含<code>Recreator</code>)，最后总结：</p>
<ul>
<li>
<h2><a id="_810"></a>简化称呼以缩短阅读量：</h2>
<h2><a id="VM
ViewModel__VM
SavedStateViewModelFactory__Factory_812"></a>VM组：<br>
<code>ViewModel</code> = <code>VM</code><br>
<code>SavedStateViewModelFactory</code> = <code>Factory</code></h2>
<h2><a id="Registry
SavedStateRegistryController__RegistryController
SavedStateRegistry__Registry_816"></a>Registry组：<br>
<code>SavedStateRegistryController</code> = <code>RegistryController</code><br>
<code>SavedStateRegistry</code> = <code>Registry</code></h2>
<h2><a id="Handle
SavedStateHandleController__HandleController
SavedStateHandle__Handle_820"></a>Handle组：<br>
<code>SavedStateHandleController</code> = <code>HandleController</code><br>
<code>SavedStateHandle</code> = <code>Handle</code></h2>
<h2><a id="Provider
SavedStateProvider__Provider_824"></a>Provider组：<br>
<code>SavedStateProvider</code> = <code>Provider</code></h2>
</li>
<li>
<p>初始化阶段：<br>
<code>ComponentActivity</code>创建了<code>RegistryController</code>实例<br>
<code>RegistryController</code>创建了内部的<code>Registry</code>实例<br>
<code>ComponentActivity</code>创建了<code>Factory</code>，并传入<code>RegistryController</code>维护的<code>Registry</code></p>
</li>
<li>
<p>恢复阶段<br>
<code>ComponentActivity</code>在<code>onCreate</code>调用<code>RegistryController</code>的<code>performRestore</code><br>
<code>RegistryController</code>的<code>performRestore</code>中，调用<code>Registry</code>的<code>performRestore</code><br>
<code>Registry</code>的<code>performRestore</code>中，把数据从<code>savedInstanceState (Bundle)</code>取出，并储存到<code>mRestoredState</code>中<br>
<em><strong>在此处<code>Registry</code>已把数据恢复</strong></em></p>
</li>
<li>
<p>VM生成阶段：<br>
<code>VM</code>需要通过<code>Factory</code>创建，创建过程：<br>
– 创建<code>VM</code>对应的<code>HandleController</code>实例，创建过程：<br>
------ 通过<code>Registry</code>的<code>consumeRestoredStateForKey</code>把数据取出生成<code>Handle</code><br>
------ <code>Handle</code>内部维护一个<code>Provider</code>实例，共享数据容器<code>mRegular</code><br>
------ <code>HandleController</code>被注入<code>Handle</code><br>
------ <code>Provider</code>绑定到<code>Registry</code><br>
------ <em><strong>在此处实现了 (<code>RegistryController</code>-<code>Registry</code>-<code>Provider</code>-<code>Handle</code>) 绑定</strong></em><br>
–<code>VM</code>被<code>Factory</code>注入<code>Handle</code><br>
–<em><strong>在此处实现了 (<code>RegistryController</code>-<code>Registry</code>-<code>Provider</code>-<code>Handle-VM</code>) 绑定</strong></em><br>
–***<code>VM</code>数据最终通过<code>Registry</code>恢复***</p>
</li>
<li>
<p>写数据阶段<br>
<code>VM</code>读写的数据最终存放到<code>Handle</code>的<code>mRegular</code>中<br>
<em><strong><code>VM</code>数据最终通过<code>Registry</code>保存</strong></em></p>
</li>
<li>
<p>保存阶段<br>
<code>ComponentActivity</code>在<code>onSaveInstanceState</code>调用<code>RegistryController</code>的<code>performSave</code><br>
<code>RegistryController</code>的<code>performSave</code>中，调用<code>Registry</code>的<code>performSave</code><br>
<code>Registry</code>的<code>performSave</code>中，将所有注册的<code>Provider</code>数据打包成一个<code>Bundle</code>保存到<code>onSaveInstanceState</code>的<code>Bundle</code>中<br>
<em><strong>在此处<code>Registry</code>已把数据保存</strong></em></p>
</li>
</ul>
<p>作者：七零八落问号<br>
链接：https://www.jianshu.com/p/4a65ee05e6a1</p>

                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-60ecaf1f42.css" rel="stylesheet">
                                                <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg class="icon" aria-hidden="true">
                            <use xlink:href="#csdnc-thumbsup"></use>
                        </svg><span class="name">点赞</span>
                        <span class="count"></span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-Collection-G" ></use>
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;" data-report-click='{"mod":"1582594662_002"}'><svg class="icon" aria-hidden="true">
                            <use xlink:href="#icon-csdnc-fenxiang"></use>
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg t="1575545411852" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5717" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M179.176 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5718"></path><path d="M509.684 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5719"></path><path d="M846.175 499.222m-113.245 0a113.245 113.245 0 1 0 226.49 0 113.245 113.245 0 1 0-226.49 0Z" p-id="5720"></path></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/weixin_43901866">
                    <img src="https://profile.csdnimg.cn/8/2/E/3_weixin_43901866" class="avatar_pic" username='weixin_43901866'>
                                            <img src="https://g.csdnimg.cn/static/user-reg-year/1x/1.png" class="user-years">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/weixin_43901866" data-report-click='{"mod":"popu_379"}' target="_blank">Android Developer</a></span>
                                            </div>
                    <div class="text"><span>发布了450 篇原创文章</span> · <span>获赞 730</span> · <span>访问量 20万+</span></div>
                </div>
                                <div class="right-message">
                                            <a href="https://bbs.csdn.net/topics/395532450" target="_blank"
                        class="btn btn-sm btn-red-hollow bt-button personal-messageboard">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>
    </article>
</div>
</div>
</body>
</html>
